=============================================================
Epsilon PDA
=============================================================
Root Rule Start: _Type.RootStart
Root Rule End: _Type.RootEnd
Rule Start: _Type.Start
Rule End: _Type.2.End
Rule End: _Type.6.End
Rule End: _Type.10.End
Rule End: _Type.14.End
Rule End: _Type.18.End
Rule End: _Type.22.End
Rule End: _Type.26.End
Rule End: _Type.30.End
Rule End: _Type.34.End
Rule End: _Type.38.End
Rule End: _Type.42.End
Rule End: _Type.45.End
Rule End: _Type.56.End
Rule End: _Type.60.End
Rule End: _Type.64.End
Rule End: _Type.68.End
Rule End: _Type.73.End
Rule End: _Type.80.End
Rule End: _Type.86.End
Rule End: _Type.94.End
Rule End: _Type.99.End
Rule End: _Type.103.End

Root Rule Start: _CtorFragment.RootStart
Root Rule End: _CtorFragment.RootEnd
Rule Start: _CtorFragment.Start
Rule End: _CtorFragment.2.End

Root Rule Start: _LetVariable.RootStart
Root Rule End: _LetVariable.RootEnd
Rule Start: _LetVariable.Start
Rule End: _LetVariable.2.End

Root Rule Start: _VirtualExpression.RootStart
Root Rule End: _VirtualExpression.RootEnd
Rule Start: _VirtualExpression.Start
Rule End: _VirtualExpression.2.End
Rule End: _VirtualExpression.5.End
Rule End: _VirtualExpression.11.End
Rule End: _VirtualExpression.18.End

Root Rule Start: _ExpPrimitive.RootStart
Root Rule End: _ExpPrimitive.RootEnd
Rule Start: _ExpPrimitive.Start
Rule End: _ExpPrimitive.2.End
Rule End: _ExpPrimitive.6.End
Rule End: _ExpPrimitive.10.End
Rule End: _ExpPrimitive.14.End
Rule End: _ExpPrimitive.17.End
Rule End: _ExpPrimitive.20.End
Rule End: _ExpPrimitive.23.End
Rule End: _ExpPrimitive.26.End
Rule End: _ExpPrimitive.29.End
Rule End: _ExpPrimitive.32.End
Rule End: _ExpPrimitive.36.End
Rule End: _ExpPrimitive.41.End
Rule End: _ExpPrimitive.44.End
Rule End: _ExpPrimitive.55.End
Rule End: _ExpPrimitive.67.End
Rule End: _ExpPrimitive.73.End
Rule End: _ExpPrimitive.83.End
Rule End: _ExpPrimitive.91.End
Rule End: _ExpPrimitive.105.End
Rule End: _ExpPrimitive.121.End
Rule End: _ExpPrimitive.130.End
Rule End: _ExpPrimitive.135.End
Rule End: _ExpPrimitive.140.End
Rule End: _ExpPrimitive.147.End
Rule End: _ExpPrimitive.155.End
Rule End: _ExpPrimitive.160.End
Rule End: _ExpPrimitive.175.End
Rule End: _ExpPrimitive.181.End
Rule End: _ExpPrimitive.187.End
Rule End: _ExpPrimitive.193.End
Rule End: _ExpPrimitive.199.End
Rule End: _ExpPrimitive.207.End
Rule End: _ExpPrimitive.215.End
Rule End: _ExpPrimitive.219.End

Root Rule Start: _Exp0.RootStart
Root Rule End: _Exp0.RootEnd
Rule Start: _Exp0.Start
Rule End: _Exp0.2.End
Rule End: _Exp0.4.End
Rule End: _Exp0.9.End
Rule End: _Exp0.14.End
Rule End: _Exp0.19.End
Rule End: _Exp0.25.End

Root Rule Start: _Exp1.RootStart
Root Rule End: _Exp1.RootEnd
Rule Start: _Exp1.Start
Rule End: _Exp1.2.End
Rule End: _Exp1.4.End

Root Rule Start: _Exp2.RootStart
Root Rule End: _Exp2.RootEnd
Rule Start: _Exp2.Start
Rule End: _Exp2.2.End
Rule End: _Exp2.4.End
Rule End: _Exp2.10.End
Rule End: _Exp2.16.End

Root Rule Start: _Exp3.RootStart
Root Rule End: _Exp3.RootEnd
Rule Start: _Exp3.Start
Rule End: _Exp3.2.End
Rule End: _Exp3.4.End
Rule End: _Exp3.10.End
Rule End: _Exp3.16.End
Rule End: _Exp3.22.End

Root Rule Start: _Exp4.RootStart
Root Rule End: _Exp4.RootEnd
Rule Start: _Exp4.Start
Rule End: _Exp4.2.End
Rule End: _Exp4.4.End
Rule End: _Exp4.10.End

Root Rule Start: _Exp5.RootStart
Root Rule End: _Exp5.RootEnd
Rule Start: _Exp5.Start
Rule End: _Exp5.2.End
Rule End: _Exp5.4.End
Rule End: _Exp5.10.End
Rule End: _Exp5.16.End
Rule End: _Exp5.22.End
Rule End: _Exp5.28.End
Rule End: _Exp5.34.End

Root Rule Start: _Exp6.RootStart
Root Rule End: _Exp6.RootEnd
Rule Start: _Exp6.Start
Rule End: _Exp6.2.End
Rule End: _Exp6.4.End

Root Rule Start: _Exp7.RootStart
Root Rule End: _Exp7.RootEnd
Rule Start: _Exp7.Start
Rule End: _Exp7.2.End
Rule End: _Exp7.4.End

Root Rule Start: _Exp8.RootStart
Root Rule End: _Exp8.RootEnd
Rule Start: _Exp8.Start
Rule End: _Exp8.2.End
Rule End: _Exp8.4.End

Root Rule Start: _Exp9.RootStart
Root Rule End: _Exp9.RootEnd
Rule Start: _Exp9.Start
Rule End: _Exp9.2.End
Rule End: _Exp9.4.End

Root Rule Start: _Exp10.RootStart
Root Rule End: _Exp10.RootEnd
Rule Start: _Exp10.Start
Rule End: _Exp10.2.End
Rule End: _Exp10.4.End

Root Rule Start: _Exp11.RootStart
Root Rule End: _Exp11.RootEnd
Rule Start: _Exp11.Start
Rule End: _Exp11.2.End
Rule End: _Exp11.4.End

Root Rule Start: _Expression.RootStart
Root Rule End: _Expression.RootEnd
Rule Start: _Expression.Start
Rule End: _Expression.2.End

Root Rule Start: _SwitchCase.RootStart
Root Rule End: _SwitchCase.RootEnd
Rule Start: _SwitchCase.Start
Rule End: _SwitchCase.2.End

Root Rule Start: _Block.RootStart
Root Rule End: _Block.RootEnd
Rule Start: _Block.Start
Rule End: _Block.2.End

Root Rule Start: _If.RootStart
Root Rule End: _If.RootEnd
Rule Start: _If.Start
Rule End: _If.2.End

Root Rule Start: _VirtualStatement.RootStart
Root Rule End: _VirtualStatement.RootEnd
Rule Start: _VirtualStatement.Start
Rule End: _VirtualStatement.2.End
Rule End: _VirtualStatement.15.End
Rule End: _VirtualStatement.27.End

Root Rule Start: _CoStatement.RootStart
Root Rule End: _CoStatement.RootEnd
Rule Start: _CoStatement.Start
Rule End: _CoStatement.2.End

Root Rule Start: _CoProvider.RootStart
Root Rule End: _CoProvider.RootEnd
Rule Start: _CoProvider.Start
Rule End: _CoProvider.2.End

Root Rule Start: _Statement.RootStart
Root Rule End: _Statement.RootEnd
Rule Start: _Statement.Start
Rule End: _Statement.2.End
Rule End: _Statement.4.End
Rule End: _Statement.7.End
Rule End: _Statement.11.End
Rule End: _Statement.15.End
Rule End: _Statement.20.End
Rule End: _Statement.25.End
Rule End: _Statement.30.End
Rule End: _Statement.32.End
Rule End: _Statement.39.End
Rule End: _Statement.50.End
Rule End: _Statement.54.End
Rule End: _Statement.56.End

Root Rule Start: _Attribute.RootStart
Root Rule End: _Attribute.RootEnd
Rule Start: _Attribute.Start
Rule End: _Attribute.2.End

Root Rule Start: _Namespace.RootStart
Root Rule End: _Namespace.RootEnd
Rule Start: _Namespace.Start
Rule End: _Namespace.2.End

Root Rule Start: _FunctionArgument.RootStart
Root Rule End: _FunctionArgument.RootEnd
Rule Start: _FunctionArgument.Start
Rule End: _FunctionArgument.2.End

Root Rule Start: _Function.RootStart
Root Rule End: _Function.RootEnd
Rule Start: _Function.Start
Rule End: _Function.2.End

Root Rule Start: _Variable.RootStart
Root Rule End: _Variable.RootEnd
Rule Start: _Variable.Start
Rule End: _Variable.2.End

Root Rule Start: _Event.RootStart
Root Rule End: _Event.RootEnd
Rule Start: _Event.Start
Rule End: _Event.2.End

Root Rule Start: _Property.RootStart
Root Rule End: _Property.RootEnd
Rule Start: _Property.Start
Rule End: _Property.2.End

Root Rule Start: _BaseConstructorCall.RootStart
Root Rule End: _BaseConstructorCall.RootEnd
Rule Start: _BaseConstructorCall.Start
Rule End: _BaseConstructorCall.2.End

Root Rule Start: _Constructor.RootStart
Root Rule End: _Constructor.RootEnd
Rule Start: _Constructor.Start
Rule End: _Constructor.2.End

Root Rule Start: _Destructor.RootStart
Root Rule End: _Destructor.RootEnd
Rule Start: _Destructor.Start
Rule End: _Destructor.2.End

Root Rule Start: _ClassBody.RootStart
Root Rule End: _ClassBody.RootEnd
Rule Start: _ClassBody.Start
Rule End: _ClassBody.2.End

Root Rule Start: _Class.RootStart
Root Rule End: _Class.RootEnd
Rule Start: _Class.Start
Rule End: _Class.2.End
Rule End: _Class.8.End
Rule End: _Class.14.End

Root Rule Start: _EnumItemInt.RootStart
Root Rule End: _EnumItemInt.RootEnd
Rule Start: _EnumItemInt.Start
Rule End: _EnumItemInt.2.End

Root Rule Start: _EnumItemA.RootStart
Root Rule End: _EnumItemA.RootEnd
Rule Start: _EnumItemA.Start
Rule End: _EnumItemA.2.End

Root Rule Start: _EnumItemB.RootStart
Root Rule End: _EnumItemB.RootEnd
Rule Start: _EnumItemB.Start
Rule End: _EnumItemB.2.End

Root Rule Start: _Enum.RootStart
Root Rule End: _Enum.RootEnd
Rule Start: _Enum.Start
Rule End: _Enum.2.End
Rule End: _Enum.12.End

Root Rule Start: _StructMember.RootStart
Root Rule End: _StructMember.RootEnd
Rule Start: _StructMember.Start
Rule End: _StructMember.2.End

Root Rule Start: _Struct.RootStart
Root Rule End: _Struct.RootEnd
Rule Start: _Struct.Start
Rule End: _Struct.2.End

Root Rule Start: _APConfig.RootStart
Root Rule End: _APConfig.RootEnd
Rule Start: _APConfig.Start
Rule End: _APConfig.2.End
Rule End: _APConfig.8.End
Rule End: _APConfig.15.End
Rule End: _APConfig.23.End

Root Rule Start: _AutoProperty.RootStart
Root Rule End: _AutoProperty.RootEnd
Rule Start: _AutoProperty.Start
Rule End: _AutoProperty.2.End

Root Rule Start: _CastResultInterface.RootStart
Root Rule End: _CastResultInterface.RootEnd
Rule Start: _CastResultInterface.Start
Rule End: _CastResultInterface.2.End

Root Rule Start: _SharedDeclarationBranch.RootStart
Root Rule End: _SharedDeclarationBranch.RootEnd
Rule Start: _SharedDeclarationBranch.Start
Rule End: _SharedDeclarationBranch.2.End
Rule End: _SharedDeclarationBranch.4.End
Rule End: _SharedDeclarationBranch.6.End
Rule End: _SharedDeclarationBranch.8.End
Rule End: _SharedDeclarationBranch.10.End
Rule End: _SharedDeclarationBranch.12.End
Rule End: _SharedDeclarationBranch.14.End
Rule End: _SharedDeclarationBranch.16.End
Rule End: _SharedDeclarationBranch.18.End
Rule End: _SharedDeclarationBranch.20.End

Root Rule Start: _MemberDeclarationBranch.RootStart
Root Rule End: _MemberDeclarationBranch.RootEnd
Rule Start: _MemberDeclarationBranch.Start
Rule End: _MemberDeclarationBranch.2.End
Rule End: _MemberDeclarationBranch.4.End

Root Rule Start: _Declaration.RootStart
Root Rule End: _Declaration.RootEnd
Rule Start: _Declaration.Start
Rule End: _Declaration.2.End
Rule End: _Declaration.6.End

Root Rule Start: _ClassMember.RootStart
Root Rule End: _ClassMember.RootEnd
Rule Start: _ClassMember.Start
Rule End: _ClassMember.2.End
Rule End: _ClassMember.6.End

Root Rule Start: _MemberDeclaration.RootStart
Root Rule End: _MemberDeclaration.RootEnd
Rule Start: _MemberDeclaration.Start
Rule End: _MemberDeclaration.2.End
Rule End: _MemberDeclaration.6.End

Root Rule Start: _UsingFragment.RootStart
Root Rule End: _UsingFragment.RootEnd
Rule Start: _UsingFragment.Start
Rule End: _UsingFragment.2.End
Rule End: _UsingFragment.5.End

Root Rule Start: _UsingItem.RootStart
Root Rule End: _UsingItem.RootEnd
Rule Start: _UsingItem.Start
Rule End: _UsingItem.2.End

Root Rule Start: _UsingPath.RootStart
Root Rule End: _UsingPath.RootEnd
Rule Start: _UsingPath.Start
Rule End: _UsingPath.2.End

Root Rule Start: _Module.RootStart
Root Rule End: _Module.RootEnd
Rule Start: _Module.Start
Rule End: _Module.2.End

@ $<_Type>
STATE _Type.RootStart
    TOKEN-BEGIN => _Type.Start

@ <_Type>
STATE _Type.Start
    EPSILON => _Type.1
    EPSILON => _Type.5
    EPSILON => _Type.9
    EPSILON => _Type.13
    EPSILON => _Type.17
    EPSILON => _Type.21
    EPSILON => _Type.25
    EPSILON => _Type.29
    EPSILON => _Type.33
    EPSILON => _Type.37
    EPSILON => _Type.41
    EPSILON => _Type.44
    EPSILON => _Type.55
    EPSILON => _Type.59
    EPSILON => _Type.63
    EPSILON => _Type.67
    EPSILON => _Type.72
    EPSILON => _Type.79
    EPSILON => _Type.85
    EPSILON => _Type.93
    EPSILON => _Type.98
    EPSILON => _Type.102

<_Type>: @"void" as PredefinedType with { name = "Void" }
STATE _Type.1
    [TYPE_VOID "void"] => _Type.4

<_Type>: @"object" as PredefinedType with { name = "Object" }
STATE _Type.5
    [TYPE_OBJECT "object"] => _Type.8

<_Type>: @"interface" as PredefinedType with { name = "Interface" }
STATE _Type.9
    [TYPE_INTERFACE "interface"] => _Type.12

<_Type>: @"int" as PredefinedType with { name = "Int" }
STATE _Type.13
    [TYPE_INT "int"] => _Type.16

<_Type>: @"uint" as PredefinedType with { name = "UInt" }
STATE _Type.17
    [TYPE_UINT "uint"] => _Type.20

<_Type>: @"float" as PredefinedType with { name = "Float" }
STATE _Type.21
    [TYPE_FLOAT "float"] => _Type.24

<_Type>: @"double" as PredefinedType with { name = "Double" }
STATE _Type.25
    [TYPE_DOUBLE "double"] => _Type.28

<_Type>: @"string" as PredefinedType with { name = "String" }
STATE _Type.29
    [TYPE_STRING "string"] => _Type.32

<_Type>: @"char" as PredefinedType with { name = "Char" }
STATE _Type.33
    [TYPE_CHAR "char"] => _Type.36

<_Type>: @"bool" as PredefinedType with { name = "Bool" }
STATE _Type.37
    [TYPE_BOOL "bool"] => _Type.40

<_Type>: @NAME : name as ReferenceType
STATE _Type.41
    [NAME] => _Type.43
        ASSIGN name

<_Type>: @"func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.44
    [KEYWORD_FUNC "func"] => _Type.51

<_Type>: @_Type : element "*" as RawPointerType
STATE _Type.55
    <_Type> => _Type.58
        ASSIGN element

<_Type>: @_Type : element "^" as SharedPointerType
STATE _Type.59
    <_Type> => _Type.62
        ASSIGN element

<_Type>: @_Type : element "?" as NullableType
STATE _Type.63
    <_Type> => _Type.66
        ASSIGN element

<_Type>: @_Type : element "{" "}" as EnumerableType
STATE _Type.67
    <_Type> => _Type.71
        ASSIGN element

<_Type>: @_Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Writable" }
STATE _Type.72
    <_Type> => _Type.78
        ASSIGN value

<_Type>: @"observe" _Type : element "[" "]" as ObservableListType
STATE _Type.79
    [KEYWORD_OBSERVE "observe"] => _Type.84

<_Type>: @"const" _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.85
    [KEYWORD_CONST "const"] => _Type.92

<_Type>: @_Type : parent "::" NAME : name as ChildType
STATE _Type.93
    <_Type> => _Type.97
        ASSIGN parent

<_Type>: @"::" NAME : name as TopQualifiedType
STATE _Type.98
    [SCOPE_DELIMITER "::"] => _Type.101

<_Type>: @"(" !_Type ")"
STATE _Type.102
    [OPEN_BRACKET "("] => _Type.105

<_Type>: "void" as PredefinedType@ with { name = "Void" }
STATE _Type.4
    EPSILON => _Type.3
        CREATE PredefinedType

<_Type>: "object" as PredefinedType@ with { name = "Object" }
STATE _Type.8
    EPSILON => _Type.7
        CREATE PredefinedType

<_Type>: "interface" as PredefinedType@ with { name = "Interface" }
STATE _Type.12
    EPSILON => _Type.11
        CREATE PredefinedType

<_Type>: "int" as PredefinedType@ with { name = "Int" }
STATE _Type.16
    EPSILON => _Type.15
        CREATE PredefinedType

<_Type>: "uint" as PredefinedType@ with { name = "UInt" }
STATE _Type.20
    EPSILON => _Type.19
        CREATE PredefinedType

<_Type>: "float" as PredefinedType@ with { name = "Float" }
STATE _Type.24
    EPSILON => _Type.23
        CREATE PredefinedType

<_Type>: "double" as PredefinedType@ with { name = "Double" }
STATE _Type.28
    EPSILON => _Type.27
        CREATE PredefinedType

<_Type>: "string" as PredefinedType@ with { name = "String" }
STATE _Type.32
    EPSILON => _Type.31
        CREATE PredefinedType

<_Type>: "char" as PredefinedType@ with { name = "Char" }
STATE _Type.36
    EPSILON => _Type.35
        CREATE PredefinedType

<_Type>: "bool" as PredefinedType@ with { name = "Bool" }
STATE _Type.40
    EPSILON => _Type.39
        CREATE PredefinedType

<_Type>: NAME : name as ReferenceType@
STATE _Type.43
    EPSILON => _Type.42.End
        CREATE ReferenceType

<_Type>: "func"@ "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.51
    [OPEN_BRACKET "("] => _Type.50

<_Type>: _Type : element@ "*" as RawPointerType
STATE _Type.58
    [MUL "*"] => _Type.57

<_Type>: _Type : element@ "^" as SharedPointerType
STATE _Type.62
    [EXP "^"] => _Type.61

<_Type>: _Type : element@ "?" as NullableType
STATE _Type.66
    [QUESTION_MARK "?"] => _Type.65

<_Type>: _Type : element@ "{" "}" as EnumerableType
STATE _Type.71
    [OPEN_BRACE "{"] => _Type.70

<_Type>: _Type : value@ "[" [ _Type : key ] "]" as MapType with { writability = "Writable" }
STATE _Type.78
    [OPEN_ARRAY "["] => _Type.77

<_Type>: "observe"@ _Type : element "[" "]" as ObservableListType
STATE _Type.84
    <_Type> => _Type.83
        ASSIGN element

<_Type>: "const"@ _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.92
    <_Type> => _Type.91
        ASSIGN value

<_Type>: _Type : parent@ "::" NAME : name as ChildType
STATE _Type.97
    [SCOPE_DELIMITER "::"] => _Type.96

<_Type>: "::"@ NAME : name as TopQualifiedType
STATE _Type.101
    [NAME] => _Type.100
        ASSIGN name

<_Type>: "("@ !_Type ")"
STATE _Type.105
    <_Type> => _Type.104
        USING 

<_Type>: "void" as PredefinedType@ with { name = "Void" }
STATE _Type.3
    EPSILON => _Type.2.End
        SET name => Void

<_Type>: "object" as PredefinedType@ with { name = "Object" }
STATE _Type.7
    EPSILON => _Type.6.End
        SET name => Object

<_Type>: "interface" as PredefinedType@ with { name = "Interface" }
STATE _Type.11
    EPSILON => _Type.10.End
        SET name => Interface

<_Type>: "int" as PredefinedType@ with { name = "Int" }
STATE _Type.15
    EPSILON => _Type.14.End
        SET name => Int

<_Type>: "uint" as PredefinedType@ with { name = "UInt" }
STATE _Type.19
    EPSILON => _Type.18.End
        SET name => UInt

<_Type>: "float" as PredefinedType@ with { name = "Float" }
STATE _Type.23
    EPSILON => _Type.22.End
        SET name => Float

<_Type>: "double" as PredefinedType@ with { name = "Double" }
STATE _Type.27
    EPSILON => _Type.26.End
        SET name => Double

<_Type>: "string" as PredefinedType@ with { name = "String" }
STATE _Type.31
    EPSILON => _Type.30.End
        SET name => String

<_Type>: "char" as PredefinedType@ with { name = "Char" }
STATE _Type.35
    EPSILON => _Type.34.End
        SET name => Char

<_Type>: "bool" as PredefinedType@ with { name = "Bool" }
STATE _Type.39
    EPSILON => _Type.38.End
        SET name => Bool

<_Type>: NAME : name as ReferenceType@
END STATE _Type.42.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "func" "("@ [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.50
    <_Type> => _Type.52
        ASSIGN arguments
    EPSILON => _Type.49

<_Type>: _Type : element "*" as RawPointerType@
STATE _Type.57
    EPSILON => _Type.56.End
        CREATE RawPointerType

<_Type>: _Type : element "^" as SharedPointerType@
STATE _Type.61
    EPSILON => _Type.60.End
        CREATE SharedPointerType

<_Type>: _Type : element "?" as NullableType@
STATE _Type.65
    EPSILON => _Type.64.End
        CREATE NullableType

<_Type>: _Type : element "{"@ "}" as EnumerableType
STATE _Type.70
    [CLOSE_BRACE "}"] => _Type.69

<_Type>: _Type : value "["@ [ _Type : key ] "]" as MapType with { writability = "Writable" }
STATE _Type.77
    <_Type> => _Type.76
        ASSIGN key
    EPSILON => _Type.76

<_Type>: "observe" _Type : element@ "[" "]" as ObservableListType
STATE _Type.83
    [OPEN_ARRAY "["] => _Type.82

<_Type>: "const" _Type : value@ "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.91
    [OPEN_ARRAY "["] => _Type.90

<_Type>: _Type : parent "::"@ NAME : name as ChildType
STATE _Type.96
    [NAME] => _Type.95
        ASSIGN name

<_Type>: "::" NAME : name as TopQualifiedType@
STATE _Type.100
    EPSILON => _Type.99.End
        CREATE TopQualifiedType

<_Type>: "(" !_Type@ ")"
STATE _Type.104
    [CLOSE_BRACKET ")"] => _Type.103.End

<_Type>: "void" as PredefinedType with { name = "Void" }@
END STATE _Type.2.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "object" as PredefinedType with { name = "Object" }@
END STATE _Type.6.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "interface" as PredefinedType with { name = "Interface" }@
END STATE _Type.10.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "int" as PredefinedType with { name = "Int" }@
END STATE _Type.14.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "uint" as PredefinedType with { name = "UInt" }@
END STATE _Type.18.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "float" as PredefinedType with { name = "Float" }@
END STATE _Type.22.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "double" as PredefinedType with { name = "Double" }@
END STATE _Type.26.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "string" as PredefinedType with { name = "String" }@
END STATE _Type.30.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "char" as PredefinedType with { name = "Char" }@
END STATE _Type.34.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "bool" as PredefinedType with { name = "Bool" }@
END STATE _Type.38.End
    TOKEN-FINISH => _Type.RootEnd

$<_Type> @
STATE _Type.RootEnd

<_Type>: "func" "(" [ _Type : arguments@ { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.52
    EPSILON => _Type.53

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ]@ ")" ":" _Type : result as FunctionType
STATE _Type.49
    [CLOSE_BRACKET ")"] => _Type.48

<_Type>: _Type : element "*" as RawPointerType@
END STATE _Type.56.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: _Type : element "^" as SharedPointerType@
END STATE _Type.60.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: _Type : element "?" as NullableType@
END STATE _Type.64.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: _Type : element "{" "}" as EnumerableType@
STATE _Type.69
    EPSILON => _Type.68.End
        CREATE EnumerableType

<_Type>: _Type : value "[" [ _Type : key ]@ "]" as MapType with { writability = "Writable" }
STATE _Type.76
    [CLOSE_ARRAY "]"] => _Type.75

<_Type>: "observe" _Type : element "["@ "]" as ObservableListType
STATE _Type.82
    [CLOSE_ARRAY "]"] => _Type.81

<_Type>: "const" _Type : value "["@ [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.90
    <_Type> => _Type.89
        ASSIGN key
    EPSILON => _Type.89

<_Type>: _Type : parent "::" NAME : name as ChildType@
STATE _Type.95
    EPSILON => _Type.94.End
        CREATE ChildType

<_Type>: "::" NAME : name as TopQualifiedType@
END STATE _Type.99.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "(" !_Type ")"@
END STATE _Type.103.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "func" "(" [ _Type : arguments @{ "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.53
    EPSILON => _Type.49
    [COMMA ","] => _Type.54

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")"@ ":" _Type : result as FunctionType
STATE _Type.48
    [COLON ":"] => _Type.47

<_Type>: _Type : element "{" "}" as EnumerableType@
END STATE _Type.68.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: _Type : value "[" [ _Type : key ] "]" as MapType@ with { writability = "Writable" }
STATE _Type.75
    EPSILON => _Type.74
        CREATE MapType

<_Type>: "observe" _Type : element "[" "]" as ObservableListType@
STATE _Type.81
    EPSILON => _Type.80.End
        CREATE ObservableListType

<_Type>: "const" _Type : value "[" [ _Type : key ]@ "]" as MapType with { writability = "Readonly" }
STATE _Type.89
    [CLOSE_ARRAY "]"] => _Type.88

<_Type>: _Type : parent "::" NAME : name as ChildType@
END STATE _Type.94.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "func" "(" [ _Type : arguments { ","@ _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.54
    <_Type> => _Type.53
        ASSIGN arguments

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":"@ _Type : result as FunctionType
STATE _Type.47
    <_Type> => _Type.46
        ASSIGN result

<_Type>: _Type : value "[" [ _Type : key ] "]" as MapType@ with { writability = "Writable" }
STATE _Type.74
    EPSILON => _Type.73.End
        SET writability => Writable

<_Type>: "observe" _Type : element "[" "]" as ObservableListType@
END STATE _Type.80.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "const" _Type : value "[" [ _Type : key ] "]" as MapType@ with { writability = "Readonly" }
STATE _Type.88
    EPSILON => _Type.87
        CREATE MapType

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType@
STATE _Type.46
    EPSILON => _Type.45.End
        CREATE FunctionType

<_Type>: _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Writable" }@
END STATE _Type.73.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "const" _Type : value "[" [ _Type : key ] "]" as MapType@ with { writability = "Readonly" }
STATE _Type.87
    EPSILON => _Type.86.End
        SET writability => Readonly

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType@
END STATE _Type.45.End
    TOKEN-FINISH => _Type.RootEnd

<_Type>: "const" _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }@
END STATE _Type.86.End
    TOKEN-FINISH => _Type.RootEnd

--------------------------------
@ $<_CtorFragment>
STATE _CtorFragment.RootStart
    TOKEN-BEGIN => _CtorFragment.Start

@ <_CtorFragment>
STATE _CtorFragment.Start
    EPSILON => _CtorFragment.1

<_CtorFragment>: @_Expression : key [ ":" _Expression : value ] as ConstructorArgument
STATE _CtorFragment.1
    <_Expression> => _CtorFragment.4
        ASSIGN key

<_CtorFragment>: _Expression : key@ [ ":" _Expression : value ] as ConstructorArgument
STATE _CtorFragment.4
    [COLON ":"] => _CtorFragment.5
    EPSILON => _CtorFragment.3

<_CtorFragment>: _Expression : key [ ":"@ _Expression : value ] as ConstructorArgument
STATE _CtorFragment.5
    <_Expression> => _CtorFragment.3
        ASSIGN value

<_CtorFragment>: _Expression : key [ ":" _Expression : value ] as ConstructorArgument@
STATE _CtorFragment.3
    EPSILON => _CtorFragment.2.End
        CREATE ConstructorArgument

<_CtorFragment>: _Expression : key [ ":" _Expression : value ] as ConstructorArgument@
END STATE _CtorFragment.2.End
    TOKEN-FINISH => _CtorFragment.RootEnd

$<_CtorFragment> @
STATE _CtorFragment.RootEnd

--------------------------------
@ $<_LetVariable>
STATE _LetVariable.RootStart
    TOKEN-BEGIN => _LetVariable.Start

@ <_LetVariable>
STATE _LetVariable.Start
    EPSILON => _LetVariable.1

<_LetVariable>: @NAME : name "=" _Expression : value as LetVariable
STATE _LetVariable.1
    [NAME] => _LetVariable.5
        ASSIGN name

<_LetVariable>: NAME : name@ "=" _Expression : value as LetVariable
STATE _LetVariable.5
    [ASSIGN "="] => _LetVariable.4

<_LetVariable>: NAME : name "="@ _Expression : value as LetVariable
STATE _LetVariable.4
    <_Expression> => _LetVariable.3
        ASSIGN value

<_LetVariable>: NAME : name "=" _Expression : value as LetVariable@
STATE _LetVariable.3
    EPSILON => _LetVariable.2.End
        CREATE LetVariable

<_LetVariable>: NAME : name "=" _Expression : value as LetVariable@
END STATE _LetVariable.2.End
    TOKEN-FINISH => _LetVariable.RootEnd

$<_LetVariable> @
STATE _LetVariable.RootEnd

--------------------------------
@ $<_VirtualExpression>
STATE _VirtualExpression.RootStart
    TOKEN-BEGIN => _VirtualExpression.Start

@ <_VirtualExpression>
STATE _VirtualExpression.Start
    EPSILON => _VirtualExpression.1
    EPSILON => _VirtualExpression.4
    EPSILON => _VirtualExpression.10
    EPSILON => _VirtualExpression.17

<_VirtualExpression>: @FORMATSTRING : value as FormatExpression
STATE _VirtualExpression.1
    [FORMATSTRING] => _VirtualExpression.3
        ASSIGN value

<_VirtualExpression>: @"bind" "(" _Expression : expression ")" as BindExpression
STATE _VirtualExpression.4
    [KEYWORD_BIND "bind"] => _VirtualExpression.9

<_VirtualExpression>: @"$coroutine" [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.10
    [COROUTINE_COROUTINE "$coroutine"] => _VirtualExpression.14

<_VirtualExpression>: @"new" _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.17
    [KEYWORD_NEW "new"] => _VirtualExpression.24

<_VirtualExpression>: FORMATSTRING : value as FormatExpression@
STATE _VirtualExpression.3
    EPSILON => _VirtualExpression.2.End
        CREATE FormatExpression

<_VirtualExpression>: "bind"@ "(" _Expression : expression ")" as BindExpression
STATE _VirtualExpression.9
    [OPEN_BRACKET "("] => _VirtualExpression.8

<_VirtualExpression>: "$coroutine"@ [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.14
    [OPEN_BRACKET "("] => _VirtualExpression.16
    EPSILON => _VirtualExpression.13

<_VirtualExpression>: "new"@ _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.24
    <_Type> => _VirtualExpression.23
        ASSIGN type

<_VirtualExpression>: FORMATSTRING : value as FormatExpression@
END STATE _VirtualExpression.2.End
    TOKEN-FINISH => _VirtualExpression.RootEnd

<_VirtualExpression>: "bind" "("@ _Expression : expression ")" as BindExpression
STATE _VirtualExpression.8
    <_Expression> => _VirtualExpression.7
        ASSIGN expression

<_VirtualExpression>: "$coroutine" [ "("@ NAME : name ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.16
    [NAME] => _VirtualExpression.15
        ASSIGN name

<_VirtualExpression>: "$coroutine" [ "(" NAME : name ")" ]@ _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.13
    <_Block> => _VirtualExpression.12
        ASSIGN statement

<_VirtualExpression>: "new" _Type : type@ "(" "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.23
    [OPEN_BRACKET "("] => _VirtualExpression.22

$<_VirtualExpression> @
STATE _VirtualExpression.RootEnd

<_VirtualExpression>: "bind" "(" _Expression : expression@ ")" as BindExpression
STATE _VirtualExpression.7
    [CLOSE_BRACKET ")"] => _VirtualExpression.6

<_VirtualExpression>: "$coroutine" [ "(" NAME : name@ ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.15
    [CLOSE_BRACKET ")"] => _VirtualExpression.13

<_VirtualExpression>: "$coroutine" [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression@
STATE _VirtualExpression.12
    EPSILON => _VirtualExpression.11.End
        CREATE NewCoroutineExpression

<_VirtualExpression>: "new" _Type : type "("@ "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.22
    [KEYWORD_USING "using"] => _VirtualExpression.21

<_VirtualExpression>: "bind" "(" _Expression : expression ")" as BindExpression@
STATE _VirtualExpression.6
    EPSILON => _VirtualExpression.5.End
        CREATE BindExpression

<_VirtualExpression>: "$coroutine" [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression@
END STATE _VirtualExpression.11.End
    TOKEN-FINISH => _VirtualExpression.RootEnd

<_VirtualExpression>: "new" _Type : type "(" "using"@ _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.21
    <_Expression> => _VirtualExpression.20
        ASSIGN expression

<_VirtualExpression>: "bind" "(" _Expression : expression ")" as BindExpression@
END STATE _VirtualExpression.5.End
    TOKEN-FINISH => _VirtualExpression.RootEnd

<_VirtualExpression>: "new" _Type : type "(" "using" _Expression : expression@ ")" as MixinCastExpression
STATE _VirtualExpression.20
    [CLOSE_BRACKET ")"] => _VirtualExpression.19

<_VirtualExpression>: "new" _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression@
STATE _VirtualExpression.19
    EPSILON => _VirtualExpression.18.End
        CREATE MixinCastExpression

<_VirtualExpression>: "new" _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression@
END STATE _VirtualExpression.18.End
    TOKEN-FINISH => _VirtualExpression.RootEnd

--------------------------------
@ $<_ExpPrimitive>
STATE _ExpPrimitive.RootStart
    TOKEN-BEGIN => _ExpPrimitive.Start

@ <_ExpPrimitive>
STATE _ExpPrimitive.Start
    EPSILON => _ExpPrimitive.1
    EPSILON => _ExpPrimitive.5
    EPSILON => _ExpPrimitive.9
    EPSILON => _ExpPrimitive.13
    EPSILON => _ExpPrimitive.16
    EPSILON => _ExpPrimitive.19
    EPSILON => _ExpPrimitive.22
    EPSILON => _ExpPrimitive.25
    EPSILON => _ExpPrimitive.28
    EPSILON => _ExpPrimitive.31
    EPSILON => _ExpPrimitive.35
    EPSILON => _ExpPrimitive.40
    EPSILON => _ExpPrimitive.43
    EPSILON => _ExpPrimitive.54
    EPSILON => _ExpPrimitive.66
    EPSILON => _ExpPrimitive.72
    EPSILON => _ExpPrimitive.82
    EPSILON => _ExpPrimitive.90
    EPSILON => _ExpPrimitive.104
    EPSILON => _ExpPrimitive.120
    EPSILON => _ExpPrimitive.129
    EPSILON => _ExpPrimitive.134
    EPSILON => _ExpPrimitive.139
    EPSILON => _ExpPrimitive.146
    EPSILON => _ExpPrimitive.154
    EPSILON => _ExpPrimitive.159
    EPSILON => _ExpPrimitive.174
    EPSILON => _ExpPrimitive.180
    EPSILON => _ExpPrimitive.186
    EPSILON => _ExpPrimitive.192
    EPSILON => _ExpPrimitive.198
    EPSILON => _ExpPrimitive.206
    EPSILON => _ExpPrimitive.214
    EPSILON => _ExpPrimitive.218

<_ExpPrimitive>: @"null" as LiteralExpression with { value = "Null" }
STATE _ExpPrimitive.1
    [KEYWORD_NULL "null"] => _ExpPrimitive.4

<_ExpPrimitive>: @"true" as LiteralExpression with { value = "True" }
STATE _ExpPrimitive.5
    [KEYWORD_TRUE "true"] => _ExpPrimitive.8

<_ExpPrimitive>: @"false" as LiteralExpression with { value = "False" }
STATE _ExpPrimitive.9
    [KEYWORD_FALSE "false"] => _ExpPrimitive.12

<_ExpPrimitive>: @INTEGER : value as IntegerExpression
STATE _ExpPrimitive.13
    [INTEGER] => _ExpPrimitive.15
        ASSIGN value

<_ExpPrimitive>: @FLOAT : value as FloatingExpression
STATE _ExpPrimitive.16
    [FLOAT] => _ExpPrimitive.18
        ASSIGN value

<_ExpPrimitive>: @STRING : value as StringExpression
STATE _ExpPrimitive.19
    [STRING] => _ExpPrimitive.21
        ASSIGN value

<_ExpPrimitive>: @"this" as ThisExpression
STATE _ExpPrimitive.22
    [KEYWORD_THIS "this"] => _ExpPrimitive.24

<_ExpPrimitive>: @NAME : name as ReferenceExpression
STATE _ExpPrimitive.25
    [NAME] => _ExpPrimitive.27
        ASSIGN name

<_ExpPrimitive>: @ORDERED_NAME : name as OrderedNameExpression
STATE _ExpPrimitive.28
    [ORDERED_NAME] => _ExpPrimitive.30
        ASSIGN name

<_ExpPrimitive>: @"(" !_Expression ")"
STATE _ExpPrimitive.31
    [OPEN_BRACKET "("] => _ExpPrimitive.34

<_ExpPrimitive>: @"[" _Expression : body "]" as OrderedLambdaExpression
STATE _ExpPrimitive.35
    [OPEN_ARRAY "["] => _ExpPrimitive.39

<_ExpPrimitive>: @_Function : function as FunctionExpression
STATE _ExpPrimitive.40
    <_Function> => _ExpPrimitive.42
        ASSIGN function

<_ExpPrimitive>: @"let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.43
    [KEYWORD_LET "let"] => _ExpPrimitive.51

<_ExpPrimitive>: @"range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.54
    [KEYWORD_RANGE "range"] => _ExpPrimitive.61

<_ExpPrimitive>: @"{" { _CtorFragment : arguments } "}" as ConstructorExpression
STATE _ExpPrimitive.66
    [OPEN_BRACE "{"] => _ExpPrimitive.70

<_ExpPrimitive>: @"new" _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.72
    [KEYWORD_NEW "new"] => _ExpPrimitive.78

<_ExpPrimitive>: @"new" _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.82
    [KEYWORD_NEW "new"] => _ExpPrimitive.88

<_ExpPrimitive>: @_ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.90
    <_ExpPrimitive> => _ExpPrimitive.99
        ASSIGN parent

<_ExpPrimitive>: @_ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.104
    <_ExpPrimitive> => _ExpPrimitive.115
        ASSIGN parent

<_ExpPrimitive>: @_ExpPrimitive : function "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.120
    <_ExpPrimitive> => _ExpPrimitive.125
        ASSIGN function

<_ExpPrimitive>: @_ExpPrimitive : parent "." NAME : name as MemberExpression
STATE _ExpPrimitive.129
    <_ExpPrimitive> => _ExpPrimitive.133
        ASSIGN parent

<_ExpPrimitive>: @_ExpPrimitive : parent "::" NAME : name as ChildExpression
STATE _ExpPrimitive.134
    <_ExpPrimitive> => _ExpPrimitive.138
        ASSIGN parent

<_ExpPrimitive>: @_ExpPrimitive : first "[" _Expression : second "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.139
    <_ExpPrimitive> => _ExpPrimitive.145
        ASSIGN first

<_ExpPrimitive>: @_ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.146
    <_ExpPrimitive> => _ExpPrimitive.150
        ASSIGN element

<_ExpPrimitive>: @_ExpPrimitive : expression "of" _Type : type as InferExpression
STATE _ExpPrimitive.154
    <_ExpPrimitive> => _ExpPrimitive.158
        ASSIGN expression

<_ExpPrimitive>: @_ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.159
    <_ExpPrimitive> => _ExpPrimitive.161
        ASSIGN expression

<_ExpPrimitive>: @_ExpPrimitive : expression "as" _Type : type as TypeCastingExpression with { strategy = "Weak" }
STATE _ExpPrimitive.174
    <_ExpPrimitive> => _ExpPrimitive.179
        ASSIGN expression

<_ExpPrimitive>: @_ExpPrimitive : expression "as" "*" as ExpectedTypeCastExpression with { strategy = "Weak" }
STATE _ExpPrimitive.180
    <_ExpPrimitive> => _ExpPrimitive.185
        ASSIGN expression

<_ExpPrimitive>: @"typeof" "(" _Type : type ")" as TypeOfTypeExpression
STATE _ExpPrimitive.186
    [KEYWORD_TYPEOF "typeof"] => _ExpPrimitive.191

<_ExpPrimitive>: @"type" "(" _Expression : expression ")" as TypeOfExpressionExpression
STATE _ExpPrimitive.192
    [KEYWORD_TYPE "type"] => _ExpPrimitive.197

<_ExpPrimitive>: @"attach" "(" _Expression : event "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.198
    [KEYWORD_ATTACH "attach"] => _ExpPrimitive.205

<_ExpPrimitive>: @"detach" "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.206
    [KEYWORD_DETACH "detach"] => _ExpPrimitive.213

<_ExpPrimitive>: @"::" NAME : name as TopQualifiedExpression
STATE _ExpPrimitive.214
    [SCOPE_DELIMITER "::"] => _ExpPrimitive.217

<_ExpPrimitive>: @!_VirtualExpression
STATE _ExpPrimitive.218
    <_VirtualExpression> => _ExpPrimitive.219.End
        USING 

<_ExpPrimitive>: "null" as LiteralExpression@ with { value = "Null" }
STATE _ExpPrimitive.4
    EPSILON => _ExpPrimitive.3
        CREATE LiteralExpression

<_ExpPrimitive>: "true" as LiteralExpression@ with { value = "True" }
STATE _ExpPrimitive.8
    EPSILON => _ExpPrimitive.7
        CREATE LiteralExpression

<_ExpPrimitive>: "false" as LiteralExpression@ with { value = "False" }
STATE _ExpPrimitive.12
    EPSILON => _ExpPrimitive.11
        CREATE LiteralExpression

<_ExpPrimitive>: INTEGER : value as IntegerExpression@
STATE _ExpPrimitive.15
    EPSILON => _ExpPrimitive.14.End
        CREATE IntegerExpression

<_ExpPrimitive>: FLOAT : value as FloatingExpression@
STATE _ExpPrimitive.18
    EPSILON => _ExpPrimitive.17.End
        CREATE FloatingExpression

<_ExpPrimitive>: STRING : value as StringExpression@
STATE _ExpPrimitive.21
    EPSILON => _ExpPrimitive.20.End
        CREATE StringExpression

<_ExpPrimitive>: "this" as ThisExpression@
STATE _ExpPrimitive.24
    EPSILON => _ExpPrimitive.23.End
        CREATE ThisExpression

<_ExpPrimitive>: NAME : name as ReferenceExpression@
STATE _ExpPrimitive.27
    EPSILON => _ExpPrimitive.26.End
        CREATE ReferenceExpression

<_ExpPrimitive>: ORDERED_NAME : name as OrderedNameExpression@
STATE _ExpPrimitive.30
    EPSILON => _ExpPrimitive.29.End
        CREATE OrderedNameExpression

<_ExpPrimitive>: "("@ !_Expression ")"
STATE _ExpPrimitive.34
    <_Expression> => _ExpPrimitive.33
        USING 

<_ExpPrimitive>: "["@ _Expression : body "]" as OrderedLambdaExpression
STATE _ExpPrimitive.39
    <_Expression> => _ExpPrimitive.38
        ASSIGN body

<_ExpPrimitive>: _Function : function as FunctionExpression@
STATE _ExpPrimitive.42
    EPSILON => _ExpPrimitive.41.End
        CREATE FunctionExpression

<_ExpPrimitive>: "let"@ _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.51
    <_LetVariable> => _ExpPrimitive.50
        ASSIGN variables

<_ExpPrimitive>: "range"@ ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.61
    [OPEN_BRACKET "("] => _ExpPrimitive.62
    [OPEN_ARRAY "["] => _ExpPrimitive.63

<_ExpPrimitive>: "{"@ { _CtorFragment : arguments } "}" as ConstructorExpression
STATE _ExpPrimitive.70
    EPSILON => _ExpPrimitive.71

<_ExpPrimitive>: "new"@ _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.78
    <_Type> => _ExpPrimitive.77
        ASSIGN type

<_ExpPrimitive>: "new"@ _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.88
    <_Type> => _ExpPrimitive.87
        ASSIGN type

<_ExpPrimitive>: _ExpPrimitive : parent@ "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.99
    [DOT "."] => _ExpPrimitive.98

<_ExpPrimitive>: _ExpPrimitive : parent@ "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.115
    [DOT "."] => _ExpPrimitive.114

<_ExpPrimitive>: _ExpPrimitive : function@ "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.125
    [OPEN_BRACKET "("] => _ExpPrimitive.124

<_ExpPrimitive>: _ExpPrimitive : parent@ "." NAME : name as MemberExpression
STATE _ExpPrimitive.133
    [DOT "."] => _ExpPrimitive.132

<_ExpPrimitive>: _ExpPrimitive : parent@ "::" NAME : name as ChildExpression
STATE _ExpPrimitive.138
    [SCOPE_DELIMITER "::"] => _ExpPrimitive.137

<_ExpPrimitive>: _ExpPrimitive : first@ "[" _Expression : second "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.145
    [OPEN_ARRAY "["] => _ExpPrimitive.144

<_ExpPrimitive>: _ExpPrimitive : element@ ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.150
    [KEYWORD_IN "in"] => _ExpPrimitive.151
    [KEYWORD_NOT "not"] => _ExpPrimitive.153

<_ExpPrimitive>: _ExpPrimitive : expression@ "of" _Type : type as InferExpression
STATE _ExpPrimitive.158
    [KEYWORD_OF "of"] => _ExpPrimitive.157

<_ExpPrimitive>: _ExpPrimitive : expression@ ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.161
    [KEYWORD_IS "is"] => _ExpPrimitive.164
    [KEYWORD_IS "is"] => _ExpPrimitive.166
    [KEYWORD_IS "is"] => _ExpPrimitive.169
    [KEYWORD_IS "is"] => _ExpPrimitive.173

<_ExpPrimitive>: _ExpPrimitive : expression@ "as" _Type : type as TypeCastingExpression with { strategy = "Weak" }
STATE _ExpPrimitive.179
    [KEYWORD_AS "as"] => _ExpPrimitive.178

<_ExpPrimitive>: _ExpPrimitive : expression@ "as" "*" as ExpectedTypeCastExpression with { strategy = "Weak" }
STATE _ExpPrimitive.185
    [KEYWORD_AS "as"] => _ExpPrimitive.184

<_ExpPrimitive>: "typeof"@ "(" _Type : type ")" as TypeOfTypeExpression
STATE _ExpPrimitive.191
    [OPEN_BRACKET "("] => _ExpPrimitive.190

<_ExpPrimitive>: "type"@ "(" _Expression : expression ")" as TypeOfExpressionExpression
STATE _ExpPrimitive.197
    [OPEN_BRACKET "("] => _ExpPrimitive.196

<_ExpPrimitive>: "attach"@ "(" _Expression : event "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.205
    [OPEN_BRACKET "("] => _ExpPrimitive.204

<_ExpPrimitive>: "detach"@ "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.213
    [OPEN_BRACKET "("] => _ExpPrimitive.212

<_ExpPrimitive>: "::"@ NAME : name as TopQualifiedExpression
STATE _ExpPrimitive.217
    [NAME] => _ExpPrimitive.216
        ASSIGN name

<_ExpPrimitive>: !_VirtualExpression@
END STATE _ExpPrimitive.219.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "null" as LiteralExpression@ with { value = "Null" }
STATE _ExpPrimitive.3
    EPSILON => _ExpPrimitive.2.End
        SET value => Null

<_ExpPrimitive>: "true" as LiteralExpression@ with { value = "True" }
STATE _ExpPrimitive.7
    EPSILON => _ExpPrimitive.6.End
        SET value => True

<_ExpPrimitive>: "false" as LiteralExpression@ with { value = "False" }
STATE _ExpPrimitive.11
    EPSILON => _ExpPrimitive.10.End
        SET value => False

<_ExpPrimitive>: INTEGER : value as IntegerExpression@
END STATE _ExpPrimitive.14.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: FLOAT : value as FloatingExpression@
END STATE _ExpPrimitive.17.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: STRING : value as StringExpression@
END STATE _ExpPrimitive.20.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "this" as ThisExpression@
END STATE _ExpPrimitive.23.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: NAME : name as ReferenceExpression@
END STATE _ExpPrimitive.26.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: ORDERED_NAME : name as OrderedNameExpression@
END STATE _ExpPrimitive.29.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "(" !_Expression@ ")"
STATE _ExpPrimitive.33
    [CLOSE_BRACKET ")"] => _ExpPrimitive.32.End

<_ExpPrimitive>: "[" _Expression : body@ "]" as OrderedLambdaExpression
STATE _ExpPrimitive.38
    [CLOSE_ARRAY "]"] => _ExpPrimitive.37

<_ExpPrimitive>: _Function : function as FunctionExpression@
END STATE _ExpPrimitive.41.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "let" _LetVariable : variables@ { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.50
    EPSILON => _ExpPrimitive.52

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) )@ _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.62
    EPSILON => _ExpPrimitive.60
        SET beginBoundary => Exclusive

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) )@ _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.63
    EPSILON => _ExpPrimitive.60
        SET beginBoundary => Inclusive

<_ExpPrimitive>: "{" @{ _CtorFragment : arguments } "}" as ConstructorExpression
STATE _ExpPrimitive.71
    EPSILON => _ExpPrimitive.69
    <_CtorFragment> => _ExpPrimitive.71
        ASSIGN arguments

<_ExpPrimitive>: "new" _Type : type@ "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.77
    [OPEN_BRACKET "("] => _ExpPrimitive.76

<_ExpPrimitive>: "new" _Type : type@ "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.87
    [OPEN_BRACE "{"] => _ExpPrimitive.86

<_ExpPrimitive>: _ExpPrimitive : parent "."@ "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.98
    [KEYWORD_OBSERVE "observe"] => _ExpPrimitive.97

<_ExpPrimitive>: _ExpPrimitive : parent "."@ "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.114
    [KEYWORD_OBSERVE "observe"] => _ExpPrimitive.113

<_ExpPrimitive>: _ExpPrimitive : function "("@ [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.124
    <_Expression> => _ExpPrimitive.126
        ASSIGN arguments
    EPSILON => _ExpPrimitive.123

<_ExpPrimitive>: _ExpPrimitive : parent "."@ NAME : name as MemberExpression
STATE _ExpPrimitive.132
    [NAME] => _ExpPrimitive.131
        ASSIGN name

<_ExpPrimitive>: _ExpPrimitive : parent "::"@ NAME : name as ChildExpression
STATE _ExpPrimitive.137
    [NAME] => _ExpPrimitive.136
        ASSIGN name

<_ExpPrimitive>: _ExpPrimitive : first "["@ _Expression : second "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.144
    <_Expression> => _ExpPrimitive.143
        ASSIGN second

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) )@ _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.151
    EPSILON => _ExpPrimitive.149
        SET test => In

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not"@ "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.153
    [KEYWORD_IN "in"] => _ExpPrimitive.152

<_ExpPrimitive>: _ExpPrimitive : expression "of"@ _Type : type as InferExpression
STATE _ExpPrimitive.157
    <_Type> => _ExpPrimitive.156
        ASSIGN type

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) )@ _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.164
    EPSILON => _ExpPrimitive.163
        SET test => IsType

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is"@ "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.166
    [KEYWORD_NOT "not"] => _ExpPrimitive.165

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is"@ "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.169
    [KEYWORD_NULL "null"] => _ExpPrimitive.168

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is"@ "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.173
    [KEYWORD_NOT "not"] => _ExpPrimitive.172

<_ExpPrimitive>: _ExpPrimitive : expression "as"@ _Type : type as TypeCastingExpression with { strategy = "Weak" }
STATE _ExpPrimitive.178
    <_Type> => _ExpPrimitive.177
        ASSIGN type

<_ExpPrimitive>: _ExpPrimitive : expression "as"@ "*" as ExpectedTypeCastExpression with { strategy = "Weak" }
STATE _ExpPrimitive.184
    [MUL "*"] => _ExpPrimitive.183

<_ExpPrimitive>: "typeof" "("@ _Type : type ")" as TypeOfTypeExpression
STATE _ExpPrimitive.190
    <_Type> => _ExpPrimitive.189
        ASSIGN type

<_ExpPrimitive>: "type" "("@ _Expression : expression ")" as TypeOfExpressionExpression
STATE _ExpPrimitive.196
    <_Expression> => _ExpPrimitive.195
        ASSIGN expression

<_ExpPrimitive>: "attach" "("@ _Expression : event "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.204
    <_Expression> => _ExpPrimitive.203
        ASSIGN event

<_ExpPrimitive>: "detach" "("@ _Expression : event "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.212
    <_Expression> => _ExpPrimitive.211
        ASSIGN event

<_ExpPrimitive>: "::" NAME : name as TopQualifiedExpression@
STATE _ExpPrimitive.216
    EPSILON => _ExpPrimitive.215.End
        CREATE TopQualifiedExpression

$<_ExpPrimitive> @
STATE _ExpPrimitive.RootEnd

<_ExpPrimitive>: "null" as LiteralExpression with { value = "Null" }@
END STATE _ExpPrimitive.2.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "true" as LiteralExpression with { value = "True" }@
END STATE _ExpPrimitive.6.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "false" as LiteralExpression with { value = "False" }@
END STATE _ExpPrimitive.10.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "(" !_Expression ")"@
END STATE _ExpPrimitive.32.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "[" _Expression : body "]" as OrderedLambdaExpression@
STATE _ExpPrimitive.37
    EPSILON => _ExpPrimitive.36.End
        CREATE OrderedLambdaExpression

<_ExpPrimitive>: "let" _LetVariable : variables @{ "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.52
    EPSILON => _ExpPrimitive.49
    [COMMA ","] => _ExpPrimitive.53

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) )@ _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.60
    <_Expression> => _ExpPrimitive.59
        ASSIGN begin

<_ExpPrimitive>: "{" { _CtorFragment : arguments }@ "}" as ConstructorExpression
STATE _ExpPrimitive.69
    [CLOSE_BRACE "}"] => _ExpPrimitive.68

<_ExpPrimitive>: "new" _Type : type "("@ [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.76
    <_Expression> => _ExpPrimitive.79
        ASSIGN arguments
    EPSILON => _ExpPrimitive.75

<_ExpPrimitive>: "new" _Type : type "{"@ { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.86
    EPSILON => _ExpPrimitive.89

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe"@ "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.97
    [OPEN_BRACKET "("] => _ExpPrimitive.96

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe"@ "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.113
    [KEYWORD_AS "as"] => _ExpPrimitive.112

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments@ { "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.126
    EPSILON => _ExpPrimitive.127

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { "," _Expression : arguments } ]@ ")" as CallExpression
STATE _ExpPrimitive.123
    [CLOSE_BRACKET ")"] => _ExpPrimitive.122

<_ExpPrimitive>: _ExpPrimitive : parent "." NAME : name as MemberExpression@
STATE _ExpPrimitive.131
    EPSILON => _ExpPrimitive.130.End
        CREATE MemberExpression

<_ExpPrimitive>: _ExpPrimitive : parent "::" NAME : name as ChildExpression@
STATE _ExpPrimitive.136
    EPSILON => _ExpPrimitive.135.End
        CREATE ChildExpression

<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second@ "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.143
    [CLOSE_ARRAY "]"] => _ExpPrimitive.142

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) )@ _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.149
    <_Expression> => _ExpPrimitive.148
        ASSIGN collection

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) )@ _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.152
    EPSILON => _ExpPrimitive.149
        SET test => NotIn

<_ExpPrimitive>: _ExpPrimitive : expression "of" _Type : type as InferExpression@
STATE _ExpPrimitive.156
    EPSILON => _ExpPrimitive.155.End
        CREATE InferExpression

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) )@ _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.163
    <_Type> => _ExpPrimitive.162
        ASSIGN type

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) )@ _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.165
    EPSILON => _ExpPrimitive.163
        SET test => IsNotType

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
STATE _ExpPrimitive.168
    EPSILON => _ExpPrimitive.167
        CREATE TypeTestingExpression

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not"@ "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.172
    [KEYWORD_NULL "null"] => _ExpPrimitive.171

<_ExpPrimitive>: _ExpPrimitive : expression "as" _Type : type as TypeCastingExpression@ with { strategy = "Weak" }
STATE _ExpPrimitive.177
    EPSILON => _ExpPrimitive.176
        CREATE TypeCastingExpression

<_ExpPrimitive>: _ExpPrimitive : expression "as" "*" as ExpectedTypeCastExpression@ with { strategy = "Weak" }
STATE _ExpPrimitive.183
    EPSILON => _ExpPrimitive.182
        CREATE ExpectedTypeCastExpression

<_ExpPrimitive>: "typeof" "(" _Type : type@ ")" as TypeOfTypeExpression
STATE _ExpPrimitive.189
    [CLOSE_BRACKET ")"] => _ExpPrimitive.188

<_ExpPrimitive>: "type" "(" _Expression : expression@ ")" as TypeOfExpressionExpression
STATE _ExpPrimitive.195
    [CLOSE_BRACKET ")"] => _ExpPrimitive.194

<_ExpPrimitive>: "attach" "(" _Expression : event@ "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.203
    [COMMA ","] => _ExpPrimitive.202

<_ExpPrimitive>: "detach" "(" _Expression : event@ "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.211
    [COMMA ","] => _ExpPrimitive.210

<_ExpPrimitive>: "::" NAME : name as TopQualifiedExpression@
END STATE _ExpPrimitive.215.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "[" _Expression : body "]" as OrderedLambdaExpression@
END STATE _ExpPrimitive.36.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables }@ "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.49
    [KEYWORD_IN "in"] => _ExpPrimitive.48

<_ExpPrimitive>: "let" _LetVariable : variables { ","@ _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.53
    <_LetVariable> => _ExpPrimitive.52
        ASSIGN variables

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin@ "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.59
    [COMMA ","] => _ExpPrimitive.58

<_ExpPrimitive>: "{" { _CtorFragment : arguments } "}" as ConstructorExpression@
STATE _ExpPrimitive.68
    EPSILON => _ExpPrimitive.67.End
        CREATE ConstructorExpression

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments@ { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.79
    EPSILON => _ExpPrimitive.80

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ]@ ")" as NewClassExpression
STATE _ExpPrimitive.75
    [CLOSE_BRACKET ")"] => _ExpPrimitive.74

<_ExpPrimitive>: "new" _Type : type "{" @{ _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.89
    EPSILON => _ExpPrimitive.85
    <_MemberDeclaration> => _ExpPrimitive.89
        ASSIGN declarations

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "("@ _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.96
    <_Expression> => _ExpPrimitive.95
        ASSIGN expression

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as"@ NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.112
    [NAME] => _ExpPrimitive.111
        ASSIGN name

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments @{ "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.127
    EPSILON => _ExpPrimitive.123
    [COMMA ","] => _ExpPrimitive.128

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression@
STATE _ExpPrimitive.122
    EPSILON => _ExpPrimitive.121.End
        CREATE CallExpression

<_ExpPrimitive>: _ExpPrimitive : parent "." NAME : name as MemberExpression@
END STATE _ExpPrimitive.130.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : parent "::" NAME : name as ChildExpression@
END STATE _ExpPrimitive.135.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second "]" as BinaryExpression@ with { op = "Index" }
STATE _ExpPrimitive.142
    EPSILON => _ExpPrimitive.141
        CREATE BinaryExpression

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression@
STATE _ExpPrimitive.148
    EPSILON => _ExpPrimitive.147.End
        CREATE SetTestingExpression

<_ExpPrimitive>: _ExpPrimitive : expression "of" _Type : type as InferExpression@
END STATE _ExpPrimitive.155.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
STATE _ExpPrimitive.162
    EPSILON => _ExpPrimitive.160.End
        CREATE TypeTestingExpression

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
STATE _ExpPrimitive.167
    EPSILON => _ExpPrimitive.160.End
        SET test => IsNull

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
STATE _ExpPrimitive.171
    EPSILON => _ExpPrimitive.170
        CREATE TypeTestingExpression

<_ExpPrimitive>: _ExpPrimitive : expression "as" _Type : type as TypeCastingExpression@ with { strategy = "Weak" }
STATE _ExpPrimitive.176
    EPSILON => _ExpPrimitive.175.End
        SET strategy => Weak

<_ExpPrimitive>: _ExpPrimitive : expression "as" "*" as ExpectedTypeCastExpression@ with { strategy = "Weak" }
STATE _ExpPrimitive.182
    EPSILON => _ExpPrimitive.181.End
        SET strategy => Weak

<_ExpPrimitive>: "typeof" "(" _Type : type ")" as TypeOfTypeExpression@
STATE _ExpPrimitive.188
    EPSILON => _ExpPrimitive.187.End
        CREATE TypeOfTypeExpression

<_ExpPrimitive>: "type" "(" _Expression : expression ")" as TypeOfExpressionExpression@
STATE _ExpPrimitive.194
    EPSILON => _ExpPrimitive.193.End
        CREATE TypeOfExpressionExpression

<_ExpPrimitive>: "attach" "(" _Expression : event ","@ _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.202
    <_Expression> => _ExpPrimitive.201
        ASSIGN function

<_ExpPrimitive>: "detach" "(" _Expression : event ","@ _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.210
    <_Expression> => _ExpPrimitive.209
        ASSIGN handler

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in"@ "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.48
    [OPEN_BRACKET "("] => _ExpPrimitive.47

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin ","@ _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.58
    <_Expression> => _ExpPrimitive.57
        ASSIGN end

<_ExpPrimitive>: "{" { _CtorFragment : arguments } "}" as ConstructorExpression@
END STATE _ExpPrimitive.67.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments @{ "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.80
    EPSILON => _ExpPrimitive.75
    [COMMA ","] => _ExpPrimitive.81

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression@
STATE _ExpPrimitive.74
    EPSILON => _ExpPrimitive.73.End
        CREATE NewClassExpression

<_ExpPrimitive>: "new" _Type : type "{" { _MemberDeclaration : declarations }@ "}" as NewInterfaceExpression
STATE _ExpPrimitive.85
    [CLOSE_BRACE "}"] => _ExpPrimitive.84

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression@ [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.95
    [KEYWORD_ON "on"] => _ExpPrimitive.101
    EPSILON => _ExpPrimitive.94

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name@ "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.111
    [OPEN_BRACKET "("] => _ExpPrimitive.110

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { ","@ _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.128
    <_Expression> => _ExpPrimitive.127
        ASSIGN arguments

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression@
END STATE _ExpPrimitive.121.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second "]" as BinaryExpression@ with { op = "Index" }
STATE _ExpPrimitive.141
    EPSILON => _ExpPrimitive.140.End
        SET op => Index

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression@
END STATE _ExpPrimitive.147.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
END STATE _ExpPrimitive.160.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
STATE _ExpPrimitive.170
    EPSILON => _ExpPrimitive.160.End
        SET test => IsNotNull

<_ExpPrimitive>: _ExpPrimitive : expression "as" _Type : type as TypeCastingExpression with { strategy = "Weak" }@
END STATE _ExpPrimitive.175.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : expression "as" "*" as ExpectedTypeCastExpression with { strategy = "Weak" }@
END STATE _ExpPrimitive.181.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "typeof" "(" _Type : type ")" as TypeOfTypeExpression@
END STATE _ExpPrimitive.187.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "type" "(" _Expression : expression ")" as TypeOfExpressionExpression@
END STATE _ExpPrimitive.193.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "attach" "(" _Expression : event "," _Expression : function@ ")" as AttachEventExpression
STATE _ExpPrimitive.201
    [CLOSE_BRACKET ")"] => _ExpPrimitive.200

<_ExpPrimitive>: "detach" "(" _Expression : event "," _Expression : handler@ ")" as DetachEventExpression
STATE _ExpPrimitive.209
    [CLOSE_BRACKET ")"] => _ExpPrimitive.208

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "("@ _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.47
    <_Expression> => _ExpPrimitive.46
        ASSIGN expression

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end@ ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.57
    [CLOSE_BRACKET ")"] => _ExpPrimitive.64
    [CLOSE_ARRAY "]"] => _ExpPrimitive.65

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { ","@ _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.81
    <_Expression> => _ExpPrimitive.80
        ASSIGN arguments

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression@
END STATE _ExpPrimitive.73.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "new" _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression@
STATE _ExpPrimitive.84
    EPSILON => _ExpPrimitive.83.End
        CREATE NewInterfaceExpression

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on"@ _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.101
    <_Expression> => _ExpPrimitive.100
        ASSIGN events

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ]@ ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.94
    [CLOSE_BRACKET ")"] => _ExpPrimitive.93

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "("@ _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.110
    <_Expression> => _ExpPrimitive.109
        ASSIGN expression

<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second "]" as BinaryExpression with { op = "Index" }@
END STATE _ExpPrimitive.140.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "attach" "(" _Expression : event "," _Expression : function ")" as AttachEventExpression@
STATE _ExpPrimitive.200
    EPSILON => _ExpPrimitive.199.End
        CREATE AttachEventExpression

<_ExpPrimitive>: "detach" "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression@
STATE _ExpPrimitive.208
    EPSILON => _ExpPrimitive.207.End
        CREATE DetachEventExpression

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression@ ")" as LetExpression
STATE _ExpPrimitive.46
    [CLOSE_BRACKET ")"] => _ExpPrimitive.45

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
STATE _ExpPrimitive.64
    EPSILON => _ExpPrimitive.56
        SET endBoundary => Exclusive

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
STATE _ExpPrimitive.65
    EPSILON => _ExpPrimitive.56
        SET endBoundary => Inclusive

<_ExpPrimitive>: "new" _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression@
END STATE _ExpPrimitive.83.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events@ { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.100
    EPSILON => _ExpPrimitive.102

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression@ with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.93
    EPSILON => _ExpPrimitive.92
        CREATE ObserveExpression

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression@ [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.109
    [KEYWORD_ON "on"] => _ExpPrimitive.117
    EPSILON => _ExpPrimitive.108

<_ExpPrimitive>: "attach" "(" _Expression : event "," _Expression : function ")" as AttachEventExpression@
END STATE _ExpPrimitive.199.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "detach" "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression@
END STATE _ExpPrimitive.207.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression@
STATE _ExpPrimitive.45
    EPSILON => _ExpPrimitive.44.End
        CREATE LetExpression

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
STATE _ExpPrimitive.56
    EPSILON => _ExpPrimitive.55.End
        CREATE RangeExpression

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events @{ "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.102
    EPSILON => _ExpPrimitive.94
    [COMMA ","] => _ExpPrimitive.103

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression@ with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.92
    EPSILON => _ExpPrimitive.91.End
        SET observeType => SimpleObserve

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on"@ _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.117
    <_Expression> => _ExpPrimitive.116
        ASSIGN events

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ]@ ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.108
    [CLOSE_BRACKET ")"] => _ExpPrimitive.107

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression@
END STATE _ExpPrimitive.44.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
END STATE _ExpPrimitive.55.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { ","@ _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.103
    <_Expression> => _ExpPrimitive.102
        ASSIGN events

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }@
END STATE _ExpPrimitive.91.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events@ { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.116
    EPSILON => _ExpPrimitive.118

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression@ with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.107
    EPSILON => _ExpPrimitive.106
        CREATE ObserveExpression

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events @{ "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.118
    EPSILON => _ExpPrimitive.108
    [COMMA ","] => _ExpPrimitive.119

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression@ with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.106
    EPSILON => _ExpPrimitive.105.End
        SET observeType => ExtendedObserve

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { ","@ _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.119
    <_Expression> => _ExpPrimitive.118
        ASSIGN events

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }@
END STATE _ExpPrimitive.105.End
    TOKEN-FINISH => _ExpPrimitive.RootEnd

--------------------------------
@ $<_Exp0>
STATE _Exp0.RootStart
    TOKEN-BEGIN => _Exp0.Start

@ <_Exp0>
STATE _Exp0.Start
    EPSILON => _Exp0.1
    EPSILON => _Exp0.3
    EPSILON => _Exp0.8
    EPSILON => _Exp0.13
    EPSILON => _Exp0.18
    EPSILON => _Exp0.24

<_Exp0>: @!_ExpPrimitive
STATE _Exp0.1
    <_ExpPrimitive> => _Exp0.2.End
        USING 

<_Exp0>: @"+" _Exp0 : operand as UnaryExpression with { op = "Positive" }
STATE _Exp0.3
    [ADD "+"] => _Exp0.7

<_Exp0>: @"-" _Exp0 : operand as UnaryExpression with { op = "Negative" }
STATE _Exp0.8
    [SUB "-"] => _Exp0.12

<_Exp0>: @"not" _Exp0 : operand as UnaryExpression with { op = "Not" }
STATE _Exp0.13
    [KEYWORD_NOT "not"] => _Exp0.17

<_Exp0>: @"cast" _Type : type _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }
STATE _Exp0.18
    [KEYWORD_CAST "cast"] => _Exp0.23

<_Exp0>: @"cast" "*" _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }
STATE _Exp0.24
    [KEYWORD_CAST "cast"] => _Exp0.29

<_Exp0>: !_ExpPrimitive@
END STATE _Exp0.2.End
    TOKEN-FINISH => _Exp0.RootEnd

<_Exp0>: "+"@ _Exp0 : operand as UnaryExpression with { op = "Positive" }
STATE _Exp0.7
    <_Exp0> => _Exp0.6
        ASSIGN operand

<_Exp0>: "-"@ _Exp0 : operand as UnaryExpression with { op = "Negative" }
STATE _Exp0.12
    <_Exp0> => _Exp0.11
        ASSIGN operand

<_Exp0>: "not"@ _Exp0 : operand as UnaryExpression with { op = "Not" }
STATE _Exp0.17
    <_Exp0> => _Exp0.16
        ASSIGN operand

<_Exp0>: "cast"@ _Type : type _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }
STATE _Exp0.23
    <_Type> => _Exp0.22
        ASSIGN type

<_Exp0>: "cast"@ "*" _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }
STATE _Exp0.29
    [MUL "*"] => _Exp0.28

$<_Exp0> @
STATE _Exp0.RootEnd

<_Exp0>: "+" _Exp0 : operand as UnaryExpression@ with { op = "Positive" }
STATE _Exp0.6
    EPSILON => _Exp0.5
        CREATE UnaryExpression

<_Exp0>: "-" _Exp0 : operand as UnaryExpression@ with { op = "Negative" }
STATE _Exp0.11
    EPSILON => _Exp0.10
        CREATE UnaryExpression

<_Exp0>: "not" _Exp0 : operand as UnaryExpression@ with { op = "Not" }
STATE _Exp0.16
    EPSILON => _Exp0.15
        CREATE UnaryExpression

<_Exp0>: "cast" _Type : type@ _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }
STATE _Exp0.22
    <_Exp0> => _Exp0.21
        ASSIGN expression

<_Exp0>: "cast" "*"@ _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }
STATE _Exp0.28
    <_Exp0> => _Exp0.27
        ASSIGN expression

<_Exp0>: "+" _Exp0 : operand as UnaryExpression@ with { op = "Positive" }
STATE _Exp0.5
    EPSILON => _Exp0.4.End
        SET op => Positive

<_Exp0>: "-" _Exp0 : operand as UnaryExpression@ with { op = "Negative" }
STATE _Exp0.10
    EPSILON => _Exp0.9.End
        SET op => Negative

<_Exp0>: "not" _Exp0 : operand as UnaryExpression@ with { op = "Not" }
STATE _Exp0.15
    EPSILON => _Exp0.14.End
        SET op => Not

<_Exp0>: "cast" _Type : type _Exp0 : expression as TypeCastingExpression@ with { strategy = "Strong" }
STATE _Exp0.21
    EPSILON => _Exp0.20
        CREATE TypeCastingExpression

<_Exp0>: "cast" "*" _Exp0 : expression as ExpectedTypeCastExpression@ with { strategy = "Strong" }
STATE _Exp0.27
    EPSILON => _Exp0.26
        CREATE ExpectedTypeCastExpression

<_Exp0>: "+" _Exp0 : operand as UnaryExpression with { op = "Positive" }@
END STATE _Exp0.4.End
    TOKEN-FINISH => _Exp0.RootEnd

<_Exp0>: "-" _Exp0 : operand as UnaryExpression with { op = "Negative" }@
END STATE _Exp0.9.End
    TOKEN-FINISH => _Exp0.RootEnd

<_Exp0>: "not" _Exp0 : operand as UnaryExpression with { op = "Not" }@
END STATE _Exp0.14.End
    TOKEN-FINISH => _Exp0.RootEnd

<_Exp0>: "cast" _Type : type _Exp0 : expression as TypeCastingExpression@ with { strategy = "Strong" }
STATE _Exp0.20
    EPSILON => _Exp0.19.End
        SET strategy => Strong

<_Exp0>: "cast" "*" _Exp0 : expression as ExpectedTypeCastExpression@ with { strategy = "Strong" }
STATE _Exp0.26
    EPSILON => _Exp0.25.End
        SET strategy => Strong

<_Exp0>: "cast" _Type : type _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }@
END STATE _Exp0.19.End
    TOKEN-FINISH => _Exp0.RootEnd

<_Exp0>: "cast" "*" _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }@
END STATE _Exp0.25.End
    TOKEN-FINISH => _Exp0.RootEnd

--------------------------------
@ $<_Exp1>
STATE _Exp1.RootStart
    TOKEN-BEGIN => _Exp1.Start

@ <_Exp1>
STATE _Exp1.Start
    EPSILON => _Exp1.1
    EPSILON => _Exp1.3

<_Exp1>: @!_Exp0
STATE _Exp1.1
    <_Exp0> => _Exp1.2.End
        USING 

<_Exp1>: @_Exp1 : first "^" _Exp0 : second as BinaryExpression with { op = "Exp" }
STATE _Exp1.3
    <_Exp1> => _Exp1.8
        ASSIGN first

<_Exp1>: !_Exp0@
END STATE _Exp1.2.End
    TOKEN-FINISH => _Exp1.RootEnd

<_Exp1>: _Exp1 : first@ "^" _Exp0 : second as BinaryExpression with { op = "Exp" }
STATE _Exp1.8
    [EXP "^"] => _Exp1.7

$<_Exp1> @
STATE _Exp1.RootEnd

<_Exp1>: _Exp1 : first "^"@ _Exp0 : second as BinaryExpression with { op = "Exp" }
STATE _Exp1.7
    <_Exp0> => _Exp1.6
        ASSIGN second

<_Exp1>: _Exp1 : first "^" _Exp0 : second as BinaryExpression@ with { op = "Exp" }
STATE _Exp1.6
    EPSILON => _Exp1.5
        CREATE BinaryExpression

<_Exp1>: _Exp1 : first "^" _Exp0 : second as BinaryExpression@ with { op = "Exp" }
STATE _Exp1.5
    EPSILON => _Exp1.4.End
        SET op => Exp

<_Exp1>: _Exp1 : first "^" _Exp0 : second as BinaryExpression with { op = "Exp" }@
END STATE _Exp1.4.End
    TOKEN-FINISH => _Exp1.RootEnd

--------------------------------
@ $<_Exp2>
STATE _Exp2.RootStart
    TOKEN-BEGIN => _Exp2.Start

@ <_Exp2>
STATE _Exp2.Start
    EPSILON => _Exp2.1
    EPSILON => _Exp2.3
    EPSILON => _Exp2.9
    EPSILON => _Exp2.15

<_Exp2>: @!_Exp1
STATE _Exp2.1
    <_Exp1> => _Exp2.2.End
        USING 

<_Exp2>: @_Exp2 : first "*" _Exp1 : second as BinaryExpression with { op = "Mul" }
STATE _Exp2.3
    <_Exp2> => _Exp2.8
        ASSIGN first

<_Exp2>: @_Exp2 : first "/" _Exp1 : second as BinaryExpression with { op = "Div" }
STATE _Exp2.9
    <_Exp2> => _Exp2.14
        ASSIGN first

<_Exp2>: @_Exp2 : first "%" _Exp1 : second as BinaryExpression with { op = "Mod" }
STATE _Exp2.15
    <_Exp2> => _Exp2.20
        ASSIGN first

<_Exp2>: !_Exp1@
END STATE _Exp2.2.End
    TOKEN-FINISH => _Exp2.RootEnd

<_Exp2>: _Exp2 : first@ "*" _Exp1 : second as BinaryExpression with { op = "Mul" }
STATE _Exp2.8
    [MUL "*"] => _Exp2.7

<_Exp2>: _Exp2 : first@ "/" _Exp1 : second as BinaryExpression with { op = "Div" }
STATE _Exp2.14
    [DIV "/"] => _Exp2.13

<_Exp2>: _Exp2 : first@ "%" _Exp1 : second as BinaryExpression with { op = "Mod" }
STATE _Exp2.20
    [MOD "%"] => _Exp2.19

$<_Exp2> @
STATE _Exp2.RootEnd

<_Exp2>: _Exp2 : first "*"@ _Exp1 : second as BinaryExpression with { op = "Mul" }
STATE _Exp2.7
    <_Exp1> => _Exp2.6
        ASSIGN second

<_Exp2>: _Exp2 : first "/"@ _Exp1 : second as BinaryExpression with { op = "Div" }
STATE _Exp2.13
    <_Exp1> => _Exp2.12
        ASSIGN second

<_Exp2>: _Exp2 : first "%"@ _Exp1 : second as BinaryExpression with { op = "Mod" }
STATE _Exp2.19
    <_Exp1> => _Exp2.18
        ASSIGN second

<_Exp2>: _Exp2 : first "*" _Exp1 : second as BinaryExpression@ with { op = "Mul" }
STATE _Exp2.6
    EPSILON => _Exp2.5
        CREATE BinaryExpression

<_Exp2>: _Exp2 : first "/" _Exp1 : second as BinaryExpression@ with { op = "Div" }
STATE _Exp2.12
    EPSILON => _Exp2.11
        CREATE BinaryExpression

<_Exp2>: _Exp2 : first "%" _Exp1 : second as BinaryExpression@ with { op = "Mod" }
STATE _Exp2.18
    EPSILON => _Exp2.17
        CREATE BinaryExpression

<_Exp2>: _Exp2 : first "*" _Exp1 : second as BinaryExpression@ with { op = "Mul" }
STATE _Exp2.5
    EPSILON => _Exp2.4.End
        SET op => Mul

<_Exp2>: _Exp2 : first "/" _Exp1 : second as BinaryExpression@ with { op = "Div" }
STATE _Exp2.11
    EPSILON => _Exp2.10.End
        SET op => Div

<_Exp2>: _Exp2 : first "%" _Exp1 : second as BinaryExpression@ with { op = "Mod" }
STATE _Exp2.17
    EPSILON => _Exp2.16.End
        SET op => Mod

<_Exp2>: _Exp2 : first "*" _Exp1 : second as BinaryExpression with { op = "Mul" }@
END STATE _Exp2.4.End
    TOKEN-FINISH => _Exp2.RootEnd

<_Exp2>: _Exp2 : first "/" _Exp1 : second as BinaryExpression with { op = "Div" }@
END STATE _Exp2.10.End
    TOKEN-FINISH => _Exp2.RootEnd

<_Exp2>: _Exp2 : first "%" _Exp1 : second as BinaryExpression with { op = "Mod" }@
END STATE _Exp2.16.End
    TOKEN-FINISH => _Exp2.RootEnd

--------------------------------
@ $<_Exp3>
STATE _Exp3.RootStart
    TOKEN-BEGIN => _Exp3.Start

@ <_Exp3>
STATE _Exp3.Start
    EPSILON => _Exp3.1
    EPSILON => _Exp3.3
    EPSILON => _Exp3.9
    EPSILON => _Exp3.15
    EPSILON => _Exp3.21

<_Exp3>: @!_Exp2
STATE _Exp3.1
    <_Exp2> => _Exp3.2.End
        USING 

<_Exp3>: @_Exp3 : first "+" _Exp2 : second as BinaryExpression with { op = "Add" }
STATE _Exp3.3
    <_Exp3> => _Exp3.8
        ASSIGN first

<_Exp3>: @_Exp3 : first "-" _Exp2 : second as BinaryExpression with { op = "Sub" }
STATE _Exp3.9
    <_Exp3> => _Exp3.14
        ASSIGN first

<_Exp3>: @_Exp3 : first "&" _Exp2 : second as BinaryExpression with { op = "Union" }
STATE _Exp3.15
    <_Exp3> => _Exp3.20
        ASSIGN first

<_Exp3>: @_Exp3 : first "|" _Exp2 : second as BinaryExpression with { op = "Intersect" }
STATE _Exp3.21
    <_Exp3> => _Exp3.26
        ASSIGN first

<_Exp3>: !_Exp2@
END STATE _Exp3.2.End
    TOKEN-FINISH => _Exp3.RootEnd

<_Exp3>: _Exp3 : first@ "+" _Exp2 : second as BinaryExpression with { op = "Add" }
STATE _Exp3.8
    [ADD "+"] => _Exp3.7

<_Exp3>: _Exp3 : first@ "-" _Exp2 : second as BinaryExpression with { op = "Sub" }
STATE _Exp3.14
    [SUB "-"] => _Exp3.13

<_Exp3>: _Exp3 : first@ "&" _Exp2 : second as BinaryExpression with { op = "Union" }
STATE _Exp3.20
    [UNION "&"] => _Exp3.19

<_Exp3>: _Exp3 : first@ "|" _Exp2 : second as BinaryExpression with { op = "Intersect" }
STATE _Exp3.26
    [INTERSECTION "|"] => _Exp3.25

$<_Exp3> @
STATE _Exp3.RootEnd

<_Exp3>: _Exp3 : first "+"@ _Exp2 : second as BinaryExpression with { op = "Add" }
STATE _Exp3.7
    <_Exp2> => _Exp3.6
        ASSIGN second

<_Exp3>: _Exp3 : first "-"@ _Exp2 : second as BinaryExpression with { op = "Sub" }
STATE _Exp3.13
    <_Exp2> => _Exp3.12
        ASSIGN second

<_Exp3>: _Exp3 : first "&"@ _Exp2 : second as BinaryExpression with { op = "Union" }
STATE _Exp3.19
    <_Exp2> => _Exp3.18
        ASSIGN second

<_Exp3>: _Exp3 : first "|"@ _Exp2 : second as BinaryExpression with { op = "Intersect" }
STATE _Exp3.25
    <_Exp2> => _Exp3.24
        ASSIGN second

<_Exp3>: _Exp3 : first "+" _Exp2 : second as BinaryExpression@ with { op = "Add" }
STATE _Exp3.6
    EPSILON => _Exp3.5
        CREATE BinaryExpression

<_Exp3>: _Exp3 : first "-" _Exp2 : second as BinaryExpression@ with { op = "Sub" }
STATE _Exp3.12
    EPSILON => _Exp3.11
        CREATE BinaryExpression

<_Exp3>: _Exp3 : first "&" _Exp2 : second as BinaryExpression@ with { op = "Union" }
STATE _Exp3.18
    EPSILON => _Exp3.17
        CREATE BinaryExpression

<_Exp3>: _Exp3 : first "|" _Exp2 : second as BinaryExpression@ with { op = "Intersect" }
STATE _Exp3.24
    EPSILON => _Exp3.23
        CREATE BinaryExpression

<_Exp3>: _Exp3 : first "+" _Exp2 : second as BinaryExpression@ with { op = "Add" }
STATE _Exp3.5
    EPSILON => _Exp3.4.End
        SET op => Add

<_Exp3>: _Exp3 : first "-" _Exp2 : second as BinaryExpression@ with { op = "Sub" }
STATE _Exp3.11
    EPSILON => _Exp3.10.End
        SET op => Sub

<_Exp3>: _Exp3 : first "&" _Exp2 : second as BinaryExpression@ with { op = "Union" }
STATE _Exp3.17
    EPSILON => _Exp3.16.End
        SET op => Union

<_Exp3>: _Exp3 : first "|" _Exp2 : second as BinaryExpression@ with { op = "Intersect" }
STATE _Exp3.23
    EPSILON => _Exp3.22.End
        SET op => Intersect

<_Exp3>: _Exp3 : first "+" _Exp2 : second as BinaryExpression with { op = "Add" }@
END STATE _Exp3.4.End
    TOKEN-FINISH => _Exp3.RootEnd

<_Exp3>: _Exp3 : first "-" _Exp2 : second as BinaryExpression with { op = "Sub" }@
END STATE _Exp3.10.End
    TOKEN-FINISH => _Exp3.RootEnd

<_Exp3>: _Exp3 : first "&" _Exp2 : second as BinaryExpression with { op = "Union" }@
END STATE _Exp3.16.End
    TOKEN-FINISH => _Exp3.RootEnd

<_Exp3>: _Exp3 : first "|" _Exp2 : second as BinaryExpression with { op = "Intersect" }@
END STATE _Exp3.22.End
    TOKEN-FINISH => _Exp3.RootEnd

--------------------------------
@ $<_Exp4>
STATE _Exp4.RootStart
    TOKEN-BEGIN => _Exp4.Start

@ <_Exp4>
STATE _Exp4.Start
    EPSILON => _Exp4.1
    EPSILON => _Exp4.3
    EPSILON => _Exp4.9

<_Exp4>: @!_Exp3
STATE _Exp4.1
    <_Exp3> => _Exp4.2.End
        USING 

<_Exp4>: @_Exp4 : first "shl" _Exp3 : second as BinaryExpression with { op = "Shl" }
STATE _Exp4.3
    <_Exp4> => _Exp4.8
        ASSIGN first

<_Exp4>: @_Exp4 : first "shr" _Exp3 : second as BinaryExpression with { op = "Shr" }
STATE _Exp4.9
    <_Exp4> => _Exp4.14
        ASSIGN first

<_Exp4>: !_Exp3@
END STATE _Exp4.2.End
    TOKEN-FINISH => _Exp4.RootEnd

<_Exp4>: _Exp4 : first@ "shl" _Exp3 : second as BinaryExpression with { op = "Shl" }
STATE _Exp4.8
    [KEYWORD_SHL "shl"] => _Exp4.7

<_Exp4>: _Exp4 : first@ "shr" _Exp3 : second as BinaryExpression with { op = "Shr" }
STATE _Exp4.14
    [KEYWORD_SHR "shr"] => _Exp4.13

$<_Exp4> @
STATE _Exp4.RootEnd

<_Exp4>: _Exp4 : first "shl"@ _Exp3 : second as BinaryExpression with { op = "Shl" }
STATE _Exp4.7
    <_Exp3> => _Exp4.6
        ASSIGN second

<_Exp4>: _Exp4 : first "shr"@ _Exp3 : second as BinaryExpression with { op = "Shr" }
STATE _Exp4.13
    <_Exp3> => _Exp4.12
        ASSIGN second

<_Exp4>: _Exp4 : first "shl" _Exp3 : second as BinaryExpression@ with { op = "Shl" }
STATE _Exp4.6
    EPSILON => _Exp4.5
        CREATE BinaryExpression

<_Exp4>: _Exp4 : first "shr" _Exp3 : second as BinaryExpression@ with { op = "Shr" }
STATE _Exp4.12
    EPSILON => _Exp4.11
        CREATE BinaryExpression

<_Exp4>: _Exp4 : first "shl" _Exp3 : second as BinaryExpression@ with { op = "Shl" }
STATE _Exp4.5
    EPSILON => _Exp4.4.End
        SET op => Shl

<_Exp4>: _Exp4 : first "shr" _Exp3 : second as BinaryExpression@ with { op = "Shr" }
STATE _Exp4.11
    EPSILON => _Exp4.10.End
        SET op => Shr

<_Exp4>: _Exp4 : first "shl" _Exp3 : second as BinaryExpression with { op = "Shl" }@
END STATE _Exp4.4.End
    TOKEN-FINISH => _Exp4.RootEnd

<_Exp4>: _Exp4 : first "shr" _Exp3 : second as BinaryExpression with { op = "Shr" }@
END STATE _Exp4.10.End
    TOKEN-FINISH => _Exp4.RootEnd

--------------------------------
@ $<_Exp5>
STATE _Exp5.RootStart
    TOKEN-BEGIN => _Exp5.Start

@ <_Exp5>
STATE _Exp5.Start
    EPSILON => _Exp5.1
    EPSILON => _Exp5.3
    EPSILON => _Exp5.9
    EPSILON => _Exp5.15
    EPSILON => _Exp5.21
    EPSILON => _Exp5.27
    EPSILON => _Exp5.33

<_Exp5>: @!_Exp4
STATE _Exp5.1
    <_Exp4> => _Exp5.2.End
        USING 

<_Exp5>: @_Exp5 : first "<" _Exp4 : second as BinaryExpression with { op = "LT" }
STATE _Exp5.3
    <_Exp5> => _Exp5.8
        ASSIGN first

<_Exp5>: @_Exp5 : first ">" _Exp4 : second as BinaryExpression with { op = "GT" }
STATE _Exp5.9
    <_Exp5> => _Exp5.14
        ASSIGN first

<_Exp5>: @_Exp5 : first "<=" _Exp4 : second as BinaryExpression with { op = "LE" }
STATE _Exp5.15
    <_Exp5> => _Exp5.20
        ASSIGN first

<_Exp5>: @_Exp5 : first ">=" _Exp4 : second as BinaryExpression with { op = "GE" }
STATE _Exp5.21
    <_Exp5> => _Exp5.26
        ASSIGN first

<_Exp5>: @_Exp5 : first "==" _Exp4 : second as BinaryExpression with { op = "EQ" }
STATE _Exp5.27
    <_Exp5> => _Exp5.32
        ASSIGN first

<_Exp5>: @_Exp5 : first "!=" _Exp4 : second as BinaryExpression with { op = "NE" }
STATE _Exp5.33
    <_Exp5> => _Exp5.38
        ASSIGN first

<_Exp5>: !_Exp4@
END STATE _Exp5.2.End
    TOKEN-FINISH => _Exp5.RootEnd

<_Exp5>: _Exp5 : first@ "<" _Exp4 : second as BinaryExpression with { op = "LT" }
STATE _Exp5.8
    [LT "<"] => _Exp5.7

<_Exp5>: _Exp5 : first@ ">" _Exp4 : second as BinaryExpression with { op = "GT" }
STATE _Exp5.14
    [GT ">"] => _Exp5.13

<_Exp5>: _Exp5 : first@ "<=" _Exp4 : second as BinaryExpression with { op = "LE" }
STATE _Exp5.20
    [LE "<="] => _Exp5.19

<_Exp5>: _Exp5 : first@ ">=" _Exp4 : second as BinaryExpression with { op = "GE" }
STATE _Exp5.26
    [GE ">="] => _Exp5.25

<_Exp5>: _Exp5 : first@ "==" _Exp4 : second as BinaryExpression with { op = "EQ" }
STATE _Exp5.32
    [EQ "=="] => _Exp5.31

<_Exp5>: _Exp5 : first@ "!=" _Exp4 : second as BinaryExpression with { op = "NE" }
STATE _Exp5.38
    [NE "!="] => _Exp5.37

$<_Exp5> @
STATE _Exp5.RootEnd

<_Exp5>: _Exp5 : first "<"@ _Exp4 : second as BinaryExpression with { op = "LT" }
STATE _Exp5.7
    <_Exp4> => _Exp5.6
        ASSIGN second

<_Exp5>: _Exp5 : first ">"@ _Exp4 : second as BinaryExpression with { op = "GT" }
STATE _Exp5.13
    <_Exp4> => _Exp5.12
        ASSIGN second

<_Exp5>: _Exp5 : first "<="@ _Exp4 : second as BinaryExpression with { op = "LE" }
STATE _Exp5.19
    <_Exp4> => _Exp5.18
        ASSIGN second

<_Exp5>: _Exp5 : first ">="@ _Exp4 : second as BinaryExpression with { op = "GE" }
STATE _Exp5.25
    <_Exp4> => _Exp5.24
        ASSIGN second

<_Exp5>: _Exp5 : first "=="@ _Exp4 : second as BinaryExpression with { op = "EQ" }
STATE _Exp5.31
    <_Exp4> => _Exp5.30
        ASSIGN second

<_Exp5>: _Exp5 : first "!="@ _Exp4 : second as BinaryExpression with { op = "NE" }
STATE _Exp5.37
    <_Exp4> => _Exp5.36
        ASSIGN second

<_Exp5>: _Exp5 : first "<" _Exp4 : second as BinaryExpression@ with { op = "LT" }
STATE _Exp5.6
    EPSILON => _Exp5.5
        CREATE BinaryExpression

<_Exp5>: _Exp5 : first ">" _Exp4 : second as BinaryExpression@ with { op = "GT" }
STATE _Exp5.12
    EPSILON => _Exp5.11
        CREATE BinaryExpression

<_Exp5>: _Exp5 : first "<=" _Exp4 : second as BinaryExpression@ with { op = "LE" }
STATE _Exp5.18
    EPSILON => _Exp5.17
        CREATE BinaryExpression

<_Exp5>: _Exp5 : first ">=" _Exp4 : second as BinaryExpression@ with { op = "GE" }
STATE _Exp5.24
    EPSILON => _Exp5.23
        CREATE BinaryExpression

<_Exp5>: _Exp5 : first "==" _Exp4 : second as BinaryExpression@ with { op = "EQ" }
STATE _Exp5.30
    EPSILON => _Exp5.29
        CREATE BinaryExpression

<_Exp5>: _Exp5 : first "!=" _Exp4 : second as BinaryExpression@ with { op = "NE" }
STATE _Exp5.36
    EPSILON => _Exp5.35
        CREATE BinaryExpression

<_Exp5>: _Exp5 : first "<" _Exp4 : second as BinaryExpression@ with { op = "LT" }
STATE _Exp5.5
    EPSILON => _Exp5.4.End
        SET op => LT

<_Exp5>: _Exp5 : first ">" _Exp4 : second as BinaryExpression@ with { op = "GT" }
STATE _Exp5.11
    EPSILON => _Exp5.10.End
        SET op => GT

<_Exp5>: _Exp5 : first "<=" _Exp4 : second as BinaryExpression@ with { op = "LE" }
STATE _Exp5.17
    EPSILON => _Exp5.16.End
        SET op => LE

<_Exp5>: _Exp5 : first ">=" _Exp4 : second as BinaryExpression@ with { op = "GE" }
STATE _Exp5.23
    EPSILON => _Exp5.22.End
        SET op => GE

<_Exp5>: _Exp5 : first "==" _Exp4 : second as BinaryExpression@ with { op = "EQ" }
STATE _Exp5.29
    EPSILON => _Exp5.28.End
        SET op => EQ

<_Exp5>: _Exp5 : first "!=" _Exp4 : second as BinaryExpression@ with { op = "NE" }
STATE _Exp5.35
    EPSILON => _Exp5.34.End
        SET op => NE

<_Exp5>: _Exp5 : first "<" _Exp4 : second as BinaryExpression with { op = "LT" }@
END STATE _Exp5.4.End
    TOKEN-FINISH => _Exp5.RootEnd

<_Exp5>: _Exp5 : first ">" _Exp4 : second as BinaryExpression with { op = "GT" }@
END STATE _Exp5.10.End
    TOKEN-FINISH => _Exp5.RootEnd

<_Exp5>: _Exp5 : first "<=" _Exp4 : second as BinaryExpression with { op = "LE" }@
END STATE _Exp5.16.End
    TOKEN-FINISH => _Exp5.RootEnd

<_Exp5>: _Exp5 : first ">=" _Exp4 : second as BinaryExpression with { op = "GE" }@
END STATE _Exp5.22.End
    TOKEN-FINISH => _Exp5.RootEnd

<_Exp5>: _Exp5 : first "==" _Exp4 : second as BinaryExpression with { op = "EQ" }@
END STATE _Exp5.28.End
    TOKEN-FINISH => _Exp5.RootEnd

<_Exp5>: _Exp5 : first "!=" _Exp4 : second as BinaryExpression with { op = "NE" }@
END STATE _Exp5.34.End
    TOKEN-FINISH => _Exp5.RootEnd

--------------------------------
@ $<_Exp6>
STATE _Exp6.RootStart
    TOKEN-BEGIN => _Exp6.Start

@ <_Exp6>
STATE _Exp6.Start
    EPSILON => _Exp6.1
    EPSILON => _Exp6.3

<_Exp6>: @!_Exp5
STATE _Exp6.1
    <_Exp5> => _Exp6.2.End
        USING 

<_Exp6>: @_Exp6 : first "xor" _Exp5 : second as BinaryExpression with { op = "Xor" }
STATE _Exp6.3
    <_Exp6> => _Exp6.8
        ASSIGN first

<_Exp6>: !_Exp5@
END STATE _Exp6.2.End
    TOKEN-FINISH => _Exp6.RootEnd

<_Exp6>: _Exp6 : first@ "xor" _Exp5 : second as BinaryExpression with { op = "Xor" }
STATE _Exp6.8
    [KEYWORD_XOR "xor"] => _Exp6.7

$<_Exp6> @
STATE _Exp6.RootEnd

<_Exp6>: _Exp6 : first "xor"@ _Exp5 : second as BinaryExpression with { op = "Xor" }
STATE _Exp6.7
    <_Exp5> => _Exp6.6
        ASSIGN second

<_Exp6>: _Exp6 : first "xor" _Exp5 : second as BinaryExpression@ with { op = "Xor" }
STATE _Exp6.6
    EPSILON => _Exp6.5
        CREATE BinaryExpression

<_Exp6>: _Exp6 : first "xor" _Exp5 : second as BinaryExpression@ with { op = "Xor" }
STATE _Exp6.5
    EPSILON => _Exp6.4.End
        SET op => Xor

<_Exp6>: _Exp6 : first "xor" _Exp5 : second as BinaryExpression with { op = "Xor" }@
END STATE _Exp6.4.End
    TOKEN-FINISH => _Exp6.RootEnd

--------------------------------
@ $<_Exp7>
STATE _Exp7.RootStart
    TOKEN-BEGIN => _Exp7.Start

@ <_Exp7>
STATE _Exp7.Start
    EPSILON => _Exp7.1
    EPSILON => _Exp7.3

<_Exp7>: @!_Exp6
STATE _Exp7.1
    <_Exp6> => _Exp7.2.End
        USING 

<_Exp7>: @_Exp7 : first "and" _Exp6 : second as BinaryExpression with { op = "And" }
STATE _Exp7.3
    <_Exp7> => _Exp7.8
        ASSIGN first

<_Exp7>: !_Exp6@
END STATE _Exp7.2.End
    TOKEN-FINISH => _Exp7.RootEnd

<_Exp7>: _Exp7 : first@ "and" _Exp6 : second as BinaryExpression with { op = "And" }
STATE _Exp7.8
    [KEYWORD_AND "and"] => _Exp7.7

$<_Exp7> @
STATE _Exp7.RootEnd

<_Exp7>: _Exp7 : first "and"@ _Exp6 : second as BinaryExpression with { op = "And" }
STATE _Exp7.7
    <_Exp6> => _Exp7.6
        ASSIGN second

<_Exp7>: _Exp7 : first "and" _Exp6 : second as BinaryExpression@ with { op = "And" }
STATE _Exp7.6
    EPSILON => _Exp7.5
        CREATE BinaryExpression

<_Exp7>: _Exp7 : first "and" _Exp6 : second as BinaryExpression@ with { op = "And" }
STATE _Exp7.5
    EPSILON => _Exp7.4.End
        SET op => And

<_Exp7>: _Exp7 : first "and" _Exp6 : second as BinaryExpression with { op = "And" }@
END STATE _Exp7.4.End
    TOKEN-FINISH => _Exp7.RootEnd

--------------------------------
@ $<_Exp8>
STATE _Exp8.RootStart
    TOKEN-BEGIN => _Exp8.Start

@ <_Exp8>
STATE _Exp8.Start
    EPSILON => _Exp8.1
    EPSILON => _Exp8.3

<_Exp8>: @!_Exp7
STATE _Exp8.1
    <_Exp7> => _Exp8.2.End
        USING 

<_Exp8>: @_Exp8 : first "or" _Exp7 : second as BinaryExpression with { op = "Or" }
STATE _Exp8.3
    <_Exp8> => _Exp8.8
        ASSIGN first

<_Exp8>: !_Exp7@
END STATE _Exp8.2.End
    TOKEN-FINISH => _Exp8.RootEnd

<_Exp8>: _Exp8 : first@ "or" _Exp7 : second as BinaryExpression with { op = "Or" }
STATE _Exp8.8
    [KEYWORD_OR "or"] => _Exp8.7

$<_Exp8> @
STATE _Exp8.RootEnd

<_Exp8>: _Exp8 : first "or"@ _Exp7 : second as BinaryExpression with { op = "Or" }
STATE _Exp8.7
    <_Exp7> => _Exp8.6
        ASSIGN second

<_Exp8>: _Exp8 : first "or" _Exp7 : second as BinaryExpression@ with { op = "Or" }
STATE _Exp8.6
    EPSILON => _Exp8.5
        CREATE BinaryExpression

<_Exp8>: _Exp8 : first "or" _Exp7 : second as BinaryExpression@ with { op = "Or" }
STATE _Exp8.5
    EPSILON => _Exp8.4.End
        SET op => Or

<_Exp8>: _Exp8 : first "or" _Exp7 : second as BinaryExpression with { op = "Or" }@
END STATE _Exp8.4.End
    TOKEN-FINISH => _Exp8.RootEnd

--------------------------------
@ $<_Exp9>
STATE _Exp9.RootStart
    TOKEN-BEGIN => _Exp9.Start

@ <_Exp9>
STATE _Exp9.Start
    EPSILON => _Exp9.1
    EPSILON => _Exp9.3

<_Exp9>: @!_Exp8
STATE _Exp9.1
    <_Exp8> => _Exp9.2.End
        USING 

<_Exp9>: @_Exp9 : first "??" _Exp8 : second as BinaryExpression with { op = "FailedThen" }
STATE _Exp9.3
    <_Exp9> => _Exp9.8
        ASSIGN first

<_Exp9>: !_Exp8@
END STATE _Exp9.2.End
    TOKEN-FINISH => _Exp9.RootEnd

<_Exp9>: _Exp9 : first@ "??" _Exp8 : second as BinaryExpression with { op = "FailedThen" }
STATE _Exp9.8
    [FAILED_THEN "??"] => _Exp9.7

$<_Exp9> @
STATE _Exp9.RootEnd

<_Exp9>: _Exp9 : first "??"@ _Exp8 : second as BinaryExpression with { op = "FailedThen" }
STATE _Exp9.7
    <_Exp8> => _Exp9.6
        ASSIGN second

<_Exp9>: _Exp9 : first "??" _Exp8 : second as BinaryExpression@ with { op = "FailedThen" }
STATE _Exp9.6
    EPSILON => _Exp9.5
        CREATE BinaryExpression

<_Exp9>: _Exp9 : first "??" _Exp8 : second as BinaryExpression@ with { op = "FailedThen" }
STATE _Exp9.5
    EPSILON => _Exp9.4.End
        SET op => FailedThen

<_Exp9>: _Exp9 : first "??" _Exp8 : second as BinaryExpression with { op = "FailedThen" }@
END STATE _Exp9.4.End
    TOKEN-FINISH => _Exp9.RootEnd

--------------------------------
@ $<_Exp10>
STATE _Exp10.RootStart
    TOKEN-BEGIN => _Exp10.Start

@ <_Exp10>
STATE _Exp10.Start
    EPSILON => _Exp10.1
    EPSILON => _Exp10.3

<_Exp10>: @!_Exp9
STATE _Exp10.1
    <_Exp9> => _Exp10.2.End
        USING 

<_Exp10>: @_Exp9 : condition "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.3
    <_Exp9> => _Exp10.9
        ASSIGN condition

<_Exp10>: !_Exp9@
END STATE _Exp10.2.End
    TOKEN-FINISH => _Exp10.RootEnd

<_Exp10>: _Exp9 : condition@ "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.9
    [QUESTION_MARK "?"] => _Exp10.8

$<_Exp10> @
STATE _Exp10.RootEnd

<_Exp10>: _Exp9 : condition "?"@ _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.8
    <_Exp10> => _Exp10.7
        ASSIGN trueBranch

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch@ ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.7
    [COLON ":"] => _Exp10.6

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch ":"@ _Exp10 : falseBranch as IfExpression
STATE _Exp10.6
    <_Exp10> => _Exp10.5
        ASSIGN falseBranch

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression@
STATE _Exp10.5
    EPSILON => _Exp10.4.End
        CREATE IfExpression

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression@
END STATE _Exp10.4.End
    TOKEN-FINISH => _Exp10.RootEnd

--------------------------------
@ $<_Exp11>
STATE _Exp11.RootStart
    TOKEN-BEGIN => _Exp11.Start

@ <_Exp11>
STATE _Exp11.Start
    EPSILON => _Exp11.1
    EPSILON => _Exp11.3

<_Exp11>: @!_Exp10
STATE _Exp11.1
    <_Exp10> => _Exp11.2.End
        USING 

<_Exp11>: @_Exp10 : first "=" _Exp11 : second as BinaryExpression with { op = "Assign" }
STATE _Exp11.3
    <_Exp10> => _Exp11.8
        ASSIGN first

<_Exp11>: !_Exp10@
END STATE _Exp11.2.End
    TOKEN-FINISH => _Exp11.RootEnd

<_Exp11>: _Exp10 : first@ "=" _Exp11 : second as BinaryExpression with { op = "Assign" }
STATE _Exp11.8
    [ASSIGN "="] => _Exp11.7

$<_Exp11> @
STATE _Exp11.RootEnd

<_Exp11>: _Exp10 : first "="@ _Exp11 : second as BinaryExpression with { op = "Assign" }
STATE _Exp11.7
    <_Exp11> => _Exp11.6
        ASSIGN second

<_Exp11>: _Exp10 : first "=" _Exp11 : second as BinaryExpression@ with { op = "Assign" }
STATE _Exp11.6
    EPSILON => _Exp11.5
        CREATE BinaryExpression

<_Exp11>: _Exp10 : first "=" _Exp11 : second as BinaryExpression@ with { op = "Assign" }
STATE _Exp11.5
    EPSILON => _Exp11.4.End
        SET op => Assign

<_Exp11>: _Exp10 : first "=" _Exp11 : second as BinaryExpression with { op = "Assign" }@
END STATE _Exp11.4.End
    TOKEN-FINISH => _Exp11.RootEnd

--------------------------------
@ $<_Expression>
STATE _Expression.RootStart
    TOKEN-BEGIN => _Expression.Start

@ <_Expression>
STATE _Expression.Start
    EPSILON => _Expression.1

<_Expression>: @!_Exp11
STATE _Expression.1
    <_Exp11> => _Expression.2.End
        USING 

<_Expression>: !_Exp11@
END STATE _Expression.2.End
    TOKEN-FINISH => _Expression.RootEnd

$<_Expression> @
STATE _Expression.RootEnd

--------------------------------
@ $<_SwitchCase>
STATE _SwitchCase.RootStart
    TOKEN-BEGIN => _SwitchCase.Start

@ <_SwitchCase>
STATE _SwitchCase.Start
    EPSILON => _SwitchCase.1

<_SwitchCase>: @"case" _Expression : expression ":" _Block : statement as SwitchCase
STATE _SwitchCase.1
    [KEYWORD_CASE "case"] => _SwitchCase.6

<_SwitchCase>: "case"@ _Expression : expression ":" _Block : statement as SwitchCase
STATE _SwitchCase.6
    <_Expression> => _SwitchCase.5
        ASSIGN expression

<_SwitchCase>: "case" _Expression : expression@ ":" _Block : statement as SwitchCase
STATE _SwitchCase.5
    [COLON ":"] => _SwitchCase.4

<_SwitchCase>: "case" _Expression : expression ":"@ _Block : statement as SwitchCase
STATE _SwitchCase.4
    <_Block> => _SwitchCase.3
        ASSIGN statement

<_SwitchCase>: "case" _Expression : expression ":" _Block : statement as SwitchCase@
STATE _SwitchCase.3
    EPSILON => _SwitchCase.2.End
        CREATE SwitchCase

<_SwitchCase>: "case" _Expression : expression ":" _Block : statement as SwitchCase@
END STATE _SwitchCase.2.End
    TOKEN-FINISH => _SwitchCase.RootEnd

$<_SwitchCase> @
STATE _SwitchCase.RootEnd

--------------------------------
@ $<_Block>
STATE _Block.RootStart
    TOKEN-BEGIN => _Block.Start

@ <_Block>
STATE _Block.Start
    EPSILON => _Block.1

<_Block>: @"{" { _Statement : statements } "}" as BlockStatement
STATE _Block.1
    [OPEN_BRACE "{"] => _Block.5

<_Block>: "{"@ { _Statement : statements } "}" as BlockStatement
STATE _Block.5
    EPSILON => _Block.6

<_Block>: "{" @{ _Statement : statements } "}" as BlockStatement
STATE _Block.6
    EPSILON => _Block.4
    <_Statement> => _Block.6
        ASSIGN statements

<_Block>: "{" { _Statement : statements }@ "}" as BlockStatement
STATE _Block.4
    [CLOSE_BRACE "}"] => _Block.3

<_Block>: "{" { _Statement : statements } "}" as BlockStatement@
STATE _Block.3
    EPSILON => _Block.2.End
        CREATE BlockStatement

<_Block>: "{" { _Statement : statements } "}" as BlockStatement@
END STATE _Block.2.End
    TOKEN-FINISH => _Block.RootEnd

$<_Block> @
STATE _Block.RootEnd

--------------------------------
@ $<_If>
STATE _If.RootStart
    TOKEN-BEGIN => _If.Start

@ <_If>
STATE _If.Start
    EPSILON => _If.1

<_If>: @"if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.1
    [KEYWORD_IF "if"] => _If.9

<_If>: "if"@ "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.9
    [OPEN_BRACKET "("] => _If.8

<_If>: "if" "("@ [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.8
    [KEYWORD_VAR "var"] => _If.13
    EPSILON => _If.7

<_If>: "if" "(" [ "var"@ NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.13
    [NAME] => _If.12
        ASSIGN name

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ]@ _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.7
    <_Expression> => _If.6
        ASSIGN expression

<_If>: "if" "(" [ "var" NAME : name@ ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.12
    [COLON ":"] => _If.11

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression@ ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.6
    [CLOSE_BRACKET ")"] => _If.5

<_If>: "if" "(" [ "var" NAME : name ":"@ _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.11
    <_Type> => _If.10
        ASSIGN type

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")"@ _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.5
    <_Block> => _If.4
        ASSIGN trueBranch

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type@ "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.10
    [ASSIGN "="] => _If.7

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch@ [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.4
    [KEYWORD_ELSE "else"] => _If.14
    EPSILON => _If.3

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else"@ ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.14
    <_Block> => _If.3
        ASSIGN falseBranch
    <_If> => _If.3
        ASSIGN falseBranch

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement@
STATE _If.3
    EPSILON => _If.2.End
        CREATE IfStatement

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement@
END STATE _If.2.End
    TOKEN-FINISH => _If.RootEnd

$<_If> @
STATE _If.RootEnd

--------------------------------
@ $<_VirtualStatement>
STATE _VirtualStatement.RootStart
    TOKEN-BEGIN => _VirtualStatement.Start

@ <_VirtualStatement>
STATE _VirtualStatement.Start
    EPSILON => _VirtualStatement.1
    EPSILON => _VirtualStatement.14
    EPSILON => _VirtualStatement.26

<_VirtualStatement>: @"switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.1
    [KEYWORD_SWITCH "switch"] => _VirtualStatement.10

<_VirtualStatement>: @"for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.14
    [KEYWORD_FOR "for"] => _VirtualStatement.22

<_VirtualStatement>: @[ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.26
    [KEYWORD_VAR "var"] => _VirtualStatement.33
    EPSILON => _VirtualStatement.31

<_VirtualStatement>: "switch"@ "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.10
    [OPEN_BRACKET "("] => _VirtualStatement.9

<_VirtualStatement>: "for"@ "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.22
    [OPEN_BRACKET "("] => _VirtualStatement.21

<_VirtualStatement>: [ "var"@ NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.33
    [NAME] => _VirtualStatement.32
        ASSIGN varName

<_VirtualStatement>: [ "var" NAME : varName "=" ]@ COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.31
    [COROUTINE_OPERATOR] => _VirtualStatement.30
        ASSIGN opName

<_VirtualStatement>: "switch" "("@ _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.9
    <_Expression> => _VirtualStatement.8
        ASSIGN expression

<_VirtualStatement>: "for" "("@ NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.21
    [NAME] => _VirtualStatement.20
        ASSIGN name

<_VirtualStatement>: [ "var" NAME : varName@ "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.32
    [ASSIGN "="] => _VirtualStatement.31

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName@ [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.30
    <_Expression> => _VirtualStatement.34
        ASSIGN arguments
    EPSILON => _VirtualStatement.29

<_VirtualStatement>: "switch" "(" _Expression : expression@ ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.8
    [CLOSE_BRACKET ")"] => _VirtualStatement.7

<_VirtualStatement>: "for" "(" NAME : name@ ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.20
    [KEYWORD_IN "in"] => _VirtualStatement.23
    [KEYWORD_IN "in"] => _VirtualStatement.25

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments@ { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.34
    EPSILON => _VirtualStatement.35

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ]@ ";" as CoOperatorStatement
STATE _VirtualStatement.29
    [SEMICOLON ";"] => _VirtualStatement.28

<_VirtualStatement>: "switch" "(" _Expression : expression ")"@ "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.7
    [OPEN_BRACE "{"] => _VirtualStatement.6

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) )@ _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.23
    EPSILON => _VirtualStatement.19
        SET direction => Normal

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in"@ "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.25
    [KEYWORD_REVERSED "reversed"] => _VirtualStatement.24

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments @{ "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.35
    EPSILON => _VirtualStatement.29
    [COMMA ","] => _VirtualStatement.36

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement@
STATE _VirtualStatement.28
    EPSILON => _VirtualStatement.27.End
        CREATE CoOperatorStatement

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{"@ { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.6
    EPSILON => _VirtualStatement.11

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) )@ _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.19
    <_Expression> => _VirtualStatement.18
        ASSIGN collection

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) )@ _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.24
    EPSILON => _VirtualStatement.19
        SET direction => Reversed

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { ","@ _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.36
    <_Expression> => _VirtualStatement.35
        ASSIGN arguments

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement@
END STATE _VirtualStatement.27.End
    TOKEN-FINISH => _VirtualStatement.RootEnd

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" @{ _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.11
    EPSILON => _VirtualStatement.5
    <_SwitchCase> => _VirtualStatement.11
        ASSIGN caseBranches

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection@ ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.18
    [CLOSE_BRACKET ")"] => _VirtualStatement.17

$<_VirtualStatement> @
STATE _VirtualStatement.RootEnd

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches }@ [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.5
    [KEYWORD_DEFAULT "default"] => _VirtualStatement.13
    EPSILON => _VirtualStatement.4

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")"@ _Block : statement as ForEachStatement
STATE _VirtualStatement.17
    <_Block> => _VirtualStatement.16
        ASSIGN statement

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default"@ ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.13
    [COLON ":"] => _VirtualStatement.12

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ]@ "}" as SwitchStatement
STATE _VirtualStatement.4
    [CLOSE_BRACE "}"] => _VirtualStatement.3

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement@
STATE _VirtualStatement.16
    EPSILON => _VirtualStatement.15.End
        CREATE ForEachStatement

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":"@ _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.12
    <_Block> => _VirtualStatement.4
        ASSIGN defaultBranch

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement@
STATE _VirtualStatement.3
    EPSILON => _VirtualStatement.2.End
        CREATE SwitchStatement

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement@
END STATE _VirtualStatement.15.End
    TOKEN-FINISH => _VirtualStatement.RootEnd

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement@
END STATE _VirtualStatement.2.End
    TOKEN-FINISH => _VirtualStatement.RootEnd

--------------------------------
@ $<_CoStatement>
STATE _CoStatement.RootStart
    TOKEN-BEGIN => _CoStatement.Start

@ <_CoStatement>
STATE _CoStatement.Start
    EPSILON => _CoStatement.1

<_CoStatement>: @"$pause" ( ";" | _Block : statement ) as CoPauseStatement
STATE _CoStatement.1
    [COROUTINE_PAUSE "$pause"] => _CoStatement.4

<_CoStatement>: "$pause"@ ( ";" | _Block : statement ) as CoPauseStatement
STATE _CoStatement.4
    [SEMICOLON ";"] => _CoStatement.3
    <_Block> => _CoStatement.3
        ASSIGN statement

<_CoStatement>: "$pause" ( ";" | _Block : statement ) as CoPauseStatement@
STATE _CoStatement.3
    EPSILON => _CoStatement.2.End
        CREATE CoPauseStatement

<_CoStatement>: "$pause" ( ";" | _Block : statement ) as CoPauseStatement@
END STATE _CoStatement.2.End
    TOKEN-FINISH => _CoStatement.RootEnd

$<_CoStatement> @
STATE _CoStatement.RootEnd

--------------------------------
@ $<_CoProvider>
STATE _CoProvider.RootStart
    TOKEN-BEGIN => _CoProvider.Start

@ <_CoProvider>
STATE _CoProvider.Start
    EPSILON => _CoProvider.1

<_CoProvider>: @( "$" | COROUTINE_OPERATOR : name ) _Block : statement as CoProviderStatement
STATE _CoProvider.1
    [COROUTINE_SIGN "$"] => _CoProvider.4
    [COROUTINE_OPERATOR] => _CoProvider.4
        ASSIGN name

<_CoProvider>: ( "$" | COROUTINE_OPERATOR : name )@ _Block : statement as CoProviderStatement
STATE _CoProvider.4
    <_Block> => _CoProvider.3
        ASSIGN statement

<_CoProvider>: ( "$" | COROUTINE_OPERATOR : name ) _Block : statement as CoProviderStatement@
STATE _CoProvider.3
    EPSILON => _CoProvider.2.End
        CREATE CoProviderStatement

<_CoProvider>: ( "$" | COROUTINE_OPERATOR : name ) _Block : statement as CoProviderStatement@
END STATE _CoProvider.2.End
    TOKEN-FINISH => _CoProvider.RootEnd

$<_CoProvider> @
STATE _CoProvider.RootEnd

--------------------------------
@ $<_Statement>
STATE _Statement.RootStart
    TOKEN-BEGIN => _Statement.Start

@ <_Statement>
STATE _Statement.Start
    EPSILON => _Statement.1
    EPSILON => _Statement.3
    EPSILON => _Statement.6
    EPSILON => _Statement.10
    EPSILON => _Statement.14
    EPSILON => _Statement.19
    EPSILON => _Statement.24
    EPSILON => _Statement.29
    EPSILON => _Statement.31
    EPSILON => _Statement.38
    EPSILON => _Statement.49
    EPSILON => _Statement.53
    EPSILON => _Statement.55

<_Statement>: @!_Block
STATE _Statement.1
    <_Block> => _Statement.2.End
        USING 

<_Statement>: @_Variable : variable as VariableStatement
STATE _Statement.3
    <_Variable> => _Statement.5
        ASSIGN variable

<_Statement>: @"break" ";" as BreakStatement
STATE _Statement.6
    [KEYWORD_BREAK "break"] => _Statement.9

<_Statement>: @"continue" ";" as ContinueStatement
STATE _Statement.10
    [KEYWORD_CONTINUE "continue"] => _Statement.13

<_Statement>: @"return" [ _Expression : expression ] ";" as ReturnStatement
STATE _Statement.14
    [KEYWORD_RETURN "return"] => _Statement.18

<_Statement>: @"delete" _Expression : expression ";" as DeleteStatement
STATE _Statement.19
    [KEYWORD_DELETE "delete"] => _Statement.23

<_Statement>: @"raise" [ _Expression : expression ] ";" as RaiseExceptionStatement
STATE _Statement.24
    [KEYWORD_RAISE "raise"] => _Statement.28

<_Statement>: @!_If
STATE _Statement.29
    <_If> => _Statement.30.End
        USING 

<_Statement>: @"while" "(" _Expression : condition ")" _Block : statement as WhileStatement
STATE _Statement.31
    [KEYWORD_WHILE "while"] => _Statement.37

<_Statement>: @"try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.38
    [KEYWORD_TRY "try"] => _Statement.43

<_Statement>: @_Expression : expression ";" as ExpressionStatement
STATE _Statement.49
    <_Expression> => _Statement.52
        ASSIGN expression

<_Statement>: @!_VirtualStatement
STATE _Statement.53
    <_VirtualStatement> => _Statement.54.End
        USING 

<_Statement>: @!_CoStatement
STATE _Statement.55
    <_CoStatement> => _Statement.56.End
        USING 

<_Statement>: !_Block@
END STATE _Statement.2.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: _Variable : variable as VariableStatement@
STATE _Statement.5
    EPSILON => _Statement.4.End
        CREATE VariableStatement

<_Statement>: "break"@ ";" as BreakStatement
STATE _Statement.9
    [SEMICOLON ";"] => _Statement.8

<_Statement>: "continue"@ ";" as ContinueStatement
STATE _Statement.13
    [SEMICOLON ";"] => _Statement.12

<_Statement>: "return"@ [ _Expression : expression ] ";" as ReturnStatement
STATE _Statement.18
    <_Expression> => _Statement.17
        ASSIGN expression
    EPSILON => _Statement.17

<_Statement>: "delete"@ _Expression : expression ";" as DeleteStatement
STATE _Statement.23
    <_Expression> => _Statement.22
        ASSIGN expression

<_Statement>: "raise"@ [ _Expression : expression ] ";" as RaiseExceptionStatement
STATE _Statement.28
    <_Expression> => _Statement.27
        ASSIGN expression
    EPSILON => _Statement.27

<_Statement>: !_If@
END STATE _Statement.30.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "while"@ "(" _Expression : condition ")" _Block : statement as WhileStatement
STATE _Statement.37
    [OPEN_BRACKET "("] => _Statement.36

<_Statement>: "try"@ _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.43
    <_Block> => _Statement.42
        ASSIGN protectedStatement

<_Statement>: _Expression : expression@ ";" as ExpressionStatement
STATE _Statement.52
    [SEMICOLON ";"] => _Statement.51

<_Statement>: !_VirtualStatement@
END STATE _Statement.54.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: !_CoStatement@
END STATE _Statement.56.End
    TOKEN-FINISH => _Statement.RootEnd

$<_Statement> @
STATE _Statement.RootEnd

<_Statement>: _Variable : variable as VariableStatement@
END STATE _Statement.4.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "break" ";" as BreakStatement@
STATE _Statement.8
    EPSILON => _Statement.7.End
        CREATE BreakStatement

<_Statement>: "continue" ";" as ContinueStatement@
STATE _Statement.12
    EPSILON => _Statement.11.End
        CREATE ContinueStatement

<_Statement>: "return" [ _Expression : expression ]@ ";" as ReturnStatement
STATE _Statement.17
    [SEMICOLON ";"] => _Statement.16

<_Statement>: "delete" _Expression : expression@ ";" as DeleteStatement
STATE _Statement.22
    [SEMICOLON ";"] => _Statement.21

<_Statement>: "raise" [ _Expression : expression ]@ ";" as RaiseExceptionStatement
STATE _Statement.27
    [SEMICOLON ";"] => _Statement.26

<_Statement>: "while" "("@ _Expression : condition ")" _Block : statement as WhileStatement
STATE _Statement.36
    <_Expression> => _Statement.35
        ASSIGN condition

<_Statement>: "try" _Block : protectedStatement@ [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.42
    [KEYWORD_CATCH "catch"] => _Statement.47
    EPSILON => _Statement.41

<_Statement>: _Expression : expression ";" as ExpressionStatement@
STATE _Statement.51
    EPSILON => _Statement.50.End
        CREATE ExpressionStatement

<_Statement>: "break" ";" as BreakStatement@
END STATE _Statement.7.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "continue" ";" as ContinueStatement@
END STATE _Statement.11.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "return" [ _Expression : expression ] ";" as ReturnStatement@
STATE _Statement.16
    EPSILON => _Statement.15.End
        CREATE ReturnStatement

<_Statement>: "delete" _Expression : expression ";" as DeleteStatement@
STATE _Statement.21
    EPSILON => _Statement.20.End
        CREATE DeleteStatement

<_Statement>: "raise" [ _Expression : expression ] ";" as RaiseExceptionStatement@
STATE _Statement.26
    EPSILON => _Statement.25.End
        CREATE RaiseExceptionStatement

<_Statement>: "while" "(" _Expression : condition@ ")" _Block : statement as WhileStatement
STATE _Statement.35
    [CLOSE_BRACKET ")"] => _Statement.34

<_Statement>: "try" _Block : protectedStatement [ "catch"@ "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.47
    [OPEN_BRACKET "("] => _Statement.46

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ]@ [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.41
    [KEYWORD_FINALLY "finally"] => _Statement.48
    EPSILON => _Statement.40

<_Statement>: _Expression : expression ";" as ExpressionStatement@
END STATE _Statement.50.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "return" [ _Expression : expression ] ";" as ReturnStatement@
END STATE _Statement.15.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "delete" _Expression : expression ";" as DeleteStatement@
END STATE _Statement.20.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "raise" [ _Expression : expression ] ";" as RaiseExceptionStatement@
END STATE _Statement.25.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "while" "(" _Expression : condition ")"@ _Block : statement as WhileStatement
STATE _Statement.34
    <_Block> => _Statement.33
        ASSIGN statement

<_Statement>: "try" _Block : protectedStatement [ "catch" "("@ NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.46
    [NAME] => _Statement.45
        ASSIGN name

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally"@ _Block : finallyStatement ] as TryStatement
STATE _Statement.48
    <_Block> => _Statement.40
        ASSIGN finallyStatement

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement@
STATE _Statement.40
    EPSILON => _Statement.39.End
        CREATE TryStatement

<_Statement>: "while" "(" _Expression : condition ")" _Block : statement as WhileStatement@
STATE _Statement.33
    EPSILON => _Statement.32.End
        CREATE WhileStatement

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name@ ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.45
    [CLOSE_BRACKET ")"] => _Statement.44

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement@
END STATE _Statement.39.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "while" "(" _Expression : condition ")" _Block : statement as WhileStatement@
END STATE _Statement.32.End
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")"@ _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.44
    <_Block> => _Statement.41
        ASSIGN catchStatement

--------------------------------
@ $<_Attribute>
STATE _Attribute.RootStart
    TOKEN-BEGIN => _Attribute.Start

@ <_Attribute>
STATE _Attribute.Start
    EPSILON => _Attribute.1

<_Attribute>: @"@" NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.1
    [AT "@"] => _Attribute.7

<_Attribute>: "@"@ NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.7
    [NAME] => _Attribute.6
        ASSIGN category

<_Attribute>: "@" NAME : category@ ":" NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.6
    [COLON ":"] => _Attribute.5

<_Attribute>: "@" NAME : category ":"@ NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.5
    [NAME] => _Attribute.4
        ASSIGN name

<_Attribute>: "@" NAME : category ":" NAME : name@ [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.4
    [OPEN_BRACKET "("] => _Attribute.9
    EPSILON => _Attribute.3

<_Attribute>: "@" NAME : category ":" NAME : name [ "("@ _Expression : value ")" ] as Attribute
STATE _Attribute.9
    <_Expression> => _Attribute.8
        ASSIGN value

<_Attribute>: "@" NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute@
STATE _Attribute.3
    EPSILON => _Attribute.2.End
        CREATE Attribute

<_Attribute>: "@" NAME : category ":" NAME : name [ "(" _Expression : value@ ")" ] as Attribute
STATE _Attribute.8
    [CLOSE_BRACKET ")"] => _Attribute.3

<_Attribute>: "@" NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute@
END STATE _Attribute.2.End
    TOKEN-FINISH => _Attribute.RootEnd

$<_Attribute> @
STATE _Attribute.RootEnd

--------------------------------
@ $<_Namespace>
STATE _Namespace.RootStart
    TOKEN-BEGIN => _Namespace.Start

@ <_Namespace>
STATE _Namespace.Start
    EPSILON => _Namespace.1

<_Namespace>: @"namespace" NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.1
    [KEYWORD_NAMESPACE "namespace"] => _Namespace.7

<_Namespace>: "namespace"@ NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.7
    [NAME] => _Namespace.6
        ASSIGN name

<_Namespace>: "namespace" NAME : name@ "{" { _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.6
    [OPEN_BRACE "{"] => _Namespace.5

<_Namespace>: "namespace" NAME : name "{"@ { _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.5
    EPSILON => _Namespace.8

<_Namespace>: "namespace" NAME : name "{" @{ _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.8
    EPSILON => _Namespace.4
    <_Declaration> => _Namespace.8
        ASSIGN declarations

<_Namespace>: "namespace" NAME : name "{" { _Declaration : declarations }@ "}" as NamespaceDeclaration
STATE _Namespace.4
    [CLOSE_BRACE "}"] => _Namespace.3

<_Namespace>: "namespace" NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration@
STATE _Namespace.3
    EPSILON => _Namespace.2.End
        CREATE NamespaceDeclaration

<_Namespace>: "namespace" NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration@
END STATE _Namespace.2.End
    TOKEN-FINISH => _Namespace.RootEnd

$<_Namespace> @
STATE _Namespace.RootEnd

--------------------------------
@ $<_FunctionArgument>
STATE _FunctionArgument.RootStart
    TOKEN-BEGIN => _FunctionArgument.Start

@ <_FunctionArgument>
STATE _FunctionArgument.Start
    EPSILON => _FunctionArgument.1

<_FunctionArgument>: @{ _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument
STATE _FunctionArgument.1
    EPSILON => _FunctionArgument.7

<_FunctionArgument>: @{ _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument
STATE _FunctionArgument.7
    EPSILON => _FunctionArgument.6
    <_Attribute> => _FunctionArgument.7
        ASSIGN attributes

<_FunctionArgument>: { _Attribute : attributes }@ NAME : name ":" _Type : type as FunctionArgument
STATE _FunctionArgument.6
    [NAME] => _FunctionArgument.5
        ASSIGN name

<_FunctionArgument>: { _Attribute : attributes } NAME : name@ ":" _Type : type as FunctionArgument
STATE _FunctionArgument.5
    [COLON ":"] => _FunctionArgument.4

<_FunctionArgument>: { _Attribute : attributes } NAME : name ":"@ _Type : type as FunctionArgument
STATE _FunctionArgument.4
    <_Type> => _FunctionArgument.3
        ASSIGN type

<_FunctionArgument>: { _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument@
STATE _FunctionArgument.3
    EPSILON => _FunctionArgument.2.End
        CREATE FunctionArgument

<_FunctionArgument>: { _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument@
END STATE _FunctionArgument.2.End
    TOKEN-FINISH => _FunctionArgument.RootEnd

$<_FunctionArgument> @
STATE _FunctionArgument.RootEnd

--------------------------------
@ $<_Function>
STATE _Function.RootStart
    TOKEN-BEGIN => _Function.Start

@ <_Function>
STATE _Function.Start
    EPSILON => _Function.1

<_Function>: @"func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.1
    [KEYWORD_FUNC "func"] => _Function.9

<_Function>: "func"@ ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.9
    [NAME] => _Function.11
        ASSIGN name
    [OPEN_BRACKET "("] => _Function.12

<_Function>: "func" ( ( NAME : name@ "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.11
    [OPEN_BRACKET "("] => _Function.10

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) )@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.12
    EPSILON => _Function.8
        SET anonymity => Anonymous

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) )@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.10
    EPSILON => _Function.8
        SET anonymity => Named

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) )@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.8
    <_FunctionArgument> => _Function.13
        ASSIGN arguments
    EPSILON => _Function.7

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments@ { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.13
    EPSILON => _Function.14

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ]@ ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.7
    [CLOSE_BRACKET ")"] => _Function.6

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments @{ "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.14
    EPSILON => _Function.7
    [COMMA ","] => _Function.15

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")"@ ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.6
    [COLON ":"] => _Function.5

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { ","@ _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.15
    <_FunctionArgument> => _Function.14
        ASSIGN arguments

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":"@ _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.5
    <_Type> => _Function.4
        ASSIGN returnType

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType@ ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.4
    <_Block> => _Function.3
        ASSIGN statement
    <_CoProvider> => _Function.3
        ASSIGN statement
    [SEMICOLON ";"] => _Function.3

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration@
STATE _Function.3
    EPSILON => _Function.2.End
        CREATE FunctionDeclaration

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration@
END STATE _Function.2.End
    TOKEN-FINISH => _Function.RootEnd

$<_Function> @
STATE _Function.RootEnd

--------------------------------
@ $<_Variable>
STATE _Variable.RootStart
    TOKEN-BEGIN => _Variable.Start

@ <_Variable>
STATE _Variable.Start
    EPSILON => _Variable.1

<_Variable>: @"var" NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.1
    [KEYWORD_VAR "var"] => _Variable.8

<_Variable>: "var"@ NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.8
    [NAME] => _Variable.7
        ASSIGN name

<_Variable>: "var" NAME : name@ [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.7
    [COLON ":"] => _Variable.9
    EPSILON => _Variable.6

<_Variable>: "var" NAME : name [ ":"@ _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.9
    <_Type> => _Variable.6
        ASSIGN type

<_Variable>: "var" NAME : name [ ":" _Type : type ]@ "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.6
    [ASSIGN "="] => _Variable.5

<_Variable>: "var" NAME : name [ ":" _Type : type ] "="@ _Expression : expression ";" as VariableDeclaration
STATE _Variable.5
    <_Expression> => _Variable.4
        ASSIGN expression

<_Variable>: "var" NAME : name [ ":" _Type : type ] "=" _Expression : expression@ ";" as VariableDeclaration
STATE _Variable.4
    [SEMICOLON ";"] => _Variable.3

<_Variable>: "var" NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration@
STATE _Variable.3
    EPSILON => _Variable.2.End
        CREATE VariableDeclaration

<_Variable>: "var" NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration@
END STATE _Variable.2.End
    TOKEN-FINISH => _Variable.RootEnd

$<_Variable> @
STATE _Variable.RootEnd

--------------------------------
@ $<_Event>
STATE _Event.RootStart
    TOKEN-BEGIN => _Event.Start

@ <_Event>
STATE _Event.Start
    EPSILON => _Event.1

<_Event>: @"event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.1
    [KEYWORD_EVENT "event"] => _Event.8

<_Event>: "event"@ NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.8
    [NAME] => _Event.7
        ASSIGN name

<_Event>: "event" NAME : name@ "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.7
    [OPEN_BRACKET "("] => _Event.6

<_Event>: "event" NAME : name "("@ [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.6
    <_Type> => _Event.9
        ASSIGN arguments
    EPSILON => _Event.5

<_Event>: "event" NAME : name "(" [ _Type : arguments@ { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.9
    EPSILON => _Event.10

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ]@ ")" ";" as EventDeclaration
STATE _Event.5
    [CLOSE_BRACKET ")"] => _Event.4

<_Event>: "event" NAME : name "(" [ _Type : arguments @{ "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.10
    EPSILON => _Event.5
    [COMMA ","] => _Event.11

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")"@ ";" as EventDeclaration
STATE _Event.4
    [SEMICOLON ";"] => _Event.3

<_Event>: "event" NAME : name "(" [ _Type : arguments { ","@ _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.11
    <_Type> => _Event.10
        ASSIGN arguments

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration@
STATE _Event.3
    EPSILON => _Event.2.End
        CREATE EventDeclaration

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration@
END STATE _Event.2.End
    TOKEN-FINISH => _Event.RootEnd

$<_Event> @
STATE _Event.RootEnd

--------------------------------
@ $<_Property>
STATE _Property.RootStart
    TOKEN-BEGIN => _Property.Start

@ <_Property>
STATE _Property.Start
    EPSILON => _Property.1

<_Property>: @"prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.1
    [KEYWORD_PROP "prop"] => _Property.11

<_Property>: "prop"@ NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.11
    [NAME] => _Property.10
        ASSIGN name

<_Property>: "prop" NAME : name@ ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.10
    [COLON ":"] => _Property.9

<_Property>: "prop" NAME : name ":"@ _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.9
    <_Type> => _Property.8
        ASSIGN type

<_Property>: "prop" NAME : name ":" _Type : type@ "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.8
    [OPEN_BRACE "{"] => _Property.7

<_Property>: "prop" NAME : name ":" _Type : type "{"@ NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.7
    [NAME] => _Property.6
        ASSIGN getter

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter@ [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.6
    [COMMA ","] => _Property.12
    EPSILON => _Property.5

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ ","@ NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.12
    [NAME] => _Property.5
        ASSIGN setter

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ]@ [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.5
    [COLON ":"] => _Property.13
    EPSILON => _Property.4

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":"@ NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.13
    [NAME] => _Property.4
        ASSIGN valueChangedEvent

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ]@ "}" as PropertyDeclaration
STATE _Property.4
    [CLOSE_BRACE "}"] => _Property.3

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration@
STATE _Property.3
    EPSILON => _Property.2.End
        CREATE PropertyDeclaration

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration@
END STATE _Property.2.End
    TOKEN-FINISH => _Property.RootEnd

$<_Property> @
STATE _Property.RootEnd

--------------------------------
@ $<_BaseConstructorCall>
STATE _BaseConstructorCall.RootStart
    TOKEN-BEGIN => _BaseConstructorCall.Start

@ <_BaseConstructorCall>
STATE _BaseConstructorCall.Start
    EPSILON => _BaseConstructorCall.1

<_BaseConstructorCall>: @_Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.1
    <_Type> => _BaseConstructorCall.6
        ASSIGN type

<_BaseConstructorCall>: _Type : type@ "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.6
    [OPEN_BRACKET "("] => _BaseConstructorCall.5

<_BaseConstructorCall>: _Type : type "("@ [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.5
    <_Expression> => _BaseConstructorCall.7
        ASSIGN arguments
    EPSILON => _BaseConstructorCall.4

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments@ { "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.7
    EPSILON => _BaseConstructorCall.8

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ]@ ")" as BaseConstructorCall
STATE _BaseConstructorCall.4
    [CLOSE_BRACKET ")"] => _BaseConstructorCall.3

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments @{ "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.8
    EPSILON => _BaseConstructorCall.4
    [COMMA ","] => _BaseConstructorCall.9

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall@
STATE _BaseConstructorCall.3
    EPSILON => _BaseConstructorCall.2.End
        CREATE BaseConstructorCall

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { ","@ _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.9
    <_Expression> => _BaseConstructorCall.8
        ASSIGN arguments

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall@
END STATE _BaseConstructorCall.2.End
    TOKEN-FINISH => _BaseConstructorCall.RootEnd

$<_BaseConstructorCall> @
STATE _BaseConstructorCall.RootEnd

--------------------------------
@ $<_Constructor>
STATE _Constructor.RootStart
    TOKEN-BEGIN => _Constructor.Start

@ <_Constructor>
STATE _Constructor.Start
    EPSILON => _Constructor.1

<_Constructor>: @( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.1
    [KEYWORD_NEW "new"] => _Constructor.9
    [KEYWORD_NEW "new"] => _Constructor.11

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) )@ "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.9
    EPSILON => _Constructor.8
        SET constructorType => SharedPtr

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new"@ "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.11
    [MUL "*"] => _Constructor.10

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) )@ "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.8
    [OPEN_BRACKET "("] => _Constructor.7

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) )@ "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.10
    EPSILON => _Constructor.8
        SET constructorType => RawPtr

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "("@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.7
    <_FunctionArgument> => _Constructor.12
        ASSIGN arguments
    EPSILON => _Constructor.6

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments@ { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.12
    EPSILON => _Constructor.13

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ]@ ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.6
    [CLOSE_BRACKET ")"] => _Constructor.5

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments @{ "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.13
    EPSILON => _Constructor.6
    [COMMA ","] => _Constructor.14

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")"@ [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.5
    [COLON ":"] => _Constructor.16
    EPSILON => _Constructor.4

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { ","@ _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.14
    <_FunctionArgument> => _Constructor.13
        ASSIGN arguments

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":"@ _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.16
    <_BaseConstructorCall> => _Constructor.15
        ASSIGN baseConstructorCalls

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ]@ _Block : statement as ConstructorDeclaration
STATE _Constructor.4
    <_Block> => _Constructor.3
        ASSIGN statement

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls@ { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.15
    EPSILON => _Constructor.17

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration@
STATE _Constructor.3
    EPSILON => _Constructor.2.End
        CREATE ConstructorDeclaration

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls @{ "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.17
    EPSILON => _Constructor.4
    [COMMA ","] => _Constructor.18

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration@
END STATE _Constructor.2.End
    TOKEN-FINISH => _Constructor.RootEnd

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { ","@ _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.18
    <_BaseConstructorCall> => _Constructor.17
        ASSIGN baseConstructorCalls

$<_Constructor> @
STATE _Constructor.RootEnd

--------------------------------
@ $<_Destructor>
STATE _Destructor.RootStart
    TOKEN-BEGIN => _Destructor.Start

@ <_Destructor>
STATE _Destructor.Start
    EPSILON => _Destructor.1

<_Destructor>: @"delete" _Block : statement as DestructorDeclaration
STATE _Destructor.1
    [KEYWORD_DELETE "delete"] => _Destructor.4

<_Destructor>: "delete"@ _Block : statement as DestructorDeclaration
STATE _Destructor.4
    <_Block> => _Destructor.3
        ASSIGN statement

<_Destructor>: "delete" _Block : statement as DestructorDeclaration@
STATE _Destructor.3
    EPSILON => _Destructor.2.End
        CREATE DestructorDeclaration

<_Destructor>: "delete" _Block : statement as DestructorDeclaration@
END STATE _Destructor.2.End
    TOKEN-FINISH => _Destructor.RootEnd

$<_Destructor> @
STATE _Destructor.RootEnd

--------------------------------
@ $<_ClassBody>
STATE _ClassBody.RootStart
    TOKEN-BEGIN => _ClassBody.Start

@ <_ClassBody>
STATE _ClassBody.Start
    EPSILON => _ClassBody.1

<_ClassBody>: @[ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.1
    [COLON ":"] => _ClassBody.8
    EPSILON => _ClassBody.6

<_ClassBody>: [ ":"@ _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.8
    <_Type> => _ClassBody.7
        ASSIGN baseTypes

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ]@ "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.6
    [OPEN_BRACE "{"] => _ClassBody.5

<_ClassBody>: [ ":" _Type : baseTypes@ { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.7
    EPSILON => _ClassBody.9

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{"@ { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.5
    EPSILON => _ClassBody.11

<_ClassBody>: [ ":" _Type : baseTypes @{ "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.9
    EPSILON => _ClassBody.6
    [COMMA ","] => _ClassBody.10

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" @{ _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.11
    EPSILON => _ClassBody.4
    <_MemberDeclaration> => _ClassBody.11
        ASSIGN declarations

<_ClassBody>: [ ":" _Type : baseTypes { ","@ _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.10
    <_Type> => _ClassBody.9
        ASSIGN baseTypes

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations }@ "}" as ClassDeclaration
STATE _ClassBody.4
    [CLOSE_BRACE "}"] => _ClassBody.3

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration@
STATE _ClassBody.3
    EPSILON => _ClassBody.2.End
        CREATE ClassDeclaration

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration@
END STATE _ClassBody.2.End
    TOKEN-FINISH => _ClassBody.RootEnd

$<_ClassBody> @
STATE _ClassBody.RootEnd

--------------------------------
@ $<_Class>
STATE _Class.RootStart
    TOKEN-BEGIN => _Class.Start

@ <_Class>
STATE _Class.Start
    EPSILON => _Class.1
    EPSILON => _Class.7
    EPSILON => _Class.13

<_Class>: @"class" NAME : name !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }
STATE _Class.1
    [KEYWORD_CLASS "class"] => _Class.6

<_Class>: @"interface" NAME : name !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }
STATE _Class.7
    [TYPE_INTERFACE "interface"] => _Class.12

<_Class>: @"interface" NAME : name "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.13
    [TYPE_INTERFACE "interface"] => _Class.19

<_Class>: "class"@ NAME : name !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }
STATE _Class.6
    [NAME] => _Class.5
        ASSIGN name

<_Class>: "interface"@ NAME : name !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }
STATE _Class.12
    [NAME] => _Class.11
        ASSIGN name

<_Class>: "interface"@ NAME : name "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.19
    [NAME] => _Class.18
        ASSIGN name

<_Class>: "class" NAME : name@ !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }
STATE _Class.5
    <_ClassBody> => _Class.4
        USING 

<_Class>: "interface" NAME : name@ !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }
STATE _Class.11
    <_ClassBody> => _Class.10
        USING 

<_Class>: "interface" NAME : name@ "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.18
    [MUL "*"] => _Class.17

<_Class>: "class" NAME : name !_ClassBody@ with { kind = "Class" } with { constructorType = "Undefined" }
STATE _Class.4
    EPSILON => _Class.3
        SET kind => Class

<_Class>: "interface" NAME : name !_ClassBody@ with { kind = "Interface" } with { constructorType = "SharedPtr" }
STATE _Class.10
    EPSILON => _Class.9
        SET kind => Interface

<_Class>: "interface" NAME : name "*"@ !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.17
    <_ClassBody> => _Class.16
        USING 

<_Class>: "class" NAME : name !_ClassBody with { kind = "Class" }@ with { constructorType = "Undefined" }
STATE _Class.3
    EPSILON => _Class.2.End
        SET constructorType => Undefined

<_Class>: "interface" NAME : name !_ClassBody with { kind = "Interface" }@ with { constructorType = "SharedPtr" }
STATE _Class.9
    EPSILON => _Class.8.End
        SET constructorType => SharedPtr

<_Class>: "interface" NAME : name "*" !_ClassBody@ with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.16
    EPSILON => _Class.15
        SET kind => Interface

<_Class>: "class" NAME : name !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }@
END STATE _Class.2.End
    TOKEN-FINISH => _Class.RootEnd

<_Class>: "interface" NAME : name !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }@
END STATE _Class.8.End
    TOKEN-FINISH => _Class.RootEnd

<_Class>: "interface" NAME : name "*" !_ClassBody with { kind = "Interface" }@ with { constructorType = "RawPtr" }
STATE _Class.15
    EPSILON => _Class.14.End
        SET constructorType => RawPtr

$<_Class> @
STATE _Class.RootEnd

<_Class>: "interface" NAME : name "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }@
END STATE _Class.14.End
    TOKEN-FINISH => _Class.RootEnd

--------------------------------
@ $<_EnumItemInt>
STATE _EnumItemInt.RootStart
    TOKEN-BEGIN => _EnumItemInt.Start

@ <_EnumItemInt>
STATE _EnumItemInt.Start
    EPSILON => _EnumItemInt.1

<_EnumItemInt>: @NAME : name as EnumItemIntersection
STATE _EnumItemInt.1
    [NAME] => _EnumItemInt.3
        ASSIGN name

<_EnumItemInt>: NAME : name as EnumItemIntersection@
STATE _EnumItemInt.3
    EPSILON => _EnumItemInt.2.End
        CREATE EnumItemIntersection

<_EnumItemInt>: NAME : name as EnumItemIntersection@
END STATE _EnumItemInt.2.End
    TOKEN-FINISH => _EnumItemInt.RootEnd

$<_EnumItemInt> @
STATE _EnumItemInt.RootEnd

--------------------------------
@ $<_EnumItemA>
STATE _EnumItemA.RootStart
    TOKEN-BEGIN => _EnumItemA.Start

@ <_EnumItemA>
STATE _EnumItemA.Start
    EPSILON => _EnumItemA.1

<_EnumItemA>: @{ _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.1
    EPSILON => _EnumItemA.9

<_EnumItemA>: @{ _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.9
    EPSILON => _EnumItemA.8
    <_Attribute> => _EnumItemA.9
        ASSIGN attributes

<_EnumItemA>: { _Attribute : attributes }@ NAME : name "=" INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.8
    [NAME] => _EnumItemA.7
        ASSIGN name

<_EnumItemA>: { _Attribute : attributes } NAME : name@ "=" INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.7
    [ASSIGN "="] => _EnumItemA.6

<_EnumItemA>: { _Attribute : attributes } NAME : name "="@ INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.6
    [INTEGER] => _EnumItemA.5
        ASSIGN number

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number@ "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.5
    [COMMA ","] => _EnumItemA.4

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem@ with { kind = "Constant" }
STATE _EnumItemA.4
    EPSILON => _EnumItemA.3
        CREATE EnumItem

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem@ with { kind = "Constant" }
STATE _EnumItemA.3
    EPSILON => _EnumItemA.2.End
        SET kind => Constant

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem with { kind = "Constant" }@
END STATE _EnumItemA.2.End
    TOKEN-FINISH => _EnumItemA.RootEnd

$<_EnumItemA> @
STATE _EnumItemA.RootEnd

--------------------------------
@ $<_EnumItemB>
STATE _EnumItemB.RootStart
    TOKEN-BEGIN => _EnumItemB.Start

@ <_EnumItemB>
STATE _EnumItemB.Start
    EPSILON => _EnumItemB.1

<_EnumItemB>: @{ _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.1
    EPSILON => _EnumItemB.10

<_EnumItemB>: @{ _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.10
    EPSILON => _EnumItemB.9
    <_Attribute> => _EnumItemB.10
        ASSIGN attributes

<_EnumItemB>: { _Attribute : attributes }@ NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.9
    [NAME] => _EnumItemB.8
        ASSIGN name

<_EnumItemB>: { _Attribute : attributes } NAME : name@ "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.8
    [ASSIGN "="] => _EnumItemB.7

<_EnumItemB>: { _Attribute : attributes } NAME : name "="@ _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.7
    <_EnumItemInt> => _EnumItemB.6
        ASSIGN intersections

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections@ { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.6
    EPSILON => _EnumItemB.11

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections @{ "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.11
    EPSILON => _EnumItemB.5
    [INTERSECTION "|"] => _EnumItemB.12

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections }@ "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.5
    [COMMA ","] => _EnumItemB.4

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|"@ _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.12
    <_EnumItemInt> => _EnumItemB.11
        ASSIGN intersections

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem@ with { kind = "Intersection" }
STATE _EnumItemB.4
    EPSILON => _EnumItemB.3
        CREATE EnumItem

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem@ with { kind = "Intersection" }
STATE _EnumItemB.3
    EPSILON => _EnumItemB.2.End
        SET kind => Intersection

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }@
END STATE _EnumItemB.2.End
    TOKEN-FINISH => _EnumItemB.RootEnd

$<_EnumItemB> @
STATE _EnumItemB.RootEnd

--------------------------------
@ $<_Enum>
STATE _Enum.RootStart
    TOKEN-BEGIN => _Enum.Start

@ <_Enum>
STATE _Enum.Start
    EPSILON => _Enum.1
    EPSILON => _Enum.11

<_Enum>: @"enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.1
    [KEYWORD_ENUM "enum"] => _Enum.9

<_Enum>: @"flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.11
    [KEYWORD_FLAGENUM "flagenum"] => _Enum.20

<_Enum>: "enum"@ NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.9
    [NAME] => _Enum.8
        ASSIGN name

<_Enum>: "flagenum"@ NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.20
    [NAME] => _Enum.19
        ASSIGN name

<_Enum>: "enum" NAME : name@ "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.8
    [OPEN_BRACE "{"] => _Enum.7

<_Enum>: "flagenum" NAME : name@ "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.19
    [OPEN_BRACE "{"] => _Enum.18

<_Enum>: "enum" NAME : name "{"@ _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.7
    <_EnumItemA> => _Enum.6
        ASSIGN items

<_Enum>: "flagenum" NAME : name "{"@ _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.18
    <_EnumItemA> => _Enum.17
        ASSIGN items

<_Enum>: "enum" NAME : name "{" _EnumItemA : items@ { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.6
    EPSILON => _Enum.10

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items@ { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.17
    EPSILON => _Enum.21

<_Enum>: "enum" NAME : name "{" _EnumItemA : items @{ _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.10
    EPSILON => _Enum.5
    <_EnumItemA> => _Enum.10
        ASSIGN items

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items @{ _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.21
    EPSILON => _Enum.16
    <_EnumItemA> => _Enum.21
        ASSIGN items

<_Enum>: "enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items }@ "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.5
    [CLOSE_BRACE "}"] => _Enum.4

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items }@ { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.16
    EPSILON => _Enum.22

<_Enum>: "enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration@ with { kind = "Normal" }
STATE _Enum.4
    EPSILON => _Enum.3
        CREATE EnumDeclaration

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } @{ _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.22
    EPSILON => _Enum.15
    <_EnumItemB> => _Enum.22
        ASSIGN items

<_Enum>: "enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration@ with { kind = "Normal" }
STATE _Enum.3
    EPSILON => _Enum.2.End
        SET kind => Normal

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items }@ "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.15
    [CLOSE_BRACE "}"] => _Enum.14

<_Enum>: "enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }@
END STATE _Enum.2.End
    TOKEN-FINISH => _Enum.RootEnd

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration@ with { kind = "Flag" }
STATE _Enum.14
    EPSILON => _Enum.13
        CREATE EnumDeclaration

$<_Enum> @
STATE _Enum.RootEnd

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration@ with { kind = "Flag" }
STATE _Enum.13
    EPSILON => _Enum.12.End
        SET kind => Flag

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }@
END STATE _Enum.12.End
    TOKEN-FINISH => _Enum.RootEnd

--------------------------------
@ $<_StructMember>
STATE _StructMember.RootStart
    TOKEN-BEGIN => _StructMember.Start

@ <_StructMember>
STATE _StructMember.Start
    EPSILON => _StructMember.1

<_StructMember>: @{ _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember
STATE _StructMember.1
    EPSILON => _StructMember.8

<_StructMember>: @{ _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember
STATE _StructMember.8
    EPSILON => _StructMember.7
    <_Attribute> => _StructMember.8
        ASSIGN attributes

<_StructMember>: { _Attribute : attributes }@ NAME : name ":" _Type : type ";" as StructMember
STATE _StructMember.7
    [NAME] => _StructMember.6
        ASSIGN name

<_StructMember>: { _Attribute : attributes } NAME : name@ ":" _Type : type ";" as StructMember
STATE _StructMember.6
    [COLON ":"] => _StructMember.5

<_StructMember>: { _Attribute : attributes } NAME : name ":"@ _Type : type ";" as StructMember
STATE _StructMember.5
    <_Type> => _StructMember.4
        ASSIGN type

<_StructMember>: { _Attribute : attributes } NAME : name ":" _Type : type@ ";" as StructMember
STATE _StructMember.4
    [SEMICOLON ";"] => _StructMember.3

<_StructMember>: { _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember@
STATE _StructMember.3
    EPSILON => _StructMember.2.End
        CREATE StructMember

<_StructMember>: { _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember@
END STATE _StructMember.2.End
    TOKEN-FINISH => _StructMember.RootEnd

$<_StructMember> @
STATE _StructMember.RootEnd

--------------------------------
@ $<_Struct>
STATE _Struct.RootStart
    TOKEN-BEGIN => _Struct.Start

@ <_Struct>
STATE _Struct.Start
    EPSILON => _Struct.1

<_Struct>: @"struct" NAME : name "{" { _StructMember : members } "}" as StructDeclaration
STATE _Struct.1
    [KEYWORD_STRUCT "struct"] => _Struct.7

<_Struct>: "struct"@ NAME : name "{" { _StructMember : members } "}" as StructDeclaration
STATE _Struct.7
    [NAME] => _Struct.6
        ASSIGN name

<_Struct>: "struct" NAME : name@ "{" { _StructMember : members } "}" as StructDeclaration
STATE _Struct.6
    [OPEN_BRACE "{"] => _Struct.5

<_Struct>: "struct" NAME : name "{"@ { _StructMember : members } "}" as StructDeclaration
STATE _Struct.5
    EPSILON => _Struct.8

<_Struct>: "struct" NAME : name "{" @{ _StructMember : members } "}" as StructDeclaration
STATE _Struct.8
    EPSILON => _Struct.4
    <_StructMember> => _Struct.8
        ASSIGN members

<_Struct>: "struct" NAME : name "{" { _StructMember : members }@ "}" as StructDeclaration
STATE _Struct.4
    [CLOSE_BRACE "}"] => _Struct.3

<_Struct>: "struct" NAME : name "{" { _StructMember : members } "}" as StructDeclaration@
STATE _Struct.3
    EPSILON => _Struct.2.End
        CREATE StructDeclaration

<_Struct>: "struct" NAME : name "{" { _StructMember : members } "}" as StructDeclaration@
END STATE _Struct.2.End
    TOKEN-FINISH => _Struct.RootEnd

$<_Struct> @
STATE _Struct.RootEnd

--------------------------------
@ $<_APConfig>
STATE _APConfig.RootStart
    TOKEN-BEGIN => _APConfig.Start

@ <_APConfig>
STATE _APConfig.Start
    EPSILON => _APConfig.1
    EPSILON => _APConfig.7
    EPSILON => _APConfig.14
    EPSILON => _APConfig.22

<_APConfig>: @"{" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "Observable" }
STATE _APConfig.1
    [OPEN_BRACE "{"] => _APConfig.6

<_APConfig>: @"{" "const" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }
STATE _APConfig.7
    [OPEN_BRACE "{"] => _APConfig.13

<_APConfig>: @"{" "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
STATE _APConfig.14
    [OPEN_BRACE "{"] => _APConfig.21

<_APConfig>: @"{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.22
    [OPEN_BRACE "{"] => _APConfig.31

<_APConfig>: "{"@ "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "Observable" }
STATE _APConfig.6
    [CLOSE_BRACE "}"] => _APConfig.5

<_APConfig>: "{"@ "const" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }
STATE _APConfig.13
    [KEYWORD_CONST "const"] => _APConfig.12

<_APConfig>: "{"@ "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
STATE _APConfig.21
    [KEYWORD_NOT "not"] => _APConfig.20

<_APConfig>: "{"@ "const" "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.31
    [KEYWORD_CONST "const"] => _APConfig.30

<_APConfig>: "{" "}" as AutoPropertyDeclaration@ with { configConst = "Writable" } with { configObserve = "Observable" }
STATE _APConfig.5
    EPSILON => _APConfig.4
        CREATE AutoPropertyDeclaration

<_APConfig>: "{" "const"@ "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }
STATE _APConfig.12
    [CLOSE_BRACE "}"] => _APConfig.11

<_APConfig>: "{" "not"@ "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
STATE _APConfig.20
    [KEYWORD_OBSERVE "observe"] => _APConfig.19

<_APConfig>: "{" "const"@ "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.30
    [COMMA ","] => _APConfig.29

<_APConfig>: "{" "}" as AutoPropertyDeclaration@ with { configConst = "Writable" } with { configObserve = "Observable" }
STATE _APConfig.4
    EPSILON => _APConfig.3
        SET configConst => Writable

<_APConfig>: "{" "const" "}" as AutoPropertyDeclaration@ with { configConst = "Readonly" } with { configObserve = "Observable" }
STATE _APConfig.11
    EPSILON => _APConfig.10
        CREATE AutoPropertyDeclaration

<_APConfig>: "{" "not" "observe"@ "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
STATE _APConfig.19
    [CLOSE_BRACE "}"] => _APConfig.18

<_APConfig>: "{" "const" ","@ "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.29
    [KEYWORD_NOT "not"] => _APConfig.28

<_APConfig>: "{" "}" as AutoPropertyDeclaration with { configConst = "Writable" }@ with { configObserve = "Observable" }
STATE _APConfig.3
    EPSILON => _APConfig.2.End
        SET configObserve => Observable

<_APConfig>: "{" "const" "}" as AutoPropertyDeclaration@ with { configConst = "Readonly" } with { configObserve = "Observable" }
STATE _APConfig.10
    EPSILON => _APConfig.9
        SET configConst => Readonly

<_APConfig>: "{" "not" "observe" "}" as AutoPropertyDeclaration@ with { configConst = "Writable" } with { configObserve = "NotObservable" }
STATE _APConfig.18
    EPSILON => _APConfig.17
        CREATE AutoPropertyDeclaration

<_APConfig>: "{" "const" "," "not"@ "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.28
    [KEYWORD_OBSERVE "observe"] => _APConfig.27

<_APConfig>: "{" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "Observable" }@
END STATE _APConfig.2.End
    TOKEN-FINISH => _APConfig.RootEnd

<_APConfig>: "{" "const" "}" as AutoPropertyDeclaration with { configConst = "Readonly" }@ with { configObserve = "Observable" }
STATE _APConfig.9
    EPSILON => _APConfig.8.End
        SET configObserve => Observable

<_APConfig>: "{" "not" "observe" "}" as AutoPropertyDeclaration@ with { configConst = "Writable" } with { configObserve = "NotObservable" }
STATE _APConfig.17
    EPSILON => _APConfig.16
        SET configConst => Writable

<_APConfig>: "{" "const" "," "not" "observe"@ "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.27
    [CLOSE_BRACE "}"] => _APConfig.26

$<_APConfig> @
STATE _APConfig.RootEnd

<_APConfig>: "{" "const" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }@
END STATE _APConfig.8.End
    TOKEN-FINISH => _APConfig.RootEnd

<_APConfig>: "{" "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" }@ with { configObserve = "NotObservable" }
STATE _APConfig.16
    EPSILON => _APConfig.15.End
        SET configObserve => NotObservable

<_APConfig>: "{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration@ with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.26
    EPSILON => _APConfig.25
        CREATE AutoPropertyDeclaration

<_APConfig>: "{" "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }@
END STATE _APConfig.15.End
    TOKEN-FINISH => _APConfig.RootEnd

<_APConfig>: "{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration@ with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.25
    EPSILON => _APConfig.24
        SET configConst => Readonly

<_APConfig>: "{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" }@ with { configObserve = "NotObservable" }
STATE _APConfig.24
    EPSILON => _APConfig.23.End
        SET configObserve => NotObservable

<_APConfig>: "{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }@
END STATE _APConfig.23.End
    TOKEN-FINISH => _APConfig.RootEnd

--------------------------------
@ $<_AutoProperty>
STATE _AutoProperty.RootStart
    TOKEN-BEGIN => _AutoProperty.Start

@ <_AutoProperty>
STATE _AutoProperty.Start
    EPSILON => _AutoProperty.1

<_AutoProperty>: @"prop" NAME : name ":" _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.1
    [KEYWORD_PROP "prop"] => _AutoProperty.7

<_AutoProperty>: "prop"@ NAME : name ":" _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.7
    [NAME] => _AutoProperty.6
        ASSIGN name

<_AutoProperty>: "prop" NAME : name@ ":" _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.6
    [COLON ":"] => _AutoProperty.5

<_AutoProperty>: "prop" NAME : name ":"@ _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.5
    <_Type> => _AutoProperty.4
        ASSIGN type

<_AutoProperty>: "prop" NAME : name ":" _Type : type@ [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.4
    [ASSIGN "="] => _AutoProperty.8
    EPSILON => _AutoProperty.3

<_AutoProperty>: "prop" NAME : name ":" _Type : type [ "="@ _Expression : expression ] !_APConfig
STATE _AutoProperty.8
    <_Expression> => _AutoProperty.3
        ASSIGN expression

<_AutoProperty>: "prop" NAME : name ":" _Type : type [ "=" _Expression : expression ]@ !_APConfig
STATE _AutoProperty.3
    <_APConfig> => _AutoProperty.2.End
        USING 

<_AutoProperty>: "prop" NAME : name ":" _Type : type [ "=" _Expression : expression ] !_APConfig@
END STATE _AutoProperty.2.End
    TOKEN-FINISH => _AutoProperty.RootEnd

$<_AutoProperty> @
STATE _AutoProperty.RootEnd

--------------------------------
@ $<_CastResultInterface>
STATE _CastResultInterface.RootStart
    TOKEN-BEGIN => _CastResultInterface.Start

@ <_CastResultInterface>
STATE _CastResultInterface.Start
    EPSILON => _CastResultInterface.1

<_CastResultInterface>: @"$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.1
    [COROUTINE_INTERFACE "$interface"] => _CastResultInterface.10

<_CastResultInterface>: "$interface"@ NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.10
    [NAME] => _CastResultInterface.9
        ASSIGN name

<_CastResultInterface>: "$interface" NAME : name@ ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.9
    [COLON ":"] => _CastResultInterface.8

<_CastResultInterface>: "$interface" NAME : name ":"@ _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.8
    <_Type> => _CastResultInterface.7
        ASSIGN baseType

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType@ "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.7
    [LT "<"] => _CastResultInterface.6

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<"@ _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.6
    <_Type> => _CastResultInterface.5
        ASSIGN elementType

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType@ ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.5
    [GT ">"] => _CastResultInterface.4

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">"@ ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.4
    [SEMICOLON ";"] => _CastResultInterface.3

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration@
STATE _CastResultInterface.3
    EPSILON => _CastResultInterface.2.End
        CREATE CastResultInterfaceDeclaration

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration@
END STATE _CastResultInterface.2.End
    TOKEN-FINISH => _CastResultInterface.RootEnd

$<_CastResultInterface> @
STATE _CastResultInterface.RootEnd

--------------------------------
@ $<_SharedDeclarationBranch>
STATE _SharedDeclarationBranch.RootStart
    TOKEN-BEGIN => _SharedDeclarationBranch.Start

@ <_SharedDeclarationBranch>
STATE _SharedDeclarationBranch.Start
    EPSILON => _SharedDeclarationBranch.1
    EPSILON => _SharedDeclarationBranch.3
    EPSILON => _SharedDeclarationBranch.5
    EPSILON => _SharedDeclarationBranch.7
    EPSILON => _SharedDeclarationBranch.9
    EPSILON => _SharedDeclarationBranch.11
    EPSILON => _SharedDeclarationBranch.13
    EPSILON => _SharedDeclarationBranch.15
    EPSILON => _SharedDeclarationBranch.17
    EPSILON => _SharedDeclarationBranch.19

<_SharedDeclarationBranch>: @!_Namespace
STATE _SharedDeclarationBranch.1
    <_Namespace> => _SharedDeclarationBranch.2.End
        USING 

<_SharedDeclarationBranch>: @!_Variable
STATE _SharedDeclarationBranch.3
    <_Variable> => _SharedDeclarationBranch.4.End
        USING 

<_SharedDeclarationBranch>: @!_Event
STATE _SharedDeclarationBranch.5
    <_Event> => _SharedDeclarationBranch.6.End
        USING 

<_SharedDeclarationBranch>: @!_Property
STATE _SharedDeclarationBranch.7
    <_Property> => _SharedDeclarationBranch.8.End
        USING 

<_SharedDeclarationBranch>: @!_Constructor
STATE _SharedDeclarationBranch.9
    <_Constructor> => _SharedDeclarationBranch.10.End
        USING 

<_SharedDeclarationBranch>: @!_Destructor
STATE _SharedDeclarationBranch.11
    <_Destructor> => _SharedDeclarationBranch.12.End
        USING 

<_SharedDeclarationBranch>: @!_Class
STATE _SharedDeclarationBranch.13
    <_Class> => _SharedDeclarationBranch.14.End
        USING 

<_SharedDeclarationBranch>: @!_Enum
STATE _SharedDeclarationBranch.15
    <_Enum> => _SharedDeclarationBranch.16.End
        USING 

<_SharedDeclarationBranch>: @!_Struct
STATE _SharedDeclarationBranch.17
    <_Struct> => _SharedDeclarationBranch.18.End
        USING 

<_SharedDeclarationBranch>: @!_CastResultInterface
STATE _SharedDeclarationBranch.19
    <_CastResultInterface> => _SharedDeclarationBranch.20.End
        USING 

<_SharedDeclarationBranch>: !_Namespace@
END STATE _SharedDeclarationBranch.2.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Variable@
END STATE _SharedDeclarationBranch.4.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Event@
END STATE _SharedDeclarationBranch.6.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Property@
END STATE _SharedDeclarationBranch.8.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Constructor@
END STATE _SharedDeclarationBranch.10.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Destructor@
END STATE _SharedDeclarationBranch.12.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Class@
END STATE _SharedDeclarationBranch.14.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Enum@
END STATE _SharedDeclarationBranch.16.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_Struct@
END STATE _SharedDeclarationBranch.18.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

<_SharedDeclarationBranch>: !_CastResultInterface@
END STATE _SharedDeclarationBranch.20.End
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd

$<_SharedDeclarationBranch> @
STATE _SharedDeclarationBranch.RootEnd

--------------------------------
@ $<_MemberDeclarationBranch>
STATE _MemberDeclarationBranch.RootStart
    TOKEN-BEGIN => _MemberDeclarationBranch.Start

@ <_MemberDeclarationBranch>
STATE _MemberDeclarationBranch.Start
    EPSILON => _MemberDeclarationBranch.1
    EPSILON => _MemberDeclarationBranch.3

<_MemberDeclarationBranch>: @!_Function
STATE _MemberDeclarationBranch.1
    <_Function> => _MemberDeclarationBranch.2.End
        USING 

<_MemberDeclarationBranch>: @!_AutoProperty
STATE _MemberDeclarationBranch.3
    <_AutoProperty> => _MemberDeclarationBranch.4.End
        USING 

<_MemberDeclarationBranch>: !_Function@
END STATE _MemberDeclarationBranch.2.End
    TOKEN-FINISH => _MemberDeclarationBranch.RootEnd

<_MemberDeclarationBranch>: !_AutoProperty@
END STATE _MemberDeclarationBranch.4.End
    TOKEN-FINISH => _MemberDeclarationBranch.RootEnd

$<_MemberDeclarationBranch> @
STATE _MemberDeclarationBranch.RootEnd

--------------------------------
@ $<_Declaration>
STATE _Declaration.RootStart
    TOKEN-BEGIN => _Declaration.Start

@ <_Declaration>
STATE _Declaration.Start
    EPSILON => _Declaration.1
    EPSILON => _Declaration.5

<_Declaration>: @{ _Attribute : attributes } !_SharedDeclarationBranch
STATE _Declaration.1
    EPSILON => _Declaration.4

<_Declaration>: @{ _Attribute : attributes } !_MemberDeclarationBranch
STATE _Declaration.5
    EPSILON => _Declaration.8

<_Declaration>: @{ _Attribute : attributes } !_SharedDeclarationBranch
STATE _Declaration.4
    EPSILON => _Declaration.3
    <_Attribute> => _Declaration.4
        ASSIGN attributes

<_Declaration>: @{ _Attribute : attributes } !_MemberDeclarationBranch
STATE _Declaration.8
    EPSILON => _Declaration.7
    <_Attribute> => _Declaration.8
        ASSIGN attributes

<_Declaration>: { _Attribute : attributes }@ !_SharedDeclarationBranch
STATE _Declaration.3
    <_SharedDeclarationBranch> => _Declaration.2.End
        USING 

<_Declaration>: { _Attribute : attributes }@ !_MemberDeclarationBranch
STATE _Declaration.7
    <_MemberDeclarationBranch> => _Declaration.6.End
        USING 

<_Declaration>: { _Attribute : attributes } !_SharedDeclarationBranch@
END STATE _Declaration.2.End
    TOKEN-FINISH => _Declaration.RootEnd

<_Declaration>: { _Attribute : attributes } !_MemberDeclarationBranch@
END STATE _Declaration.6.End
    TOKEN-FINISH => _Declaration.RootEnd

$<_Declaration> @
STATE _Declaration.RootEnd

--------------------------------
@ $<_ClassMember>
STATE _ClassMember.RootStart
    TOKEN-BEGIN => _ClassMember.Start

@ <_ClassMember>
STATE _ClassMember.Start
    EPSILON => _ClassMember.1
    EPSILON => _ClassMember.5

<_ClassMember>: @"static" as ClassMember with { kind = "Static" }
STATE _ClassMember.1
    [KEYWORD_STATIC "static"] => _ClassMember.4

<_ClassMember>: @"override" as ClassMember with { kind = "Override" }
STATE _ClassMember.5
    [KEYWORD_OVERRIDE "override"] => _ClassMember.8

<_ClassMember>: "static" as ClassMember@ with { kind = "Static" }
STATE _ClassMember.4
    EPSILON => _ClassMember.3
        CREATE ClassMember

<_ClassMember>: "override" as ClassMember@ with { kind = "Override" }
STATE _ClassMember.8
    EPSILON => _ClassMember.7
        CREATE ClassMember

<_ClassMember>: "static" as ClassMember@ with { kind = "Static" }
STATE _ClassMember.3
    EPSILON => _ClassMember.2.End
        SET kind => Static

<_ClassMember>: "override" as ClassMember@ with { kind = "Override" }
STATE _ClassMember.7
    EPSILON => _ClassMember.6.End
        SET kind => Override

<_ClassMember>: "static" as ClassMember with { kind = "Static" }@
END STATE _ClassMember.2.End
    TOKEN-FINISH => _ClassMember.RootEnd

<_ClassMember>: "override" as ClassMember with { kind = "Override" }@
END STATE _ClassMember.6.End
    TOKEN-FINISH => _ClassMember.RootEnd

$<_ClassMember> @
STATE _ClassMember.RootEnd

--------------------------------
@ $<_MemberDeclaration>
STATE _MemberDeclaration.RootStart
    TOKEN-BEGIN => _MemberDeclaration.Start

@ <_MemberDeclaration>
STATE _MemberDeclaration.Start
    EPSILON => _MemberDeclaration.1
    EPSILON => _MemberDeclaration.5

<_MemberDeclaration>: @{ _Attribute : attributes } !_SharedDeclarationBranch
STATE _MemberDeclaration.1
    EPSILON => _MemberDeclaration.4

<_MemberDeclaration>: @{ _Attribute : attributes } [ _ClassMember : classMember ] !_MemberDeclarationBranch
STATE _MemberDeclaration.5
    EPSILON => _MemberDeclaration.9

<_MemberDeclaration>: @{ _Attribute : attributes } !_SharedDeclarationBranch
STATE _MemberDeclaration.4
    EPSILON => _MemberDeclaration.3
    <_Attribute> => _MemberDeclaration.4
        ASSIGN attributes

<_MemberDeclaration>: @{ _Attribute : attributes } [ _ClassMember : classMember ] !_MemberDeclarationBranch
STATE _MemberDeclaration.9
    EPSILON => _MemberDeclaration.8
    <_Attribute> => _MemberDeclaration.9
        ASSIGN attributes

<_MemberDeclaration>: { _Attribute : attributes }@ !_SharedDeclarationBranch
STATE _MemberDeclaration.3
    <_SharedDeclarationBranch> => _MemberDeclaration.2.End
        USING 

<_MemberDeclaration>: { _Attribute : attributes }@ [ _ClassMember : classMember ] !_MemberDeclarationBranch
STATE _MemberDeclaration.8
    <_ClassMember> => _MemberDeclaration.7
        ASSIGN classMember
    EPSILON => _MemberDeclaration.7

<_MemberDeclaration>: { _Attribute : attributes } !_SharedDeclarationBranch@
END STATE _MemberDeclaration.2.End
    TOKEN-FINISH => _MemberDeclaration.RootEnd

<_MemberDeclaration>: { _Attribute : attributes } [ _ClassMember : classMember ]@ !_MemberDeclarationBranch
STATE _MemberDeclaration.7
    <_MemberDeclarationBranch> => _MemberDeclaration.6.End
        USING 

$<_MemberDeclaration> @
STATE _MemberDeclaration.RootEnd

<_MemberDeclaration>: { _Attribute : attributes } [ _ClassMember : classMember ] !_MemberDeclarationBranch@
END STATE _MemberDeclaration.6.End
    TOKEN-FINISH => _MemberDeclaration.RootEnd

--------------------------------
@ $<_UsingFragment>
STATE _UsingFragment.RootStart
    TOKEN-BEGIN => _UsingFragment.Start

@ <_UsingFragment>
STATE _UsingFragment.Start
    EPSILON => _UsingFragment.1
    EPSILON => _UsingFragment.4

<_UsingFragment>: @NAME : name as ModuleUsingNameFragment
STATE _UsingFragment.1
    [NAME] => _UsingFragment.3
        ASSIGN name

<_UsingFragment>: @"*" as ModuleUsingWildCardFragment
STATE _UsingFragment.4
    [MUL "*"] => _UsingFragment.6

<_UsingFragment>: NAME : name as ModuleUsingNameFragment@
STATE _UsingFragment.3
    EPSILON => _UsingFragment.2.End
        CREATE ModuleUsingNameFragment

<_UsingFragment>: "*" as ModuleUsingWildCardFragment@
STATE _UsingFragment.6
    EPSILON => _UsingFragment.5.End
        CREATE ModuleUsingWildCardFragment

<_UsingFragment>: NAME : name as ModuleUsingNameFragment@
END STATE _UsingFragment.2.End
    TOKEN-FINISH => _UsingFragment.RootEnd

<_UsingFragment>: "*" as ModuleUsingWildCardFragment@
END STATE _UsingFragment.5.End
    TOKEN-FINISH => _UsingFragment.RootEnd

$<_UsingFragment> @
STATE _UsingFragment.RootEnd

--------------------------------
@ $<_UsingItem>
STATE _UsingItem.RootStart
    TOKEN-BEGIN => _UsingItem.Start

@ <_UsingItem>
STATE _UsingItem.Start
    EPSILON => _UsingItem.1

<_UsingItem>: @_UsingFragment : fragments { _UsingFragment : fragments } as ModuleUsingItem
STATE _UsingItem.1
    <_UsingFragment> => _UsingItem.4
        ASSIGN fragments

<_UsingItem>: _UsingFragment : fragments@ { _UsingFragment : fragments } as ModuleUsingItem
STATE _UsingItem.4
    EPSILON => _UsingItem.5

<_UsingItem>: _UsingFragment : fragments @{ _UsingFragment : fragments } as ModuleUsingItem
STATE _UsingItem.5
    EPSILON => _UsingItem.3
    <_UsingFragment> => _UsingItem.5
        ASSIGN fragments

<_UsingItem>: _UsingFragment : fragments { _UsingFragment : fragments } as ModuleUsingItem@
STATE _UsingItem.3
    EPSILON => _UsingItem.2.End
        CREATE ModuleUsingItem

<_UsingItem>: _UsingFragment : fragments { _UsingFragment : fragments } as ModuleUsingItem@
END STATE _UsingItem.2.End
    TOKEN-FINISH => _UsingItem.RootEnd

$<_UsingItem> @
STATE _UsingItem.RootEnd

--------------------------------
@ $<_UsingPath>
STATE _UsingPath.RootStart
    TOKEN-BEGIN => _UsingPath.Start

@ <_UsingPath>
STATE _UsingPath.Start
    EPSILON => _UsingPath.1

<_UsingPath>: @"using" _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.1
    [KEYWORD_USING "using"] => _UsingPath.6

<_UsingPath>: "using"@ _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.6
    <_UsingItem> => _UsingPath.5
        ASSIGN items

<_UsingPath>: "using" _UsingItem : items@ { "::" _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.5
    EPSILON => _UsingPath.7

<_UsingPath>: "using" _UsingItem : items @{ "::" _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.7
    EPSILON => _UsingPath.4
    [SCOPE_DELIMITER "::"] => _UsingPath.8

<_UsingPath>: "using" _UsingItem : items { "::" _UsingItem : items }@ ";" as ModuleUsingPath
STATE _UsingPath.4
    [SEMICOLON ";"] => _UsingPath.3

<_UsingPath>: "using" _UsingItem : items { "::"@ _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.8
    <_UsingItem> => _UsingPath.7
        ASSIGN items

<_UsingPath>: "using" _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath@
STATE _UsingPath.3
    EPSILON => _UsingPath.2.End
        CREATE ModuleUsingPath

<_UsingPath>: "using" _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath@
END STATE _UsingPath.2.End
    TOKEN-FINISH => _UsingPath.RootEnd

$<_UsingPath> @
STATE _UsingPath.RootEnd

--------------------------------
@ $<_Module>
STATE _Module.RootStart
    TOKEN-BEGIN => _Module.Start

@ <_Module>
STATE _Module.Start
    EPSILON => _Module.1

<_Module>: @( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.1
    [KEYWORD_MODULE "module"] => _Module.8
    [KEYWORD_UNIT "unit"] => _Module.9

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) )@ NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.8
    EPSILON => _Module.7
        SET moduleType => Module

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) )@ NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.9
    EPSILON => _Module.7
        SET moduleType => Unit

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) )@ NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.7
    [NAME] => _Module.6
        ASSIGN name

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name@ ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.6
    [SEMICOLON ";"] => _Module.5

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";"@ { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.5
    EPSILON => _Module.10

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" @{ _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.10
    EPSILON => _Module.4
    <_UsingPath> => _Module.10
        ASSIGN paths

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths }@ { _Declaration : declarations } as Module
STATE _Module.4
    EPSILON => _Module.11

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths } @{ _Declaration : declarations } as Module
STATE _Module.11
    EPSILON => _Module.3
    <_Declaration> => _Module.11
        ASSIGN declarations

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module@
STATE _Module.3
    EPSILON => _Module.2.End
        CREATE Module

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module@
END STATE _Module.2.End
    TOKEN-FINISH => _Module.RootEnd

$<_Module> @
STATE _Module.RootEnd

--------------------------------
