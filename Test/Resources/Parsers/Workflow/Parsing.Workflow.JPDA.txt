=============================================================
Joint PDA
=============================================================
Root Rule Start: _Type.RootStart
Root Rule End: _Type.RootEnd
Rule Start: _Type.Start
Rule End: _Type.13

Root Rule Start: _CtorFragment.RootStart
Root Rule End: _CtorFragment.RootEnd
Rule Start: _CtorFragment.Start
Rule End: _CtorFragment.3

Root Rule Start: _LetVariable.RootStart
Root Rule End: _LetVariable.RootEnd
Rule Start: _LetVariable.Start
Rule End: _LetVariable.4

Root Rule Start: _VirtualExpression.RootStart
Root Rule End: _VirtualExpression.RootEnd
Rule Start: _VirtualExpression.Start
Rule End: _VirtualExpression.5

Root Rule Start: _ExpPrimitive.RootStart
Root Rule End: _ExpPrimitive.RootEnd
Rule Start: _ExpPrimitive.Start
Rule End: _ExpPrimitive.23

Root Rule Start: _Exp0.RootStart
Root Rule End: _Exp0.RootEnd
Rule Start: _Exp0.Start
Rule End: _Exp0.1

Root Rule Start: _Exp1.RootStart
Root Rule End: _Exp1.RootEnd
Rule Start: _Exp1.Start
Rule End: _Exp1.1

Root Rule Start: _Exp2.RootStart
Root Rule End: _Exp2.RootEnd
Rule Start: _Exp2.Start
Rule End: _Exp2.1

Root Rule Start: _Exp3.RootStart
Root Rule End: _Exp3.RootEnd
Rule Start: _Exp3.Start
Rule End: _Exp3.1

Root Rule Start: _Exp4.RootStart
Root Rule End: _Exp4.RootEnd
Rule Start: _Exp4.Start
Rule End: _Exp4.1

Root Rule Start: _Exp5.RootStart
Root Rule End: _Exp5.RootEnd
Rule Start: _Exp5.Start
Rule End: _Exp5.1

Root Rule Start: _Exp6.RootStart
Root Rule End: _Exp6.RootEnd
Rule Start: _Exp6.Start
Rule End: _Exp6.1

Root Rule Start: _Exp7.RootStart
Root Rule End: _Exp7.RootEnd
Rule Start: _Exp7.Start
Rule End: _Exp7.1

Root Rule Start: _Exp8.RootStart
Root Rule End: _Exp8.RootEnd
Rule Start: _Exp8.Start
Rule End: _Exp8.1

Root Rule Start: _Exp9.RootStart
Root Rule End: _Exp9.RootEnd
Rule Start: _Exp9.Start
Rule End: _Exp9.1

Root Rule Start: _Exp10.RootStart
Root Rule End: _Exp10.RootEnd
Rule Start: _Exp10.Start
Rule End: _Exp10.1

Root Rule Start: _Exp11.RootStart
Root Rule End: _Exp11.RootEnd
Rule Start: _Exp11.Start
Rule End: _Exp11.1

Root Rule Start: _Expression.RootStart
Root Rule End: _Expression.RootEnd
Rule Start: _Expression.Start
Rule End: _Expression.1

Root Rule Start: _SwitchCase.RootStart
Root Rule End: _SwitchCase.RootEnd
Rule Start: _SwitchCase.Start
Rule End: _SwitchCase.5

Root Rule Start: _Block.RootStart
Root Rule End: _Block.RootEnd
Rule Start: _Block.Start
Rule End: _Block.3

Root Rule Start: _If.RootStart
Root Rule End: _If.RootEnd
Rule Start: _If.Start
Rule End: _If.11

Root Rule Start: _VirtualStatement.RootStart
Root Rule End: _VirtualStatement.RootEnd
Rule Start: _VirtualStatement.Start
Rule End: _VirtualStatement.22

Root Rule Start: _CoStatement.RootStart
Root Rule End: _CoStatement.RootEnd
Rule Start: _CoStatement.Start
Rule End: _CoStatement.3

Root Rule Start: _CoProvider.RootStart
Root Rule End: _CoProvider.RootEnd
Rule Start: _CoProvider.Start
Rule End: _CoProvider.3

Root Rule Start: _Statement.RootStart
Root Rule End: _Statement.RootEnd
Rule Start: _Statement.Start
Rule End: _Statement.1

Root Rule Start: _Attribute.RootStart
Root Rule End: _Attribute.RootEnd
Rule Start: _Attribute.Start
Rule End: _Attribute.6

Root Rule Start: _Namespace.RootStart
Root Rule End: _Namespace.RootEnd
Rule Start: _Namespace.Start
Rule End: _Namespace.5

Root Rule Start: _FunctionArgument.RootStart
Root Rule End: _FunctionArgument.RootEnd
Rule Start: _FunctionArgument.Start
Rule End: _FunctionArgument.5

Root Rule Start: _Function.RootStart
Root Rule End: _Function.RootEnd
Rule Start: _Function.Start
Rule End: _Function.11

Root Rule Start: _Variable.RootStart
Root Rule End: _Variable.RootEnd
Rule Start: _Variable.Start
Rule End: _Variable.8

Root Rule Start: _Event.RootStart
Root Rule End: _Event.RootEnd
Rule Start: _Event.Start
Rule End: _Event.8

Root Rule Start: _Property.RootStart
Root Rule End: _Property.RootEnd
Rule Start: _Property.Start
Rule End: _Property.12

Root Rule Start: _BaseConstructorCall.RootStart
Root Rule End: _BaseConstructorCall.RootEnd
Rule Start: _BaseConstructorCall.Start
Rule End: _BaseConstructorCall.6

Root Rule Start: _Constructor.RootStart
Root Rule End: _Constructor.RootEnd
Rule Start: _Constructor.Start
Rule End: _Constructor.10

Root Rule Start: _Destructor.RootStart
Root Rule End: _Destructor.RootEnd
Rule Start: _Destructor.Start
Rule End: _Destructor.3

Root Rule Start: _ClassBody.RootStart
Root Rule End: _ClassBody.RootEnd
Rule Start: _ClassBody.Start
Rule End: _ClassBody.5

Root Rule Start: _Class.RootStart
Root Rule End: _Class.RootEnd
Rule Start: _Class.Start
Rule End: _Class.6

Root Rule Start: _EnumItemInt.RootStart
Root Rule End: _EnumItemInt.RootEnd
Rule Start: _EnumItemInt.Start
Rule End: _EnumItemInt.2

Root Rule Start: _EnumItemA.RootStart
Root Rule End: _EnumItemA.RootEnd
Rule Start: _EnumItemA.Start
Rule End: _EnumItemA.6

Root Rule Start: _EnumItemB.RootStart
Root Rule End: _EnumItemB.RootEnd
Rule Start: _EnumItemB.Start
Rule End: _EnumItemB.6

Root Rule Start: _Enum.RootStart
Root Rule End: _Enum.RootEnd
Rule Start: _Enum.Start
Rule End: _Enum.11

Root Rule Start: _StructMember.RootStart
Root Rule End: _StructMember.RootEnd
Rule Start: _StructMember.Start
Rule End: _StructMember.6

Root Rule Start: _Struct.RootStart
Root Rule End: _Struct.RootEnd
Rule Start: _Struct.Start
Rule End: _Struct.5

Root Rule Start: _APConfig.RootStart
Root Rule End: _APConfig.RootEnd
Rule Start: _APConfig.Start
Rule End: _APConfig.6

Root Rule Start: _AutoProperty.RootStart
Root Rule End: _AutoProperty.RootEnd
Rule Start: _AutoProperty.Start
Rule End: _AutoProperty.6

Root Rule Start: _CastResultInterface.RootStart
Root Rule End: _CastResultInterface.RootEnd
Rule Start: _CastResultInterface.Start
Rule End: _CastResultInterface.9

Root Rule Start: _SharedDeclarationBranch.RootStart
Root Rule End: _SharedDeclarationBranch.RootEnd
Rule Start: _SharedDeclarationBranch.Start
Rule End: _SharedDeclarationBranch.1

Root Rule Start: _MemberDeclarationBranch.RootStart
Root Rule End: _MemberDeclarationBranch.RootEnd
Rule Start: _MemberDeclarationBranch.Start
Rule End: _MemberDeclarationBranch.1

Root Rule Start: _Declaration.RootStart
Root Rule End: _Declaration.RootEnd
Rule Start: _Declaration.Start
Rule End: _Declaration.1

Root Rule Start: _ClassMember.RootStart
Root Rule End: _ClassMember.RootEnd
Rule Start: _ClassMember.Start
Rule End: _ClassMember.2

Root Rule Start: _MemberDeclaration.RootStart
Root Rule End: _MemberDeclaration.RootEnd
Rule Start: _MemberDeclaration.Start
Rule End: _MemberDeclaration.1

Root Rule Start: _UsingFragment.RootStart
Root Rule End: _UsingFragment.RootEnd
Rule Start: _UsingFragment.Start
Rule End: _UsingFragment.2

Root Rule Start: _UsingItem.RootStart
Root Rule End: _UsingItem.RootEnd
Rule Start: _UsingItem.Start
Rule End: _UsingItem.2

Root Rule Start: _UsingPath.RootStart
Root Rule End: _UsingPath.RootEnd
Rule Start: _UsingPath.Start
Rule End: _UsingPath.4

Root Rule Start: _Module.RootStart
Root Rule End: _Module.RootEnd
Rule Start: _Module.Start
Rule End: _Module.4

@ $<_Type>
STATE _Type.RootStart
    TOKEN-BEGIN => _Type.Start

@ <_Type>
STATE _Type.Start
    [TYPE_VOID "void"] => _Type.1
        SET name => Void
        CREATE PredefinedType
    [TYPE_OBJECT "object"] => _Type.1
        SET name => Object
        CREATE PredefinedType
    [TYPE_INTERFACE "interface"] => _Type.1
        SET name => Interface
        CREATE PredefinedType
    [TYPE_INT "int"] => _Type.1
        SET name => Int
        CREATE PredefinedType
    [TYPE_UINT "uint"] => _Type.1
        SET name => UInt
        CREATE PredefinedType
    [TYPE_FLOAT "float"] => _Type.1
        SET name => Float
        CREATE PredefinedType
    [TYPE_DOUBLE "double"] => _Type.1
        SET name => Double
        CREATE PredefinedType
    [TYPE_STRING "string"] => _Type.1
        SET name => String
        CREATE PredefinedType
    [TYPE_CHAR "char"] => _Type.1
        SET name => Char
        CREATE PredefinedType
    [TYPE_BOOL "bool"] => _Type.1
        SET name => Bool
        CREATE PredefinedType
    [NAME] => _Type.1
        ASSIGN name
        CREATE ReferenceType
    [KEYWORD_FUNC "func"] => _Type.2
    EPSILON => _Type.Start
        SHIFT [_Type.Start => _Type.3] 
    EPSILON => _Type.Start
        SHIFT [_Type.Start => _Type.4] 
    EPSILON => _Type.Start
        SHIFT [_Type.Start => _Type.5] 
    EPSILON => _Type.Start
        SHIFT [_Type.Start => _Type.6] 
    EPSILON => _Type.Start
        SHIFT [_Type.Start => _Type.7] 
    [KEYWORD_OBSERVE "observe"] => _Type.8
    [KEYWORD_CONST "const"] => _Type.9
    EPSILON => _Type.Start
        SHIFT [_Type.Start => _Type.10] 
    [SCOPE_DELIMITER "::"] => _Type.11
        CREATE TopQualifiedType
    [OPEN_BRACKET "("] => _Type.12

<_Type>: "void" as PredefinedType@ with { name = "Void" }
<_Type>: "object" as PredefinedType@ with { name = "Object" }
<_Type>: "interface" as PredefinedType@ with { name = "Interface" }
<_Type>: "int" as PredefinedType@ with { name = "Int" }
<_Type>: "uint" as PredefinedType@ with { name = "UInt" }
<_Type>: "float" as PredefinedType@ with { name = "Float" }
<_Type>: "double" as PredefinedType@ with { name = "Double" }
<_Type>: "string" as PredefinedType@ with { name = "String" }
<_Type>: "char" as PredefinedType@ with { name = "Char" }
<_Type>: "bool" as PredefinedType@ with { name = "Bool" }
<_Type>: NAME : name as ReferenceType@
<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType@
<_Type>: _Type : element "*" as RawPointerType@
<_Type>: _Type : element "^" as SharedPointerType@
<_Type>: _Type : element "?" as NullableType@
<_Type>: _Type : element "{" "}" as EnumerableType@
<_Type>: _Type : value "[" [ _Type : key ] "]" as MapType@ with { writability = "Writable" }
<_Type>: "observe" _Type : element "[" "]" as ObservableListType@
<_Type>: "const" _Type : value "[" [ _Type : key ] "]" as MapType@ with { writability = "Readonly" }
<_Type>: _Type : parent "::" NAME : name as ChildType@
<_Type>: "::" NAME : name as TopQualifiedType@
STATE _Type.1
    EPSILON => _Type.13

<_Type>: "func"@ "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.2
    [OPEN_BRACKET "("] => _Type.14

<_Type>: "observe"@ _Type : element "[" "]" as ObservableListType
STATE _Type.8
    EPSILON => _Type.Start
        SHIFT [_Type.8 => _Type.17] 

<_Type>: "const"@ _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.9
    EPSILON => _Type.Start
        SHIFT [_Type.9 => _Type.18] 

<_Type>: "::"@ NAME : name as TopQualifiedType
STATE _Type.11
    [NAME] => _Type.1
        ASSIGN name

<_Type>: "("@ !_Type ")"
STATE _Type.12
    EPSILON => _Type.Start
        SHIFT [_Type.12 => _Type.20] 

<_Type>: "void" as PredefinedType with { name = "Void" }@
<_Type>: "object" as PredefinedType with { name = "Object" }@
<_Type>: "interface" as PredefinedType with { name = "Interface" }@
<_Type>: "int" as PredefinedType with { name = "Int" }@
<_Type>: "uint" as PredefinedType with { name = "UInt" }@
<_Type>: "float" as PredefinedType with { name = "Float" }@
<_Type>: "double" as PredefinedType with { name = "Double" }@
<_Type>: "string" as PredefinedType with { name = "String" }@
<_Type>: "char" as PredefinedType with { name = "Char" }@
<_Type>: "bool" as PredefinedType with { name = "Bool" }@
<_Type>: NAME : name as ReferenceType@
<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType@
<_Type>: _Type : element "*" as RawPointerType@
<_Type>: _Type : element "^" as SharedPointerType@
<_Type>: _Type : element "?" as NullableType@
<_Type>: _Type : element "{" "}" as EnumerableType@
<_Type>: _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Writable" }@
<_Type>: "observe" _Type : element "[" "]" as ObservableListType@
<_Type>: "const" _Type : value "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }@
<_Type>: _Type : parent "::" NAME : name as ChildType@
<_Type>: "::" NAME : name as TopQualifiedType@
<_Type>: "(" !_Type ")"@
END STATE _Type.13
    NORMAL-REDUCE => _Type.3
        REDUCE [_Type.Start => _Type.3] 
        ASSIGN element
    NORMAL-REDUCE => _Type.4
        REDUCE [_Type.Start => _Type.4] 
        ASSIGN element
    NORMAL-REDUCE => _Type.5
        REDUCE [_Type.Start => _Type.5] 
        ASSIGN element
    NORMAL-REDUCE => _Type.6
        REDUCE [_Type.Start => _Type.6] 
        ASSIGN element
    NORMAL-REDUCE => _Type.7
        REDUCE [_Type.Start => _Type.7] 
        ASSIGN value
    NORMAL-REDUCE => _Type.10
        REDUCE [_Type.Start => _Type.10] 
        ASSIGN parent
    NORMAL-REDUCE => _Type.17
        REDUCE [_Type.8 => _Type.17] 
        ASSIGN element
    NORMAL-REDUCE => _Type.18
        REDUCE [_Type.9 => _Type.18] 
        ASSIGN value
    NORMAL-REDUCE => _Type.20
        REDUCE [_Type.12 => _Type.20] 
        USING 
    TOKEN-FINISH => _Type.RootEnd
    NORMAL-REDUCE => _Type.21
        REDUCE [_Type.14 => _Type.21] 
        ASSIGN arguments
    NORMAL-REDUCE => _Type.23
        REDUCE [_Type.16 => _Type.23] 
        ASSIGN key
        CREATE MapType
        SET writability => Writable
    NORMAL-REDUCE => _Type.23
        REDUCE [_Type.24 => _Type.23] 
        ASSIGN key
        CREATE MapType
        SET writability => Readonly
    NORMAL-REDUCE => _Type.1
        REDUCE [_Type.26 => _Type.1] 
        ASSIGN result
        CREATE FunctionType
    NORMAL-REDUCE => _Type.21
        REDUCE [_Type.25 => _Type.21] 
        ASSIGN arguments
    NORMAL-REDUCE => _VirtualExpression.8
        REDUCE [_VirtualExpression.4 => _VirtualExpression.8] 
        ASSIGN type
    NORMAL-REDUCE => _ExpPrimitive.28
        REDUCE [_ExpPrimitive.7 => _ExpPrimitive.28] 
        ASSIGN type
    NORMAL-REDUCE => _ExpPrimitive.29
        REDUCE [_ExpPrimitive.7 => _ExpPrimitive.29] 
        ASSIGN type
    NORMAL-REDUCE => _ExpPrimitive.1
        REDUCE [_ExpPrimitive.37 => _ExpPrimitive.1] 
        ASSIGN type
    NORMAL-REDUCE => _ExpPrimitive.1
        REDUCE [_ExpPrimitive.38 => _ExpPrimitive.1] 
        ASSIGN type
    NORMAL-REDUCE => _ExpPrimitive.1
        REDUCE [_ExpPrimitive.40 => _ExpPrimitive.1] 
        ASSIGN type
    NORMAL-REDUCE => _ExpPrimitive.63
        REDUCE [_ExpPrimitive.42 => _ExpPrimitive.63] 
        ASSIGN type
        CREATE TypeOfTypeExpression
    NORMAL-REDUCE => _Exp0.5
        REDUCE [_Exp0.3 => _Exp0.5] 
        ASSIGN type
        CREATE TypeCastingExpression
        SET strategy => Strong
    NORMAL-REDUCE => _If.9
        REDUCE [_If.7 => _If.9] 
        ASSIGN type
    NORMAL-REDUCE => _FunctionArgument.4
        REDUCE [_FunctionArgument.3 => _FunctionArgument.4] 
        ASSIGN type
    NORMAL-REDUCE => _Function.9
        REDUCE [_Function.8 => _Function.9] 
        ASSIGN returnType
    NORMAL-REDUCE => _Variable.5
        REDUCE [_Variable.3 => _Variable.5] 
        ASSIGN type
    NORMAL-REDUCE => _Event.4
        REDUCE [_Event.3 => _Event.4] 
        ASSIGN arguments
    NORMAL-REDUCE => _Event.4
        REDUCE [_Event.6 => _Event.4] 
        ASSIGN arguments
    NORMAL-REDUCE => _Property.4
        REDUCE [_Property.3 => _Property.4] 
        ASSIGN type
    NORMAL-REDUCE => _BaseConstructorCall.1
        REDUCE [_BaseConstructorCall.Start => _BaseConstructorCall.1] 
        ASSIGN type
    NORMAL-REDUCE => _ClassBody.3
        REDUCE [_ClassBody.1 => _ClassBody.3] 
        ASSIGN baseTypes
    NORMAL-REDUCE => _StructMember.4
        REDUCE [_StructMember.3 => _StructMember.4] 
        ASSIGN type
    NORMAL-REDUCE => _AutoProperty.4
        REDUCE [_AutoProperty.3 => _AutoProperty.4] 
        ASSIGN type
    NORMAL-REDUCE => _CastResultInterface.4
        REDUCE [_CastResultInterface.3 => _CastResultInterface.4] 
        ASSIGN baseType
    NORMAL-REDUCE => _CastResultInterface.6
        REDUCE [_CastResultInterface.5 => _CastResultInterface.6] 
        ASSIGN elementType

<_Type>: "func" "("@ [ _Type : arguments { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.14
    [CLOSE_BRACKET ")"] => _Type.22
    EPSILON => _Type.Start
        SHIFT [_Type.14 => _Type.21] 

<_Type>: _Type : element@ "*" as RawPointerType
STATE _Type.3
    [MUL "*"] => _Type.1
        CREATE RawPointerType

<_Type>: _Type : element@ "^" as SharedPointerType
STATE _Type.4
    [EXP "^"] => _Type.1
        CREATE SharedPointerType

<_Type>: _Type : element@ "?" as NullableType
STATE _Type.5
    [QUESTION_MARK "?"] => _Type.1
        CREATE NullableType

<_Type>: _Type : element@ "{" "}" as EnumerableType
STATE _Type.6
    [OPEN_BRACE "{"] => _Type.15

<_Type>: _Type : value@ "[" [ _Type : key ] "]" as MapType with { writability = "Writable" }
STATE _Type.7
    [OPEN_ARRAY "["] => _Type.16

<_Type>: _Type : parent@ "::" NAME : name as ChildType
STATE _Type.10
    [SCOPE_DELIMITER "::"] => _Type.19
        CREATE ChildType

<_Type>: "observe" _Type : element@ "[" "]" as ObservableListType
STATE _Type.17
    [OPEN_ARRAY "["] => _Type.23
        CREATE ObservableListType

<_Type>: "const" _Type : value@ "[" [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.18
    [OPEN_ARRAY "["] => _Type.24

<_Type>: "(" !_Type@ ")"
STATE _Type.20
    [CLOSE_BRACKET ")"] => _Type.13

$<_Type> @
STATE _Type.RootEnd

<_Type>: "func" "(" [ _Type : arguments@ { "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
<_Type>: "func" "(" [ _Type : arguments @{ "," _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.21
    [CLOSE_BRACKET ")"] => _Type.22
    [COMMA ","] => _Type.25

<_Type>: _Type : value "[" [ _Type : key ]@ "]" as MapType with { writability = "Writable" }
<_Type>: "observe" _Type : element "["@ "]" as ObservableListType
<_Type>: "const" _Type : value "[" [ _Type : key ]@ "]" as MapType with { writability = "Readonly" }
STATE _Type.23
    [CLOSE_ARRAY "]"] => _Type.1

<_VirtualExpression>: "new" _Type : type@ "(" "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.8
    [OPEN_BRACKET "("] => _VirtualExpression.11

<_ExpPrimitive>: "new" _Type : type@ "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.28
    [OPEN_BRACKET "("] => _ExpPrimitive.48

<_ExpPrimitive>: "new" _Type : type@ "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.29
    [OPEN_BRACE "{"] => _ExpPrimitive.49

<_ExpPrimitive>: "null" as LiteralExpression@ with { value = "Null" }
<_ExpPrimitive>: "true" as LiteralExpression@ with { value = "True" }
<_ExpPrimitive>: "false" as LiteralExpression@ with { value = "False" }
<_ExpPrimitive>: INTEGER : value as IntegerExpression@
<_ExpPrimitive>: FLOAT : value as FloatingExpression@
<_ExpPrimitive>: STRING : value as StringExpression@
<_ExpPrimitive>: "this" as ThisExpression@
<_ExpPrimitive>: NAME : name as ReferenceExpression@
<_ExpPrimitive>: ORDERED_NAME : name as OrderedNameExpression@
<_ExpPrimitive>: "[" _Expression : body "]" as OrderedLambdaExpression@
<_ExpPrimitive>: _Function : function as FunctionExpression@
<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression@
<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
<_ExpPrimitive>: "{" { _CtorFragment : arguments } "}" as ConstructorExpression@
<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression@
<_ExpPrimitive>: "new" _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression@
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression@ with { observeType = "SimpleObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression@ with { observeType = "ExtendedObserve" }
<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression@
<_ExpPrimitive>: _ExpPrimitive : parent "." NAME : name as MemberExpression@
<_ExpPrimitive>: _ExpPrimitive : parent "::" NAME : name as ChildExpression@
<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second "]" as BinaryExpression@ with { op = "Index" }
<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression@
<_ExpPrimitive>: _ExpPrimitive : expression "of" _Type : type as InferExpression@
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
<_ExpPrimitive>: _ExpPrimitive : expression "as" _Type : type as TypeCastingExpression@ with { strategy = "Weak" }
<_ExpPrimitive>: _ExpPrimitive : expression "as" "*" as ExpectedTypeCastExpression@ with { strategy = "Weak" }
<_ExpPrimitive>: "typeof" "(" _Type : type ")" as TypeOfTypeExpression@
<_ExpPrimitive>: "type" "(" _Expression : expression ")" as TypeOfExpressionExpression@
<_ExpPrimitive>: "attach" "(" _Expression : event "," _Expression : function ")" as AttachEventExpression@
<_ExpPrimitive>: "detach" "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression@
<_ExpPrimitive>: "::" NAME : name as TopQualifiedExpression@
STATE _ExpPrimitive.1
    EPSILON => _ExpPrimitive.23

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression@ ")" as LetExpression
<_ExpPrimitive>: "typeof" "(" _Type : type@ ")" as TypeOfTypeExpression
<_ExpPrimitive>: "type" "(" _Expression : expression@ ")" as TypeOfExpressionExpression
<_ExpPrimitive>: "attach" "(" _Expression : event "," _Expression : function@ ")" as AttachEventExpression
<_ExpPrimitive>: "detach" "(" _Expression : event "," _Expression : handler@ ")" as DetachEventExpression
STATE _ExpPrimitive.63
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1

<_Exp0>: "cast" _Type : type@ _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }
STATE _Exp0.5
    EPSILON => _Exp0.Start
        SHIFT [_Exp0.5 => _Exp0.4] 

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type@ "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.9
    [ASSIGN "="] => _If.12

<_FunctionArgument>: { _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument@
STATE _FunctionArgument.4
    EPSILON => _FunctionArgument.5
        CREATE FunctionArgument

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType@ ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.9
    [SEMICOLON ";"] => _Function.10
    EPSILON => _Block.Start
        SHIFT [_Function.9 => _Function.10] 
    EPSILON => _CoProvider.Start
        SHIFT [_Function.9 => _Function.10] 

<_Variable>: "var" NAME : name [ ":" _Type : type ]@ "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.5
    [ASSIGN "="] => _Variable.4

<_Event>: "event" NAME : name "(" [ _Type : arguments@ { "," _Type : arguments } ] ")" ";" as EventDeclaration
<_Event>: "event" NAME : name "(" [ _Type : arguments @{ "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.4
    [CLOSE_BRACKET ")"] => _Event.5
    [COMMA ","] => _Event.6

<_Property>: "prop" NAME : name ":" _Type : type@ "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.4
    [OPEN_BRACE "{"] => _Property.5

<_BaseConstructorCall>: _Type : type@ "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.1
    [OPEN_BRACKET "("] => _BaseConstructorCall.2

<_ClassBody>: [ ":" _Type : baseTypes@ { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
<_ClassBody>: [ ":" _Type : baseTypes @{ "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.3
    [COMMA ","] => _ClassBody.1
    [OPEN_BRACE "{"] => _ClassBody.2

<_StructMember>: { _Attribute : attributes } NAME : name ":" _Type : type@ ";" as StructMember
STATE _StructMember.4
    [SEMICOLON ";"] => _StructMember.5

<_AutoProperty>: "prop" NAME : name ":" _Type : type@ [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.4
    [ASSIGN "="] => _AutoProperty.5
    EPSILON => _APConfig.Start
        SHIFT [_AutoProperty.4 => _AutoProperty.6] 

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType@ "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.4
    [LT "<"] => _CastResultInterface.5

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType@ ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.6
    [GT ">"] => _CastResultInterface.7

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")"@ ":" _Type : result as FunctionType
STATE _Type.22
    [COLON ":"] => _Type.26

<_Type>: _Type : element "{"@ "}" as EnumerableType
STATE _Type.15
    [CLOSE_BRACE "}"] => _Type.1
        CREATE EnumerableType

<_Type>: _Type : value "["@ [ _Type : key ] "]" as MapType with { writability = "Writable" }
STATE _Type.16
    [CLOSE_ARRAY "]"] => _Type.1
        SET writability => Writable
        CREATE MapType
    EPSILON => _Type.Start
        SHIFT [_Type.16 => _Type.23] 

<_Type>: _Type : parent "::"@ NAME : name as ChildType
STATE _Type.19
    [NAME] => _Type.1
        ASSIGN name

<_Type>: "const" _Type : value "["@ [ _Type : key ] "]" as MapType with { writability = "Readonly" }
STATE _Type.24
    [CLOSE_ARRAY "]"] => _Type.1
        SET writability => Readonly
        CREATE MapType
    EPSILON => _Type.Start
        SHIFT [_Type.24 => _Type.23] 

<_Type>: "func" "(" [ _Type : arguments { ","@ _Type : arguments } ] ")" ":" _Type : result as FunctionType
STATE _Type.25
    EPSILON => _Type.Start
        SHIFT [_Type.25 => _Type.21] 

<_VirtualExpression>: "new" _Type : type "("@ "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.11
    [KEYWORD_USING "using"] => _VirtualExpression.13
        CREATE MixinCastExpression

<_ExpPrimitive>: "new" _Type : type "("@ [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.48
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        CREATE NewClassExpression
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.48 => _ExpPrimitive.57] 

<_ExpPrimitive>: "new" _Type : type "{"@ { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
<_ExpPrimitive>: "new" _Type : type "{" @{ _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.49
    [CLOSE_BRACE "}"] => _ExpPrimitive.1
        CREATE NewInterfaceExpression
    EPSILON => _MemberDeclaration.Start
        SHIFT [_ExpPrimitive.49 => _ExpPrimitive.49] 

<_ExpPrimitive>: "null" as LiteralExpression with { value = "Null" }@
<_ExpPrimitive>: "true" as LiteralExpression with { value = "True" }@
<_ExpPrimitive>: "false" as LiteralExpression with { value = "False" }@
<_ExpPrimitive>: INTEGER : value as IntegerExpression@
<_ExpPrimitive>: FLOAT : value as FloatingExpression@
<_ExpPrimitive>: STRING : value as StringExpression@
<_ExpPrimitive>: "this" as ThisExpression@
<_ExpPrimitive>: NAME : name as ReferenceExpression@
<_ExpPrimitive>: ORDERED_NAME : name as OrderedNameExpression@
<_ExpPrimitive>: "(" !_Expression ")"@
<_ExpPrimitive>: "[" _Expression : body "]" as OrderedLambdaExpression@
<_ExpPrimitive>: _Function : function as FunctionExpression@
<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression@
<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression@
<_ExpPrimitive>: "{" { _CtorFragment : arguments } "}" as ConstructorExpression@
<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression@
<_ExpPrimitive>: "new" _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression@
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }@
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }@
<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression@
<_ExpPrimitive>: _ExpPrimitive : parent "." NAME : name as MemberExpression@
<_ExpPrimitive>: _ExpPrimitive : parent "::" NAME : name as ChildExpression@
<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second "]" as BinaryExpression with { op = "Index" }@
<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression@
<_ExpPrimitive>: _ExpPrimitive : expression "of" _Type : type as InferExpression@
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )@
<_ExpPrimitive>: _ExpPrimitive : expression "as" _Type : type as TypeCastingExpression with { strategy = "Weak" }@
<_ExpPrimitive>: _ExpPrimitive : expression "as" "*" as ExpectedTypeCastExpression with { strategy = "Weak" }@
<_ExpPrimitive>: "typeof" "(" _Type : type ")" as TypeOfTypeExpression@
<_ExpPrimitive>: "type" "(" _Expression : expression ")" as TypeOfExpressionExpression@
<_ExpPrimitive>: "attach" "(" _Expression : event "," _Expression : function ")" as AttachEventExpression@
<_ExpPrimitive>: "detach" "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression@
<_ExpPrimitive>: "::" NAME : name as TopQualifiedExpression@
<_ExpPrimitive>: !_VirtualExpression@
END STATE _ExpPrimitive.23
    NORMAL-REDUCE => _ExpPrimitive.8
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.8] 
        ASSIGN parent
    NORMAL-REDUCE => _ExpPrimitive.9
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.9] 
        ASSIGN function
    NORMAL-REDUCE => _ExpPrimitive.10
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.10] 
        ASSIGN parent
    NORMAL-REDUCE => _ExpPrimitive.11
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.11] 
        ASSIGN parent
    NORMAL-REDUCE => _ExpPrimitive.12
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.12] 
        ASSIGN first
    NORMAL-REDUCE => _ExpPrimitive.13
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.13] 
        ASSIGN element
    NORMAL-REDUCE => _ExpPrimitive.14
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.14] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.15
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.15] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.16
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.16] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.17
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.17] 
        ASSIGN expression
    TOKEN-FINISH => _ExpPrimitive.RootEnd
    NORMAL-REDUCE => _Exp0.1
        REDUCE [_Exp0.Start => _Exp0.1] 
        USING 

@ <_Exp0>
STATE _Exp0.Start
    EPSILON => _ExpPrimitive.Start
        SHIFT [_Exp0.Start => _Exp0.1] 
    [ADD "+"] => _Exp0.2
        CREATE UnaryExpression
        SET op => Positive
    [SUB "-"] => _Exp0.2
        CREATE UnaryExpression
        SET op => Negative
    [KEYWORD_NOT "not"] => _Exp0.2
        CREATE UnaryExpression
        SET op => Not
    [KEYWORD_CAST "cast"] => _Exp0.3

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ]@ _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.12
    EPSILON => _Expression.Start
        SHIFT [_If.12 => _If.4] 

<_FunctionArgument>: { _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument@
END STATE _FunctionArgument.5
    TOKEN-FINISH => _FunctionArgument.RootEnd
    NORMAL-REDUCE => _Function.5
        REDUCE [_Function.3 => _Function.5] 
        ASSIGN arguments
        SET anonymity => Anonymous
    NORMAL-REDUCE => _Function.5
        REDUCE [_Function.4 => _Function.5] 
        ASSIGN arguments
        SET anonymity => Named
    NORMAL-REDUCE => _Function.5
        REDUCE [_Function.7 => _Function.5] 
        ASSIGN arguments
    NORMAL-REDUCE => _Constructor.4
        REDUCE [_Constructor.3 => _Constructor.4] 
        ASSIGN arguments
    NORMAL-REDUCE => _Constructor.4
        REDUCE [_Constructor.6 => _Constructor.4] 
        ASSIGN arguments

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration@
STATE _Function.10
    EPSILON => _Function.11
        CREATE FunctionDeclaration

@ <_Block>
STATE _Block.Start
    [OPEN_BRACE "{"] => _Block.1

@ <_CoProvider>
STATE _CoProvider.Start
    [COROUTINE_SIGN "$"] => _CoProvider.1
    [COROUTINE_OPERATOR] => _CoProvider.1
        ASSIGN name

<_Variable>: "var" NAME : name [ ":" _Type : type ] "="@ _Expression : expression ";" as VariableDeclaration
STATE _Variable.4
    EPSILON => _Expression.Start
        SHIFT [_Variable.4 => _Variable.6] 

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")"@ ";" as EventDeclaration
STATE _Event.5
    [SEMICOLON ";"] => _Event.7

<_Event>: "event" NAME : name "(" [ _Type : arguments { ","@ _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.6
    EPSILON => _Type.Start
        SHIFT [_Event.6 => _Event.4] 

<_Property>: "prop" NAME : name ":" _Type : type "{"@ NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.5
    [NAME] => _Property.6
        ASSIGN getter

<_BaseConstructorCall>: _Type : type "("@ [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.2
    [CLOSE_BRACKET ")"] => _BaseConstructorCall.4
    EPSILON => _Expression.Start
        SHIFT [_BaseConstructorCall.2 => _BaseConstructorCall.3] 

<_ClassBody>: [ ":"@ _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
<_ClassBody>: [ ":" _Type : baseTypes { ","@ _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.1
    EPSILON => _Type.Start
        SHIFT [_ClassBody.1 => _ClassBody.3] 

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{"@ { _MemberDeclaration : declarations } "}" as ClassDeclaration
<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" @{ _MemberDeclaration : declarations } "}" as ClassDeclaration
STATE _ClassBody.2
    [CLOSE_BRACE "}"] => _ClassBody.4
    EPSILON => _MemberDeclaration.Start
        SHIFT [_ClassBody.2 => _ClassBody.2] 

<_StructMember>: { _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember@
STATE _StructMember.5
    EPSILON => _StructMember.6
        CREATE StructMember

<_AutoProperty>: "prop" NAME : name ":" _Type : type [ "="@ _Expression : expression ] !_APConfig
STATE _AutoProperty.5
    EPSILON => _Expression.Start
        SHIFT [_AutoProperty.5 => _AutoProperty.7] 

@ <_APConfig>
STATE _APConfig.Start
    [OPEN_BRACE "{"] => _APConfig.1
        CREATE AutoPropertyDeclaration
        SET configConst => Writable
        SET configObserve => Observable
    [OPEN_BRACE "{"] => _APConfig.2

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<"@ _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.5
    EPSILON => _Type.Start
        SHIFT [_CastResultInterface.5 => _CastResultInterface.6] 

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">"@ ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.7
    [SEMICOLON ";"] => _CastResultInterface.8

<_Type>: "func" "(" [ _Type : arguments { "," _Type : arguments } ] ")" ":"@ _Type : result as FunctionType
STATE _Type.26
    EPSILON => _Type.Start
        SHIFT [_Type.26 => _Type.1] 

<_VirtualExpression>: "new" _Type : type "(" "using"@ _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.13
    EPSILON => _Expression.Start
        SHIFT [_VirtualExpression.13 => _VirtualExpression.9] 

@ <_Expression>
STATE _Expression.Start
    EPSILON => _Exp11.Start
        SHIFT [_Expression.Start => _Expression.1] 

@ <_MemberDeclaration>
STATE _MemberDeclaration.Start
    EPSILON => _SharedDeclarationBranch.Start
        SHIFT [_MemberDeclaration.Start => _MemberDeclaration.1] 
    EPSILON => _Attribute.Start
        SHIFT [_MemberDeclaration.Start => _MemberDeclaration.2] 
    EPSILON => _ClassMember.Start
        SHIFT [_MemberDeclaration.Start => _MemberDeclaration.3] 
    EPSILON => _MemberDeclarationBranch.Start
        SHIFT [_MemberDeclaration.Start => _MemberDeclaration.1] 
    EPSILON => _Attribute.Start
        SHIFT [_MemberDeclaration.Start => _MemberDeclaration.4] 

<_ExpPrimitive>: _ExpPrimitive : parent@ "." "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent@ "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.8
    [DOT "."] => _ExpPrimitive.30

<_ExpPrimitive>: _ExpPrimitive : function@ "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.9
    [OPEN_BRACKET "("] => _ExpPrimitive.31

<_ExpPrimitive>: _ExpPrimitive : parent@ "." NAME : name as MemberExpression
STATE _ExpPrimitive.10
    [DOT "."] => _ExpPrimitive.32
        CREATE MemberExpression

<_ExpPrimitive>: _ExpPrimitive : parent@ "::" NAME : name as ChildExpression
STATE _ExpPrimitive.11
    [SCOPE_DELIMITER "::"] => _ExpPrimitive.33
        CREATE ChildExpression

<_ExpPrimitive>: _ExpPrimitive : first@ "[" _Expression : second "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.12
    [OPEN_ARRAY "["] => _ExpPrimitive.34
        SET op => Index
        CREATE BinaryExpression

<_ExpPrimitive>: _ExpPrimitive : element@ ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.13
    [KEYWORD_IN "in"] => _ExpPrimitive.35
        CREATE SetTestingExpression
        SET test => In
    [KEYWORD_NOT "not"] => _ExpPrimitive.36

<_ExpPrimitive>: _ExpPrimitive : expression@ "of" _Type : type as InferExpression
STATE _ExpPrimitive.14
    [KEYWORD_OF "of"] => _ExpPrimitive.37
        CREATE InferExpression

<_ExpPrimitive>: _ExpPrimitive : expression@ ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.15
    [KEYWORD_IS "is"] => _ExpPrimitive.38
        CREATE TypeTestingExpression
        SET test => IsType
    [KEYWORD_IS "is"] => _ExpPrimitive.39

<_ExpPrimitive>: _ExpPrimitive : expression@ "as" _Type : type as TypeCastingExpression with { strategy = "Weak" }
STATE _ExpPrimitive.16
    [KEYWORD_AS "as"] => _ExpPrimitive.40
        CREATE TypeCastingExpression
        SET strategy => Weak

<_ExpPrimitive>: _ExpPrimitive : expression@ "as" "*" as ExpectedTypeCastExpression with { strategy = "Weak" }
STATE _ExpPrimitive.17
    [KEYWORD_AS "as"] => _ExpPrimitive.41

$<_ExpPrimitive> @
STATE _ExpPrimitive.RootEnd

<_Exp0>: !_ExpPrimitive@
<_Exp0>: "+" _Exp0 : operand as UnaryExpression with { op = "Positive" }@
<_Exp0>: "-" _Exp0 : operand as UnaryExpression with { op = "Negative" }@
<_Exp0>: "not" _Exp0 : operand as UnaryExpression with { op = "Not" }@
<_Exp0>: "cast" _Type : type _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }@
<_Exp0>: "cast" "*" _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }@
END STATE _Exp0.1
    TOKEN-FINISH => _Exp0.RootEnd
    NORMAL-REDUCE => _Exp0.4
        REDUCE [_Exp0.2 => _Exp0.4] 
        ASSIGN operand
    NORMAL-REDUCE => _Exp0.4
        REDUCE [_Exp0.5 => _Exp0.4] 
        ASSIGN expression
    NORMAL-REDUCE => _Exp0.4
        REDUCE [_Exp0.6 => _Exp0.4] 
        ASSIGN expression
    NORMAL-REDUCE => _Exp1.1
        REDUCE [_Exp1.Start => _Exp1.1] 
        USING 
    NORMAL-REDUCE => _Exp1.4
        REDUCE [_Exp1.3 => _Exp1.4] 
        ASSIGN second

@ <_ExpPrimitive>
STATE _ExpPrimitive.Start
    [KEYWORD_NULL "null"] => _ExpPrimitive.1
        SET value => Null
        CREATE LiteralExpression
    [KEYWORD_TRUE "true"] => _ExpPrimitive.1
        SET value => True
        CREATE LiteralExpression
    [KEYWORD_FALSE "false"] => _ExpPrimitive.1
        SET value => False
        CREATE LiteralExpression
    [INTEGER] => _ExpPrimitive.1
        ASSIGN value
        CREATE IntegerExpression
    [FLOAT] => _ExpPrimitive.1
        ASSIGN value
        CREATE FloatingExpression
    [STRING] => _ExpPrimitive.1
        ASSIGN value
        CREATE StringExpression
    [KEYWORD_THIS "this"] => _ExpPrimitive.1
        CREATE ThisExpression
    [NAME] => _ExpPrimitive.1
        ASSIGN name
        CREATE ReferenceExpression
    [ORDERED_NAME] => _ExpPrimitive.1
        ASSIGN name
        CREATE OrderedNameExpression
    [OPEN_BRACKET "("] => _ExpPrimitive.2
    [OPEN_ARRAY "["] => _ExpPrimitive.3
        CREATE OrderedLambdaExpression
    EPSILON => _Function.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.1] 
    [KEYWORD_LET "let"] => _ExpPrimitive.4
    [KEYWORD_RANGE "range"] => _ExpPrimitive.5
    [OPEN_BRACE "{"] => _ExpPrimitive.6
    [KEYWORD_NEW "new"] => _ExpPrimitive.7
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.8] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.9] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.10] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.11] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.12] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.13] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.14] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.15] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.16] 
    EPSILON => _ExpPrimitive.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.17] 
    [KEYWORD_TYPEOF "typeof"] => _ExpPrimitive.18
    [KEYWORD_TYPE "type"] => _ExpPrimitive.19
    [KEYWORD_ATTACH "attach"] => _ExpPrimitive.20
    [KEYWORD_DETACH "detach"] => _ExpPrimitive.21
    [SCOPE_DELIMITER "::"] => _ExpPrimitive.22
        CREATE TopQualifiedExpression
    EPSILON => _VirtualExpression.Start
        SHIFT [_ExpPrimitive.Start => _ExpPrimitive.23] 

<_Exp0>: "+"@ _Exp0 : operand as UnaryExpression with { op = "Positive" }
<_Exp0>: "-"@ _Exp0 : operand as UnaryExpression with { op = "Negative" }
<_Exp0>: "not"@ _Exp0 : operand as UnaryExpression with { op = "Not" }
STATE _Exp0.2
    EPSILON => _Exp0.Start
        SHIFT [_Exp0.2 => _Exp0.4] 

<_Exp0>: "cast"@ _Type : type _Exp0 : expression as TypeCastingExpression with { strategy = "Strong" }
<_Exp0>: "cast"@ "*" _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }
STATE _Exp0.3
    EPSILON => _Type.Start
        SHIFT [_Exp0.3 => _Exp0.5] 
    [MUL "*"] => _Exp0.6
        CREATE ExpectedTypeCastExpression
        SET strategy => Strong

$<_FunctionArgument> @
STATE _FunctionArgument.RootEnd

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments@ { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments @{ "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.5
    [CLOSE_BRACKET ")"] => _Function.6
    [COMMA ","] => _Function.7

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments@ { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments @{ "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.4
    [CLOSE_BRACKET ")"] => _Constructor.5
    [COMMA ","] => _Constructor.6

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration@
END STATE _Function.11
    NORMAL-REDUCE => _ExpPrimitive.1
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.1] 
        ASSIGN function
        CREATE FunctionExpression
    TOKEN-FINISH => _Function.RootEnd
    NORMAL-REDUCE => _MemberDeclarationBranch.1
        REDUCE [_MemberDeclarationBranch.Start => _MemberDeclarationBranch.1] 
        USING 

<_Block>: "{"@ { _Statement : statements } "}" as BlockStatement
<_Block>: "{" @{ _Statement : statements } "}" as BlockStatement
STATE _Block.1
    [CLOSE_BRACE "}"] => _Block.2
    EPSILON => _Statement.Start
        SHIFT [_Block.1 => _Block.1] 

<_CoProvider>: ( "$" | COROUTINE_OPERATOR : name )@ _Block : statement as CoProviderStatement
STATE _CoProvider.1
    EPSILON => _Block.Start
        SHIFT [_CoProvider.1 => _CoProvider.2] 

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration@
STATE _Event.7
    EPSILON => _Event.8
        CREATE EventDeclaration

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter@ [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.6
    [CLOSE_BRACE "}"] => _Property.9
    [COLON ":"] => _Property.8
    [COMMA ","] => _Property.7

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall@
STATE _BaseConstructorCall.4
    EPSILON => _BaseConstructorCall.6
        CREATE BaseConstructorCall

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration@
STATE _ClassBody.4
    EPSILON => _ClassBody.5
        CREATE ClassDeclaration

<_StructMember>: { _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember@
END STATE _StructMember.6
    TOKEN-FINISH => _StructMember.RootEnd
    NORMAL-REDUCE => _Struct.3
        REDUCE [_Struct.3 => _Struct.3] 
        ASSIGN members

<_APConfig>: "{"@ "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "Observable" }
<_APConfig>: "{" "const"@ "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }
<_APConfig>: "{" "not" "observe"@ "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
<_APConfig>: "{" "const" "," "not" "observe"@ "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.1
    [CLOSE_BRACE "}"] => _APConfig.3

<_APConfig>: "{"@ "const" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }
<_APConfig>: "{"@ "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
<_APConfig>: "{"@ "const" "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.2
    [KEYWORD_CONST "const"] => _APConfig.1
        CREATE AutoPropertyDeclaration
        SET configConst => Readonly
        SET configObserve => Observable
    [KEYWORD_NOT "not"] => _APConfig.4
        SET configObserve => NotObservable
        SET configConst => Writable
        CREATE AutoPropertyDeclaration
    [KEYWORD_CONST "const"] => _APConfig.5

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration@
STATE _CastResultInterface.8
    EPSILON => _CastResultInterface.9
        CREATE CastResultInterfaceDeclaration

@ <_Exp11>
STATE _Exp11.Start
    EPSILON => _Exp10.Start
        SHIFT [_Exp11.Start => _Exp11.1] 
    EPSILON => _Exp10.Start
        SHIFT [_Exp11.Start => _Exp11.2] 

@ <_SharedDeclarationBranch>
STATE _SharedDeclarationBranch.Start
    EPSILON => _Namespace.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Variable.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Event.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Property.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Constructor.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Destructor.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Class.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Enum.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _Struct.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
    EPSILON => _CastResultInterface.Start
        SHIFT [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 

@ <_Attribute>
STATE _Attribute.Start
    [AT "@"] => _Attribute.1

@ <_ClassMember>
STATE _ClassMember.Start
    [KEYWORD_STATIC "static"] => _ClassMember.1
        SET kind => Static
        CREATE ClassMember
    [KEYWORD_OVERRIDE "override"] => _ClassMember.1
        SET kind => Override
        CREATE ClassMember

@ <_MemberDeclarationBranch>
STATE _MemberDeclarationBranch.Start
    EPSILON => _Function.Start
        SHIFT [_MemberDeclarationBranch.Start => _MemberDeclarationBranch.1] 
    EPSILON => _AutoProperty.Start
        SHIFT [_MemberDeclarationBranch.Start => _MemberDeclarationBranch.1] 

<_ExpPrimitive>: _ExpPrimitive : parent "."@ "observe" "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "."@ "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.30
    [KEYWORD_OBSERVE "observe"] => _ExpPrimitive.50

<_ExpPrimitive>: _ExpPrimitive : function "("@ [ _Expression : arguments { "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.31
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        CREATE CallExpression
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.31 => _ExpPrimitive.51] 

<_ExpPrimitive>: _ExpPrimitive : parent "."@ NAME : name as MemberExpression
STATE _ExpPrimitive.32
    [NAME] => _ExpPrimitive.1
        ASSIGN name

<_ExpPrimitive>: _ExpPrimitive : parent "::"@ NAME : name as ChildExpression
STATE _ExpPrimitive.33
    [NAME] => _ExpPrimitive.1
        ASSIGN name

<_ExpPrimitive>: _ExpPrimitive : first "["@ _Expression : second "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.34
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.34 => _ExpPrimitive.25] 

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) )@ _Expression : collection as SetTestingExpression
<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not" "in" with { test = "NotIn" } ) )@ _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.35
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.35 => _ExpPrimitive.1] 

<_ExpPrimitive>: _ExpPrimitive : element ( ( "in" with { test = "In" } ) | ( "not"@ "in" with { test = "NotIn" } ) ) _Expression : collection as SetTestingExpression
STATE _ExpPrimitive.36
    [KEYWORD_IN "in"] => _ExpPrimitive.35
        CREATE SetTestingExpression
        SET test => NotIn

<_ExpPrimitive>: _ExpPrimitive : expression "of"@ _Type : type as InferExpression
STATE _ExpPrimitive.37
    EPSILON => _Type.Start
        SHIFT [_ExpPrimitive.37 => _ExpPrimitive.1] 

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) )@ _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) )@ _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.38
    EPSILON => _Type.Start
        SHIFT [_ExpPrimitive.38 => _ExpPrimitive.1] 

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is"@ "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is"@ "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is"@ "not" "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.39
    [KEYWORD_NOT "not"] => _ExpPrimitive.38
        CREATE TypeTestingExpression
        SET test => IsNotType
    [KEYWORD_NULL "null"] => _ExpPrimitive.1
        SET test => IsNull
        CREATE TypeTestingExpression
    [KEYWORD_NOT "not"] => _ExpPrimitive.52

<_ExpPrimitive>: _ExpPrimitive : expression "as"@ _Type : type as TypeCastingExpression with { strategy = "Weak" }
STATE _ExpPrimitive.40
    EPSILON => _Type.Start
        SHIFT [_ExpPrimitive.40 => _ExpPrimitive.1] 

<_ExpPrimitive>: _ExpPrimitive : expression "as"@ "*" as ExpectedTypeCastExpression with { strategy = "Weak" }
STATE _ExpPrimitive.41
    [MUL "*"] => _ExpPrimitive.1
        SET strategy => Weak
        CREATE ExpectedTypeCastExpression

$<_Exp0> @
STATE _Exp0.RootEnd

<_Exp0>: "+" _Exp0 : operand as UnaryExpression@ with { op = "Positive" }
<_Exp0>: "-" _Exp0 : operand as UnaryExpression@ with { op = "Negative" }
<_Exp0>: "not" _Exp0 : operand as UnaryExpression@ with { op = "Not" }
<_Exp0>: "cast" _Type : type _Exp0 : expression as TypeCastingExpression@ with { strategy = "Strong" }
<_Exp0>: "cast" "*" _Exp0 : expression as ExpectedTypeCastExpression@ with { strategy = "Strong" }
STATE _Exp0.4
    EPSILON => _Exp0.1

<_Exp1>: !_Exp0@
<_Exp1>: _Exp1 : first "^" _Exp0 : second as BinaryExpression with { op = "Exp" }@
END STATE _Exp1.1
    NORMAL-REDUCE => _Exp1.2
        REDUCE [_Exp1.Start => _Exp1.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp1.RootEnd
    NORMAL-REDUCE => _Exp2.1
        REDUCE [_Exp2.Start => _Exp2.1] 
        USING 
    NORMAL-REDUCE => _Exp2.4
        REDUCE [_Exp2.3 => _Exp2.4] 
        ASSIGN second

<_Exp1>: _Exp1 : first "^" _Exp0 : second as BinaryExpression@ with { op = "Exp" }
STATE _Exp1.4
    EPSILON => _Exp1.1
        CREATE BinaryExpression
        SET op => Exp

<_ExpPrimitive>: "("@ !_Expression ")"
STATE _ExpPrimitive.2
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.2 => _ExpPrimitive.24] 

<_ExpPrimitive>: "["@ _Expression : body "]" as OrderedLambdaExpression
STATE _ExpPrimitive.3
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.3 => _ExpPrimitive.25] 

@ <_Function>
STATE _Function.Start
    [KEYWORD_FUNC "func"] => _Function.1

<_ExpPrimitive>: "let"@ _LetVariable : variables { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
<_ExpPrimitive>: "let" _LetVariable : variables { ","@ _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.4
    EPSILON => _LetVariable.Start
        SHIFT [_ExpPrimitive.4 => _ExpPrimitive.26] 

<_ExpPrimitive>: "range"@ ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.5
    [OPEN_ARRAY "["] => _ExpPrimitive.27
        SET beginBoundary => Inclusive
    [OPEN_BRACKET "("] => _ExpPrimitive.27
        SET beginBoundary => Exclusive

<_ExpPrimitive>: "{"@ { _CtorFragment : arguments } "}" as ConstructorExpression
<_ExpPrimitive>: "{" @{ _CtorFragment : arguments } "}" as ConstructorExpression
STATE _ExpPrimitive.6
    [CLOSE_BRACE "}"] => _ExpPrimitive.1
        CREATE ConstructorExpression
    EPSILON => _CtorFragment.Start
        SHIFT [_ExpPrimitive.6 => _ExpPrimitive.6] 

<_ExpPrimitive>: "new"@ _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as NewClassExpression
<_ExpPrimitive>: "new"@ _Type : type "{" { _MemberDeclaration : declarations } "}" as NewInterfaceExpression
STATE _ExpPrimitive.7
    EPSILON => _Type.Start
        SHIFT [_ExpPrimitive.7 => _ExpPrimitive.28] 
    EPSILON => _Type.Start
        SHIFT [_ExpPrimitive.7 => _ExpPrimitive.29] 

<_ExpPrimitive>: "typeof"@ "(" _Type : type ")" as TypeOfTypeExpression
STATE _ExpPrimitive.18
    [OPEN_BRACKET "("] => _ExpPrimitive.42

<_ExpPrimitive>: "type"@ "(" _Expression : expression ")" as TypeOfExpressionExpression
STATE _ExpPrimitive.19
    [OPEN_BRACKET "("] => _ExpPrimitive.43
        CREATE TypeOfExpressionExpression

<_ExpPrimitive>: "attach"@ "(" _Expression : event "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.20
    [OPEN_BRACKET "("] => _ExpPrimitive.44

<_ExpPrimitive>: "detach"@ "(" _Expression : event "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.21
    [OPEN_BRACKET "("] => _ExpPrimitive.45

<_ExpPrimitive>: "::"@ NAME : name as TopQualifiedExpression
STATE _ExpPrimitive.22
    [NAME] => _ExpPrimitive.1
        ASSIGN name

@ <_VirtualExpression>
STATE _VirtualExpression.Start
    [FORMATSTRING] => _VirtualExpression.1
        ASSIGN value
        CREATE FormatExpression
    [KEYWORD_BIND "bind"] => _VirtualExpression.2
    [COROUTINE_COROUTINE "$coroutine"] => _VirtualExpression.3
    [KEYWORD_NEW "new"] => _VirtualExpression.4

<_Exp0>: "cast" "*"@ _Exp0 : expression as ExpectedTypeCastExpression with { strategy = "Strong" }
STATE _Exp0.6
    EPSILON => _Exp0.Start
        SHIFT [_Exp0.6 => _Exp0.4] 

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")"@ ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.6
    [COLON ":"] => _Function.8

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { ","@ _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.7
    EPSILON => _FunctionArgument.Start
        SHIFT [_Function.7 => _Function.5] 

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")"@ [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.5
    [COLON ":"] => _Constructor.7
    EPSILON => _Block.Start
        SHIFT [_Constructor.5 => _Constructor.8] 

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { ","@ _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.6
    EPSILON => _FunctionArgument.Start
        SHIFT [_Constructor.6 => _Constructor.4] 

$<_Function> @
STATE _Function.RootEnd

<_MemberDeclarationBranch>: !_Function@
<_MemberDeclarationBranch>: !_AutoProperty@
END STATE _MemberDeclarationBranch.1
    TOKEN-FINISH => _MemberDeclarationBranch.RootEnd
    NORMAL-REDUCE => _Declaration.1
        REDUCE [_Declaration.Start => _Declaration.1] 
        USING 
    NORMAL-REDUCE => _Declaration.1
        REDUCE [_Declaration.3 => _Declaration.1] 
        USING 
    NORMAL-REDUCE => _MemberDeclaration.1
        REDUCE [_MemberDeclaration.Start => _MemberDeclaration.1] 
        USING 
    NORMAL-REDUCE => _MemberDeclaration.1
        REDUCE [_MemberDeclaration.3 => _MemberDeclaration.1] 
        USING 
    NORMAL-REDUCE => _MemberDeclaration.1
        REDUCE [_MemberDeclaration.4 => _MemberDeclaration.1] 
        USING 

<_Block>: "{" { _Statement : statements } "}" as BlockStatement@
STATE _Block.2
    EPSILON => _Block.3
        CREATE BlockStatement

@ <_Statement>
STATE _Statement.Start
    EPSILON => _Block.Start
        SHIFT [_Statement.Start => _Statement.1] 
    EPSILON => _Variable.Start
        SHIFT [_Statement.Start => _Statement.2] 
    [KEYWORD_BREAK "break"] => _Statement.3
        CREATE BreakStatement
    [KEYWORD_CONTINUE "continue"] => _Statement.3
        CREATE ContinueStatement
    [KEYWORD_RETURN "return"] => _Statement.4
    [KEYWORD_DELETE "delete"] => _Statement.5
    [KEYWORD_RAISE "raise"] => _Statement.6
    EPSILON => _If.Start
        SHIFT [_Statement.Start => _Statement.1] 
    [KEYWORD_WHILE "while"] => _Statement.7
    [KEYWORD_TRY "try"] => _Statement.8
    EPSILON => _Expression.Start
        SHIFT [_Statement.Start => _Statement.3] 
    EPSILON => _VirtualStatement.Start
        SHIFT [_Statement.Start => _Statement.1] 
    EPSILON => _CoStatement.Start
        SHIFT [_Statement.Start => _Statement.1] 

<_Event>: "event" NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration@
END STATE _Event.8
    TOKEN-FINISH => _Event.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration@
STATE _Property.9
    EPSILON => _Property.12
        CREATE PropertyDeclaration

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":"@ NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.8
    [NAME] => _Property.11
        ASSIGN valueChangedEvent

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ ","@ NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.7
    [NAME] => _Property.10
        ASSIGN setter

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { "," _Expression : arguments } ] ")" as BaseConstructorCall@
END STATE _BaseConstructorCall.6
    TOKEN-FINISH => _BaseConstructorCall.RootEnd
    NORMAL-REDUCE => _Constructor.9
        REDUCE [_Constructor.7 => _Constructor.9] 
        ASSIGN baseConstructorCalls

<_ClassBody>: [ ":" _Type : baseTypes { "," _Type : baseTypes } ] "{" { _MemberDeclaration : declarations } "}" as ClassDeclaration@
END STATE _ClassBody.5
    TOKEN-FINISH => _ClassBody.RootEnd
    NORMAL-REDUCE => _Class.5
        REDUCE [_Class.3 => _Class.5] 
        USING 

$<_StructMember> @
STATE _StructMember.RootEnd

<_Struct>: "struct" NAME : name "{"@ { _StructMember : members } "}" as StructDeclaration
<_Struct>: "struct" NAME : name "{" @{ _StructMember : members } "}" as StructDeclaration
STATE _Struct.3
    [CLOSE_BRACE "}"] => _Struct.4
    EPSILON => _StructMember.Start
        SHIFT [_Struct.3 => _Struct.3] 

<_APConfig>: "{" "}" as AutoPropertyDeclaration@ with { configConst = "Writable" } with { configObserve = "Observable" }
<_APConfig>: "{" "const" "}" as AutoPropertyDeclaration@ with { configConst = "Readonly" } with { configObserve = "Observable" }
<_APConfig>: "{" "not" "observe" "}" as AutoPropertyDeclaration@ with { configConst = "Writable" } with { configObserve = "NotObservable" }
<_APConfig>: "{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration@ with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.3
    EPSILON => _APConfig.6

<_APConfig>: "{" "not"@ "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }
<_APConfig>: "{" "const" "," "not"@ "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.4
    [KEYWORD_OBSERVE "observe"] => _APConfig.1

<_APConfig>: "{" "const"@ "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.5
    [COMMA ","] => _APConfig.7

<_CastResultInterface>: "$interface" NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration@
END STATE _CastResultInterface.9
    TOKEN-FINISH => _CastResultInterface.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

@ <_Exp10>
STATE _Exp10.Start
    EPSILON => _Exp9.Start
        SHIFT [_Exp10.Start => _Exp10.1] 
    EPSILON => _Exp9.Start
        SHIFT [_Exp10.Start => _Exp10.2] 

@ <_Namespace>
STATE _Namespace.Start
    [KEYWORD_NAMESPACE "namespace"] => _Namespace.1

@ <_Variable>
STATE _Variable.Start
    [KEYWORD_VAR "var"] => _Variable.1

@ <_Event>
STATE _Event.Start
    [KEYWORD_EVENT "event"] => _Event.1

@ <_Property>
STATE _Property.Start
    [KEYWORD_PROP "prop"] => _Property.1

@ <_Constructor>
STATE _Constructor.Start
    [KEYWORD_NEW "new"] => _Constructor.1
        SET constructorType => SharedPtr
    [KEYWORD_NEW "new"] => _Constructor.2

@ <_Destructor>
STATE _Destructor.Start
    [KEYWORD_DELETE "delete"] => _Destructor.1

@ <_Class>
STATE _Class.Start
    [KEYWORD_CLASS "class"] => _Class.1
        SET kind => Class
        SET constructorType => Undefined
    [TYPE_INTERFACE "interface"] => _Class.1
        SET kind => Interface
        SET constructorType => SharedPtr
    [TYPE_INTERFACE "interface"] => _Class.2

@ <_Enum>
STATE _Enum.Start
    [KEYWORD_ENUM "enum"] => _Enum.1
    [KEYWORD_FLAGENUM "flagenum"] => _Enum.2

@ <_Struct>
STATE _Struct.Start
    [KEYWORD_STRUCT "struct"] => _Struct.1

@ <_CastResultInterface>
STATE _CastResultInterface.Start
    [COROUTINE_INTERFACE "$interface"] => _CastResultInterface.1

<_Attribute>: "@"@ NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.1
    [NAME] => _Attribute.2
        ASSIGN category

<_ClassMember>: "static" as ClassMember@ with { kind = "Static" }
<_ClassMember>: "override" as ClassMember@ with { kind = "Override" }
STATE _ClassMember.1
    EPSILON => _ClassMember.2

@ <_AutoProperty>
STATE _AutoProperty.Start
    [KEYWORD_PROP "prop"] => _AutoProperty.1

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe"@ "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe"@ "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.50
    [OPEN_BRACKET "("] => _ExpPrimitive.58
    [KEYWORD_AS "as"] => _ExpPrimitive.59

<_ExpPrimitive>: _ExpPrimitive : expression ( ( ( ( "is" with { test = "IsType" } ) | ( "is" "not" with { test = "IsNotType" } ) ) _Type : type as TypeTestingExpression ) | ( "is" "null" as TypeTestingExpression with { test = "IsNull" } ) | ( "is" "not"@ "null" as TypeTestingExpression with { test = "IsNotNull" } ) )
STATE _ExpPrimitive.52
    [KEYWORD_NULL "null"] => _ExpPrimitive.1
        SET test => IsNotNull
        CREATE TypeTestingExpression

<_Exp1>: _Exp1 : first@ "^" _Exp0 : second as BinaryExpression with { op = "Exp" }
STATE _Exp1.2
    [EXP "^"] => _Exp1.3

$<_Exp1> @
STATE _Exp1.RootEnd

<_Exp2>: !_Exp1@
<_Exp2>: _Exp2 : first "*" _Exp1 : second as BinaryExpression with { op = "Mul" }@
<_Exp2>: _Exp2 : first "/" _Exp1 : second as BinaryExpression with { op = "Div" }@
<_Exp2>: _Exp2 : first "%" _Exp1 : second as BinaryExpression with { op = "Mod" }@
END STATE _Exp2.1
    NORMAL-REDUCE => _Exp2.2
        REDUCE [_Exp2.Start => _Exp2.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp2.RootEnd
    NORMAL-REDUCE => _Exp3.1
        REDUCE [_Exp3.Start => _Exp3.1] 
        USING 
    NORMAL-REDUCE => _Exp3.4
        REDUCE [_Exp3.3 => _Exp3.4] 
        ASSIGN second

<_Exp2>: _Exp2 : first "*" _Exp1 : second as BinaryExpression@ with { op = "Mul" }
<_Exp2>: _Exp2 : first "/" _Exp1 : second as BinaryExpression@ with { op = "Div" }
<_Exp2>: _Exp2 : first "%" _Exp1 : second as BinaryExpression@ with { op = "Mod" }
STATE _Exp2.4
    EPSILON => _Exp2.1

<_Function>: "func"@ ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.1
    [NAME] => _Function.2
        ASSIGN name
    [OPEN_BRACKET "("] => _Function.3

@ <_LetVariable>
STATE _LetVariable.Start
    [NAME] => _LetVariable.1
        ASSIGN name

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) )@ _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) )@ _Expression : begin "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.27
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.27 => _ExpPrimitive.47] 

@ <_CtorFragment>
STATE _CtorFragment.Start
    EPSILON => _Expression.Start
        SHIFT [_CtorFragment.Start => _CtorFragment.1] 

<_ExpPrimitive>: "typeof" "("@ _Type : type ")" as TypeOfTypeExpression
STATE _ExpPrimitive.42
    EPSILON => _Type.Start
        SHIFT [_ExpPrimitive.42 => _ExpPrimitive.63] 

<_ExpPrimitive>: "type" "("@ _Expression : expression ")" as TypeOfExpressionExpression
STATE _ExpPrimitive.43
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.43 => _ExpPrimitive.63] 

<_ExpPrimitive>: "attach" "("@ _Expression : event "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.44
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.44 => _ExpPrimitive.53] 

<_ExpPrimitive>: "detach" "("@ _Expression : event "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.45
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.45 => _ExpPrimitive.54] 

<_VirtualExpression>: FORMATSTRING : value as FormatExpression@
<_VirtualExpression>: "bind" "(" _Expression : expression ")" as BindExpression@
<_VirtualExpression>: "$coroutine" [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression@
<_VirtualExpression>: "new" _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression@
STATE _VirtualExpression.1
    EPSILON => _VirtualExpression.5

<_VirtualExpression>: "bind"@ "(" _Expression : expression ")" as BindExpression
STATE _VirtualExpression.2
    [OPEN_BRACKET "("] => _VirtualExpression.6
        CREATE BindExpression

<_VirtualExpression>: "$coroutine"@ [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.3
    [OPEN_BRACKET "("] => _VirtualExpression.7
    EPSILON => _Block.Start
        SHIFT [_VirtualExpression.3 => _VirtualExpression.1] 

<_VirtualExpression>: "new"@ _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression
STATE _VirtualExpression.4
    EPSILON => _Type.Start
        SHIFT [_VirtualExpression.4 => _VirtualExpression.8] 

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":"@ _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.8
    EPSILON => _Type.Start
        SHIFT [_Function.8 => _Function.9] 

@ <_FunctionArgument>
STATE _FunctionArgument.Start
    [NAME] => _FunctionArgument.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_FunctionArgument.Start => _FunctionArgument.2] 

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":"@ _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { ","@ _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.7
    EPSILON => _BaseConstructorCall.Start
        SHIFT [_Constructor.7 => _Constructor.9] 

$<_MemberDeclarationBranch> @
STATE _MemberDeclarationBranch.RootEnd

<_Declaration>: { _Attribute : attributes } !_SharedDeclarationBranch@
<_Declaration>: { _Attribute : attributes } !_MemberDeclarationBranch@
END STATE _Declaration.1
    NORMAL-REDUCE => _Namespace.3
        REDUCE [_Namespace.3 => _Namespace.3] 
        ASSIGN declarations
    TOKEN-FINISH => _Declaration.RootEnd
    NORMAL-REDUCE => _Module.5
        REDUCE [_Module.3 => _Module.5] 
        ASSIGN declarations
    NORMAL-REDUCE => _Module.5
        REDUCE [_Module.5 => _Module.5] 
        ASSIGN declarations

<_MemberDeclaration>: { _Attribute : attributes } !_SharedDeclarationBranch@
<_MemberDeclaration>: { _Attribute : attributes } [ _ClassMember : classMember ] !_MemberDeclarationBranch@
END STATE _MemberDeclaration.1
    NORMAL-REDUCE => _ExpPrimitive.49
        REDUCE [_ExpPrimitive.49 => _ExpPrimitive.49] 
        ASSIGN declarations
    NORMAL-REDUCE => _ClassBody.2
        REDUCE [_ClassBody.2 => _ClassBody.2] 
        ASSIGN declarations
    TOKEN-FINISH => _MemberDeclaration.RootEnd

<_Block>: "{" { _Statement : statements } "}" as BlockStatement@
END STATE _Block.3
    NORMAL-REDUCE => _VirtualExpression.1
        REDUCE [_VirtualExpression.3 => _VirtualExpression.1] 
        ASSIGN statement
        CREATE NewCoroutineExpression
    NORMAL-REDUCE => _VirtualExpression.1
        REDUCE [_VirtualExpression.12 => _VirtualExpression.1] 
        ASSIGN statement
        CREATE NewCoroutineExpression
    NORMAL-REDUCE => _SwitchCase.4
        REDUCE [_SwitchCase.3 => _SwitchCase.4] 
        ASSIGN statement
    TOKEN-FINISH => _Block.RootEnd
    NORMAL-REDUCE => _If.8
        REDUCE [_If.6 => _If.8] 
        ASSIGN trueBranch
    NORMAL-REDUCE => _If.13
        REDUCE [_If.10 => _If.13] 
        ASSIGN falseBranch
    NORMAL-REDUCE => _VirtualStatement.19
        REDUCE [_VirtualStatement.20 => _VirtualStatement.19] 
        ASSIGN statement
        CREATE ForEachStatement
    NORMAL-REDUCE => _VirtualStatement.23
        REDUCE [_VirtualStatement.21 => _VirtualStatement.23] 
        ASSIGN defaultBranch
    NORMAL-REDUCE => _CoStatement.2
        REDUCE [_CoStatement.1 => _CoStatement.2] 
        ASSIGN statement
    NORMAL-REDUCE => _CoProvider.2
        REDUCE [_CoProvider.1 => _CoProvider.2] 
        ASSIGN statement
    NORMAL-REDUCE => _Statement.1
        REDUCE [_Statement.Start => _Statement.1] 
        USING 
    NORMAL-REDUCE => _Statement.10
        REDUCE [_Statement.8 => _Statement.10] 
        ASSIGN protectedStatement
    NORMAL-REDUCE => _Statement.2
        REDUCE [_Statement.13 => _Statement.2] 
        ASSIGN finallyStatement
    NORMAL-REDUCE => _Statement.2
        REDUCE [_Statement.14 => _Statement.2] 
        ASSIGN statement
    NORMAL-REDUCE => _Statement.18
        REDUCE [_Statement.17 => _Statement.18] 
        ASSIGN catchStatement
    NORMAL-REDUCE => _Function.10
        REDUCE [_Function.9 => _Function.10] 
        ASSIGN statement
    NORMAL-REDUCE => _Constructor.8
        REDUCE [_Constructor.5 => _Constructor.8] 
        ASSIGN statement
    NORMAL-REDUCE => _Constructor.8
        REDUCE [_Constructor.9 => _Constructor.8] 
        ASSIGN statement
    NORMAL-REDUCE => _Destructor.2
        REDUCE [_Destructor.1 => _Destructor.2] 
        ASSIGN statement

<_Statement>: "break"@ ";" as BreakStatement
<_Statement>: "continue"@ ";" as ContinueStatement
<_Statement>: "return" [ _Expression : expression ]@ ";" as ReturnStatement
<_Statement>: "delete" _Expression : expression@ ";" as DeleteStatement
<_Statement>: "raise" [ _Expression : expression ]@ ";" as RaiseExceptionStatement
<_Statement>: _Expression : expression@ ";" as ExpressionStatement
STATE _Statement.3
    [SEMICOLON ";"] => _Statement.2

<_Statement>: "return"@ [ _Expression : expression ] ";" as ReturnStatement
STATE _Statement.4
    [SEMICOLON ";"] => _Statement.2
        CREATE ReturnStatement
    EPSILON => _Expression.Start
        SHIFT [_Statement.4 => _Statement.3] 

<_Statement>: "delete"@ _Expression : expression ";" as DeleteStatement
STATE _Statement.5
    EPSILON => _Expression.Start
        SHIFT [_Statement.5 => _Statement.3] 

<_Statement>: "raise"@ [ _Expression : expression ] ";" as RaiseExceptionStatement
STATE _Statement.6
    [SEMICOLON ";"] => _Statement.2
        CREATE RaiseExceptionStatement
    EPSILON => _Expression.Start
        SHIFT [_Statement.6 => _Statement.3] 

@ <_If>
STATE _If.Start
    [KEYWORD_IF "if"] => _If.1

<_Statement>: "while"@ "(" _Expression : condition ")" _Block : statement as WhileStatement
STATE _Statement.7
    [OPEN_BRACKET "("] => _Statement.9

<_Statement>: "try"@ _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.8
    EPSILON => _Block.Start
        SHIFT [_Statement.8 => _Statement.10] 

@ <_VirtualStatement>
STATE _VirtualStatement.Start
    [KEYWORD_SWITCH "switch"] => _VirtualStatement.1
    [KEYWORD_FOR "for"] => _VirtualStatement.2
    [KEYWORD_VAR "var"] => _VirtualStatement.3
    [COROUTINE_OPERATOR] => _VirtualStatement.4
        ASSIGN opName

@ <_CoStatement>
STATE _CoStatement.Start
    [COROUTINE_PAUSE "$pause"] => _CoStatement.1

$<_Event> @
STATE _Event.RootEnd

<_SharedDeclarationBranch>: !_Namespace@
<_SharedDeclarationBranch>: !_Variable@
<_SharedDeclarationBranch>: !_Event@
<_SharedDeclarationBranch>: !_Property@
<_SharedDeclarationBranch>: !_Constructor@
<_SharedDeclarationBranch>: !_Destructor@
<_SharedDeclarationBranch>: !_Class@
<_SharedDeclarationBranch>: !_Enum@
<_SharedDeclarationBranch>: !_Struct@
<_SharedDeclarationBranch>: !_CastResultInterface@
END STATE _SharedDeclarationBranch.1
    TOKEN-FINISH => _SharedDeclarationBranch.RootEnd
    NORMAL-REDUCE => _Declaration.1
        REDUCE [_Declaration.Start => _Declaration.1] 
        USING 
    NORMAL-REDUCE => _Declaration.1
        REDUCE [_Declaration.2 => _Declaration.1] 
        USING 
    NORMAL-REDUCE => _MemberDeclaration.1
        REDUCE [_MemberDeclaration.Start => _MemberDeclaration.1] 
        USING 
    NORMAL-REDUCE => _MemberDeclaration.1
        REDUCE [_MemberDeclaration.2 => _MemberDeclaration.1] 
        USING 

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration@
END STATE _Property.12
    TOKEN-FINISH => _Property.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ]@ "}" as PropertyDeclaration
STATE _Property.11
    [CLOSE_BRACE "}"] => _Property.9

<_Property>: "prop" NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ]@ [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.10
    [CLOSE_BRACE "}"] => _Property.9
    [COLON ":"] => _Property.8

$<_BaseConstructorCall> @
STATE _BaseConstructorCall.RootEnd

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls@ { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls @{ "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.9
    [COMMA ","] => _Constructor.7
    EPSILON => _Block.Start
        SHIFT [_Constructor.9 => _Constructor.8] 

$<_ClassBody> @
STATE _ClassBody.RootEnd

<_Class>: "class" NAME : name !_ClassBody@ with { kind = "Class" } with { constructorType = "Undefined" }
<_Class>: "interface" NAME : name !_ClassBody@ with { kind = "Interface" } with { constructorType = "SharedPtr" }
<_Class>: "interface" NAME : name "*" !_ClassBody@ with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.5
    EPSILON => _Class.6

<_Struct>: "struct" NAME : name "{" { _StructMember : members } "}" as StructDeclaration@
STATE _Struct.4
    EPSILON => _Struct.5
        CREATE StructDeclaration

@ <_StructMember>
STATE _StructMember.Start
    [NAME] => _StructMember.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_StructMember.Start => _StructMember.2] 

<_APConfig>: "{" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "Observable" }@
<_APConfig>: "{" "const" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "Observable" }@
<_APConfig>: "{" "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Writable" } with { configObserve = "NotObservable" }@
<_APConfig>: "{" "const" "," "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }@
END STATE _APConfig.6
    TOKEN-FINISH => _APConfig.RootEnd
    NORMAL-REDUCE => _AutoProperty.6
        REDUCE [_AutoProperty.4 => _AutoProperty.6] 
        USING 
    NORMAL-REDUCE => _AutoProperty.6
        REDUCE [_AutoProperty.7 => _AutoProperty.6] 
        USING 

<_APConfig>: "{" "const" ","@ "not" "observe" "}" as AutoPropertyDeclaration with { configConst = "Readonly" } with { configObserve = "NotObservable" }
STATE _APConfig.7
    [KEYWORD_NOT "not"] => _APConfig.4
        SET configObserve => NotObservable
        SET configConst => Readonly
        CREATE AutoPropertyDeclaration

$<_CastResultInterface> @
STATE _CastResultInterface.RootEnd

@ <_Exp9>
STATE _Exp9.Start
    EPSILON => _Exp8.Start
        SHIFT [_Exp9.Start => _Exp9.1] 
    EPSILON => _Exp9.Start
        SHIFT [_Exp9.Start => _Exp9.2] 

<_Namespace>: "namespace"@ NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.1
    [NAME] => _Namespace.2
        ASSIGN name

<_Variable>: "var"@ NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.1
    [NAME] => _Variable.2
        ASSIGN name

<_Event>: "event"@ NAME : name "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.1
    [NAME] => _Event.2
        ASSIGN name

<_Property>: "prop"@ NAME : name ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.1
    [NAME] => _Property.2
        ASSIGN name

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) )@ "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) )@ "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.1
    [OPEN_BRACKET "("] => _Constructor.3

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new"@ "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.2
    [MUL "*"] => _Constructor.1
        SET constructorType => RawPtr

<_Destructor>: "delete"@ _Block : statement as DestructorDeclaration
STATE _Destructor.1
    EPSILON => _Block.Start
        SHIFT [_Destructor.1 => _Destructor.2] 

<_Class>: "class"@ NAME : name !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }
<_Class>: "interface"@ NAME : name !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }
STATE _Class.1
    [NAME] => _Class.3
        ASSIGN name

<_Class>: "interface"@ NAME : name "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.2
    [NAME] => _Class.4
        ASSIGN name

<_Enum>: "enum"@ NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.1
    [NAME] => _Enum.3
        ASSIGN name

<_Enum>: "flagenum"@ NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.2
    [NAME] => _Enum.4
        ASSIGN name

<_Struct>: "struct"@ NAME : name "{" { _StructMember : members } "}" as StructDeclaration
STATE _Struct.1
    [NAME] => _Struct.2
        ASSIGN name

<_CastResultInterface>: "$interface"@ NAME : name ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.1
    [NAME] => _CastResultInterface.2
        ASSIGN name

<_Attribute>: "@" NAME : category@ ":" NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.2
    [COLON ":"] => _Attribute.3

<_ClassMember>: "static" as ClassMember with { kind = "Static" }@
<_ClassMember>: "override" as ClassMember with { kind = "Override" }@
END STATE _ClassMember.2
    TOKEN-FINISH => _ClassMember.RootEnd
    NORMAL-REDUCE => _MemberDeclaration.3
        REDUCE [_MemberDeclaration.Start => _MemberDeclaration.3] 
        ASSIGN classMember
    NORMAL-REDUCE => _MemberDeclaration.3
        REDUCE [_MemberDeclaration.4 => _MemberDeclaration.3] 
        ASSIGN classMember

<_AutoProperty>: "prop"@ NAME : name ":" _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.1
    [NAME] => _AutoProperty.2
        ASSIGN name

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "("@ _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.58
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.58 => _ExpPrimitive.66] 

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as"@ NAME : name "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.59
    [NAME] => _ExpPrimitive.67
        ASSIGN name

<_Exp1>: _Exp1 : first "^"@ _Exp0 : second as BinaryExpression with { op = "Exp" }
STATE _Exp1.3
    EPSILON => _Exp0.Start
        SHIFT [_Exp1.3 => _Exp1.4] 

<_Exp2>: _Exp2 : first@ "*" _Exp1 : second as BinaryExpression with { op = "Mul" }
<_Exp2>: _Exp2 : first@ "/" _Exp1 : second as BinaryExpression with { op = "Div" }
<_Exp2>: _Exp2 : first@ "%" _Exp1 : second as BinaryExpression with { op = "Mod" }
STATE _Exp2.2
    [MUL "*"] => _Exp2.3
        CREATE BinaryExpression
        SET op => Mul
    [DIV "/"] => _Exp2.3
        CREATE BinaryExpression
        SET op => Div
    [MOD "%"] => _Exp2.3
        CREATE BinaryExpression
        SET op => Mod

$<_Exp2> @
STATE _Exp2.RootEnd

<_Exp3>: !_Exp2@
<_Exp3>: _Exp3 : first "+" _Exp2 : second as BinaryExpression with { op = "Add" }@
<_Exp3>: _Exp3 : first "-" _Exp2 : second as BinaryExpression with { op = "Sub" }@
<_Exp3>: _Exp3 : first "&" _Exp2 : second as BinaryExpression with { op = "Union" }@
<_Exp3>: _Exp3 : first "|" _Exp2 : second as BinaryExpression with { op = "Intersect" }@
END STATE _Exp3.1
    NORMAL-REDUCE => _Exp3.2
        REDUCE [_Exp3.Start => _Exp3.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp3.RootEnd
    NORMAL-REDUCE => _Exp4.1
        REDUCE [_Exp4.Start => _Exp4.1] 
        USING 
    NORMAL-REDUCE => _Exp4.4
        REDUCE [_Exp4.3 => _Exp4.4] 
        ASSIGN second

<_Exp3>: _Exp3 : first "+" _Exp2 : second as BinaryExpression@ with { op = "Add" }
<_Exp3>: _Exp3 : first "-" _Exp2 : second as BinaryExpression@ with { op = "Sub" }
<_Exp3>: _Exp3 : first "&" _Exp2 : second as BinaryExpression@ with { op = "Union" }
<_Exp3>: _Exp3 : first "|" _Exp2 : second as BinaryExpression@ with { op = "Intersect" }
STATE _Exp3.4
    EPSILON => _Exp3.1

<_Function>: "func" ( ( NAME : name@ "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) ) [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.2
    [OPEN_BRACKET "("] => _Function.4

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) )@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.3
    [CLOSE_BRACKET ")"] => _Function.6
        SET anonymity => Anonymous
    EPSILON => _FunctionArgument.Start
        SHIFT [_Function.3 => _Function.5] 

<_LetVariable>: NAME : name@ "=" _Expression : value as LetVariable
STATE _LetVariable.1
    [ASSIGN "="] => _LetVariable.2

<_VirtualExpression>: FORMATSTRING : value as FormatExpression@
<_VirtualExpression>: "bind" "(" _Expression : expression ")" as BindExpression@
<_VirtualExpression>: "$coroutine" [ "(" NAME : name ")" ] _Block : statement as NewCoroutineExpression@
<_VirtualExpression>: "new" _Type : type "(" "using" _Expression : expression ")" as MixinCastExpression@
END STATE _VirtualExpression.5
    TOKEN-FINISH => _VirtualExpression.RootEnd
    NORMAL-REDUCE => _ExpPrimitive.23
        REDUCE [_ExpPrimitive.Start => _ExpPrimitive.23] 
        USING 

<_VirtualExpression>: "bind" "("@ _Expression : expression ")" as BindExpression
STATE _VirtualExpression.6
    EPSILON => _Expression.Start
        SHIFT [_VirtualExpression.6 => _VirtualExpression.9] 

<_VirtualExpression>: "$coroutine" [ "("@ NAME : name ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.7
    [NAME] => _VirtualExpression.10
        ASSIGN name

<_FunctionArgument>: { _Attribute : attributes } NAME : name@ ":" _Type : type as FunctionArgument
STATE _FunctionArgument.1
    [COLON ":"] => _FunctionArgument.3

@ <_BaseConstructorCall>
STATE _BaseConstructorCall.Start
    EPSILON => _Type.Start
        SHIFT [_BaseConstructorCall.Start => _BaseConstructorCall.1] 

<_Namespace>: "namespace" NAME : name "{"@ { _Declaration : declarations } "}" as NamespaceDeclaration
<_Namespace>: "namespace" NAME : name "{" @{ _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.3
    [CLOSE_BRACE "}"] => _Namespace.4
    EPSILON => _Declaration.Start
        SHIFT [_Namespace.3 => _Namespace.3] 

$<_Declaration> @
STATE _Declaration.RootEnd

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths } @{ _Declaration : declarations } as Module
STATE _Module.5
    EPSILON => _Module.4
        CREATE Module
    EPSILON => _Declaration.Start
        SHIFT [_Module.5 => _Module.5] 

$<_MemberDeclaration> @
STATE _MemberDeclaration.RootEnd

<_SwitchCase>: "case" _Expression : expression ":" _Block : statement as SwitchCase@
STATE _SwitchCase.4
    EPSILON => _SwitchCase.5
        CREATE SwitchCase

$<_Block> @
STATE _Block.RootEnd

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch@ [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.8
    EPSILON => _If.11
        CREATE IfStatement
    [KEYWORD_ELSE "else"] => _If.10

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement@
STATE _If.13
    EPSILON => _If.11
        CREATE IfStatement

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement@
<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement@
<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement@
STATE _VirtualStatement.19
    EPSILON => _VirtualStatement.22

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ]@ "}" as SwitchStatement
STATE _VirtualStatement.23
    [CLOSE_BRACE "}"] => _VirtualStatement.19
        CREATE SwitchStatement

<_CoStatement>: "$pause" ( ";" | _Block : statement ) as CoPauseStatement@
STATE _CoStatement.2
    EPSILON => _CoStatement.3
        CREATE CoPauseStatement

<_CoProvider>: ( "$" | COROUTINE_OPERATOR : name ) _Block : statement as CoProviderStatement@
STATE _CoProvider.2
    EPSILON => _CoProvider.3
        CREATE CoProviderStatement

<_Statement>: !_Block@
<_Statement>: _Variable : variable as VariableStatement@
<_Statement>: "break" ";" as BreakStatement@
<_Statement>: "continue" ";" as ContinueStatement@
<_Statement>: "return" [ _Expression : expression ] ";" as ReturnStatement@
<_Statement>: "delete" _Expression : expression ";" as DeleteStatement@
<_Statement>: "raise" [ _Expression : expression ] ";" as RaiseExceptionStatement@
<_Statement>: !_If@
<_Statement>: "while" "(" _Expression : condition ")" _Block : statement as WhileStatement@
<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement@
<_Statement>: _Expression : expression ";" as ExpressionStatement@
<_Statement>: !_VirtualStatement@
<_Statement>: !_CoStatement@
END STATE _Statement.1
    NORMAL-REDUCE => _Block.1
        REDUCE [_Block.1 => _Block.1] 
        ASSIGN statements
    TOKEN-FINISH => _Statement.RootEnd

<_Statement>: "try" _Block : protectedStatement@ [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.10
    EPSILON => _Statement.1
        CREATE TryStatement
    [KEYWORD_CATCH "catch"] => _Statement.12
    [KEYWORD_FINALLY "finally"] => _Statement.13
        CREATE TryStatement

<_Statement>: _Variable : variable as VariableStatement@
<_Statement>: "break" ";" as BreakStatement@
<_Statement>: "continue" ";" as ContinueStatement@
<_Statement>: "return" [ _Expression : expression ] ";" as ReturnStatement@
<_Statement>: "delete" _Expression : expression ";" as DeleteStatement@
<_Statement>: "raise" [ _Expression : expression ] ";" as RaiseExceptionStatement@
<_Statement>: "while" "(" _Expression : condition ")" _Block : statement as WhileStatement@
<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement@
<_Statement>: _Expression : expression ";" as ExpressionStatement@
STATE _Statement.2
    EPSILON => _Statement.1

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ]@ [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.18
    EPSILON => _Statement.1
        CREATE TryStatement
    [KEYWORD_FINALLY "finally"] => _Statement.13
        CREATE TryStatement

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration@
STATE _Constructor.8
    EPSILON => _Constructor.10
        CREATE ConstructorDeclaration

<_Destructor>: "delete" _Block : statement as DestructorDeclaration@
STATE _Destructor.2
    EPSILON => _Destructor.3
        CREATE DestructorDeclaration

<_If>: "if"@ "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.1
    [OPEN_BRACKET "("] => _If.2

<_Statement>: "while" "("@ _Expression : condition ")" _Block : statement as WhileStatement
STATE _Statement.9
    EPSILON => _Expression.Start
        SHIFT [_Statement.9 => _Statement.11] 

<_VirtualStatement>: "switch"@ "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.1
    [OPEN_BRACKET "("] => _VirtualStatement.5

<_VirtualStatement>: "for"@ "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.2
    [OPEN_BRACKET "("] => _VirtualStatement.6

<_VirtualStatement>: [ "var"@ NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.3
    [NAME] => _VirtualStatement.7
        ASSIGN varName

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName@ [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.4
    [SEMICOLON ";"] => _VirtualStatement.19
        CREATE CoOperatorStatement
    EPSILON => _Expression.Start
        SHIFT [_VirtualStatement.4 => _VirtualStatement.8] 

<_CoStatement>: "$pause"@ ( ";" | _Block : statement ) as CoPauseStatement
STATE _CoStatement.1
    [SEMICOLON ";"] => _CoStatement.2
    EPSILON => _Block.Start
        SHIFT [_CoStatement.1 => _CoStatement.2] 

$<_SharedDeclarationBranch> @
STATE _SharedDeclarationBranch.RootEnd

$<_Property> @
STATE _Property.RootEnd

<_Class>: "class" NAME : name !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }@
<_Class>: "interface" NAME : name !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }@
<_Class>: "interface" NAME : name "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }@
END STATE _Class.6
    TOKEN-FINISH => _Class.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_Struct>: "struct" NAME : name "{" { _StructMember : members } "}" as StructDeclaration@
END STATE _Struct.5
    TOKEN-FINISH => _Struct.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_StructMember>: { _Attribute : attributes } NAME : name@ ":" _Type : type ";" as StructMember
STATE _StructMember.1
    [COLON ":"] => _StructMember.3

$<_APConfig> @
STATE _APConfig.RootEnd

<_AutoProperty>: "prop" NAME : name ":" _Type : type [ "=" _Expression : expression ] !_APConfig@
END STATE _AutoProperty.6
    TOKEN-FINISH => _AutoProperty.RootEnd
    NORMAL-REDUCE => _MemberDeclarationBranch.1
        REDUCE [_MemberDeclarationBranch.Start => _MemberDeclarationBranch.1] 
        USING 

@ <_Exp8>
STATE _Exp8.Start
    EPSILON => _Exp7.Start
        SHIFT [_Exp8.Start => _Exp8.1] 
    EPSILON => _Exp8.Start
        SHIFT [_Exp8.Start => _Exp8.2] 

<_Namespace>: "namespace" NAME : name@ "{" { _Declaration : declarations } "}" as NamespaceDeclaration
STATE _Namespace.2
    [OPEN_BRACE "{"] => _Namespace.3

<_Variable>: "var" NAME : name@ [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.2
    [ASSIGN "="] => _Variable.4
    [COLON ":"] => _Variable.3

<_Event>: "event" NAME : name@ "(" [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.2
    [OPEN_BRACKET "("] => _Event.3

<_Property>: "prop" NAME : name@ ":" _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.2
    [COLON ":"] => _Property.3

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "("@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration
STATE _Constructor.3
    [CLOSE_BRACKET ")"] => _Constructor.5
    EPSILON => _FunctionArgument.Start
        SHIFT [_Constructor.3 => _Constructor.4] 

<_Class>: "class" NAME : name@ !_ClassBody with { kind = "Class" } with { constructorType = "Undefined" }
<_Class>: "interface" NAME : name@ !_ClassBody with { kind = "Interface" } with { constructorType = "SharedPtr" }
<_Class>: "interface" NAME : name "*"@ !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.3
    EPSILON => _ClassBody.Start
        SHIFT [_Class.3 => _Class.5] 

<_Class>: "interface" NAME : name@ "*" !_ClassBody with { kind = "Interface" } with { constructorType = "RawPtr" }
STATE _Class.4
    [MUL "*"] => _Class.3
        SET constructorType => RawPtr
        SET kind => Interface

<_Enum>: "enum" NAME : name@ "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.3
    [OPEN_BRACE "{"] => _Enum.5

<_Enum>: "flagenum" NAME : name@ "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.4
    [OPEN_BRACE "{"] => _Enum.6

<_Struct>: "struct" NAME : name@ "{" { _StructMember : members } "}" as StructDeclaration
STATE _Struct.2
    [OPEN_BRACE "{"] => _Struct.3

<_CastResultInterface>: "$interface" NAME : name@ ":" _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.2
    [COLON ":"] => _CastResultInterface.3

<_Attribute>: "@" NAME : category ":"@ NAME : name [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.3
    [NAME] => _Attribute.4
        ASSIGN name

$<_ClassMember> @
STATE _ClassMember.RootEnd

<_MemberDeclaration>: { _Attribute : attributes } [ _ClassMember : classMember ]@ !_MemberDeclarationBranch
STATE _MemberDeclaration.3
    EPSILON => _MemberDeclarationBranch.Start
        SHIFT [_MemberDeclaration.3 => _MemberDeclaration.1] 

<_AutoProperty>: "prop" NAME : name@ ":" _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.2
    [COLON ":"] => _AutoProperty.3

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name@ "(" _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.67
    [OPEN_BRACKET "("] => _ExpPrimitive.69

<_Exp2>: _Exp2 : first "*"@ _Exp1 : second as BinaryExpression with { op = "Mul" }
<_Exp2>: _Exp2 : first "/"@ _Exp1 : second as BinaryExpression with { op = "Div" }
<_Exp2>: _Exp2 : first "%"@ _Exp1 : second as BinaryExpression with { op = "Mod" }
STATE _Exp2.3
    EPSILON => _Exp1.Start
        SHIFT [_Exp2.3 => _Exp2.4] 

<_Exp3>: _Exp3 : first@ "+" _Exp2 : second as BinaryExpression with { op = "Add" }
<_Exp3>: _Exp3 : first@ "-" _Exp2 : second as BinaryExpression with { op = "Sub" }
<_Exp3>: _Exp3 : first@ "&" _Exp2 : second as BinaryExpression with { op = "Union" }
<_Exp3>: _Exp3 : first@ "|" _Exp2 : second as BinaryExpression with { op = "Intersect" }
STATE _Exp3.2
    [ADD "+"] => _Exp3.3
        CREATE BinaryExpression
        SET op => Add
    [SUB "-"] => _Exp3.3
        CREATE BinaryExpression
        SET op => Sub
    [UNION "&"] => _Exp3.3
        CREATE BinaryExpression
        SET op => Union
    [INTERSECTION "|"] => _Exp3.3
        CREATE BinaryExpression
        SET op => Intersect

$<_Exp3> @
STATE _Exp3.RootEnd

<_Exp4>: !_Exp3@
<_Exp4>: _Exp4 : first "shl" _Exp3 : second as BinaryExpression with { op = "Shl" }@
<_Exp4>: _Exp4 : first "shr" _Exp3 : second as BinaryExpression with { op = "Shr" }@
END STATE _Exp4.1
    NORMAL-REDUCE => _Exp4.2
        REDUCE [_Exp4.Start => _Exp4.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp4.RootEnd
    NORMAL-REDUCE => _Exp5.1
        REDUCE [_Exp5.Start => _Exp5.1] 
        USING 
    NORMAL-REDUCE => _Exp5.4
        REDUCE [_Exp5.3 => _Exp5.4] 
        ASSIGN second

<_Exp4>: _Exp4 : first "shl" _Exp3 : second as BinaryExpression@ with { op = "Shl" }
<_Exp4>: _Exp4 : first "shr" _Exp3 : second as BinaryExpression@ with { op = "Shr" }
STATE _Exp4.4
    EPSILON => _Exp4.1

<_Function>: "func" ( ( NAME : name "(" with { anonymity = "Named" } ) | ( "(" with { anonymity = "Anonymous" } ) )@ [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" ":" _Type : returnType ( _Block : statement | _CoProvider : statement | ";" ) as FunctionDeclaration
STATE _Function.4
    [CLOSE_BRACKET ")"] => _Function.6
        SET anonymity => Named
    EPSILON => _FunctionArgument.Start
        SHIFT [_Function.4 => _Function.5] 

<_LetVariable>: NAME : name "="@ _Expression : value as LetVariable
STATE _LetVariable.2
    EPSILON => _Expression.Start
        SHIFT [_LetVariable.2 => _LetVariable.3] 

$<_VirtualExpression> @
STATE _VirtualExpression.RootEnd

<_VirtualExpression>: "$coroutine" [ "(" NAME : name@ ")" ] _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.10
    [CLOSE_BRACKET ")"] => _VirtualExpression.12

<_FunctionArgument>: { _Attribute : attributes } NAME : name ":"@ _Type : type as FunctionArgument
STATE _FunctionArgument.3
    EPSILON => _Type.Start
        SHIFT [_FunctionArgument.3 => _FunctionArgument.4] 

<_Namespace>: "namespace" NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration@
STATE _Namespace.4
    EPSILON => _Namespace.5
        CREATE NamespaceDeclaration

@ <_Declaration>
STATE _Declaration.Start
    EPSILON => _SharedDeclarationBranch.Start
        SHIFT [_Declaration.Start => _Declaration.1] 
    EPSILON => _Attribute.Start
        SHIFT [_Declaration.Start => _Declaration.2] 
    EPSILON => _MemberDeclarationBranch.Start
        SHIFT [_Declaration.Start => _Declaration.1] 
    EPSILON => _Attribute.Start
        SHIFT [_Declaration.Start => _Declaration.3] 

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module@
END STATE _Module.4
    TOKEN-FINISH => _Module.RootEnd

<_SwitchCase>: "case" _Expression : expression ":" _Block : statement as SwitchCase@
END STATE _SwitchCase.5
    TOKEN-FINISH => _SwitchCase.RootEnd
    NORMAL-REDUCE => _VirtualStatement.16
        REDUCE [_VirtualStatement.16 => _VirtualStatement.16] 
        ASSIGN caseBranches

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement@
END STATE _If.11
    TOKEN-FINISH => _If.RootEnd
    NORMAL-REDUCE => _If.13
        REDUCE [_If.10 => _If.13] 
        ASSIGN falseBranch
    NORMAL-REDUCE => _Statement.1
        REDUCE [_Statement.Start => _Statement.1] 
        USING 

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else"@ ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.10
    EPSILON => _Block.Start
        SHIFT [_If.10 => _If.13] 
    EPSILON => _If.Start
        SHIFT [_If.10 => _If.13] 

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement@
<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement@
<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement@
END STATE _VirtualStatement.22
    TOKEN-FINISH => _VirtualStatement.RootEnd
    NORMAL-REDUCE => _Statement.1
        REDUCE [_Statement.Start => _Statement.1] 
        USING 

<_CoStatement>: "$pause" ( ";" | _Block : statement ) as CoPauseStatement@
END STATE _CoStatement.3
    TOKEN-FINISH => _CoStatement.RootEnd
    NORMAL-REDUCE => _Statement.1
        REDUCE [_Statement.Start => _Statement.1] 
        USING 

<_CoProvider>: ( "$" | COROUTINE_OPERATOR : name ) _Block : statement as CoProviderStatement@
END STATE _CoProvider.3
    TOKEN-FINISH => _CoProvider.RootEnd
    NORMAL-REDUCE => _Function.10
        REDUCE [_Function.9 => _Function.10] 
        ASSIGN statement

$<_Statement> @
STATE _Statement.RootEnd

<_Statement>: "try" _Block : protectedStatement [ "catch"@ "(" NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.12
    [OPEN_BRACKET "("] => _Statement.15

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")" _Block : catchStatement ] [ "finally"@ _Block : finallyStatement ] as TryStatement
STATE _Statement.13
    EPSILON => _Block.Start
        SHIFT [_Statement.13 => _Statement.2] 

<_Constructor>: ( ( "new" with { constructorType = "SharedPtr" } ) | ( "new" "*" with { constructorType = "RawPtr" } ) ) "(" [ _FunctionArgument : arguments { "," _FunctionArgument : arguments } ] ")" [ ":" _BaseConstructorCall : baseConstructorCalls { "," _BaseConstructorCall : baseConstructorCalls } ] _Block : statement as ConstructorDeclaration@
END STATE _Constructor.10
    TOKEN-FINISH => _Constructor.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_Destructor>: "delete" _Block : statement as DestructorDeclaration@
END STATE _Destructor.3
    TOKEN-FINISH => _Destructor.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_If>: "if" "("@ [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.2
    [KEYWORD_VAR "var"] => _If.3
    EPSILON => _Expression.Start
        SHIFT [_If.2 => _If.4] 

<_VirtualStatement>: "switch" "("@ _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.5
    EPSILON => _Expression.Start
        SHIFT [_VirtualStatement.5 => _VirtualStatement.9] 

<_VirtualStatement>: "for" "("@ NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.6
    [NAME] => _VirtualStatement.10
        ASSIGN name

<_VirtualStatement>: [ "var" NAME : varName@ "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.7
    [ASSIGN "="] => _VirtualStatement.11

$<_Class> @
STATE _Class.RootEnd

$<_Struct> @
STATE _Struct.RootEnd

<_StructMember>: { _Attribute : attributes } NAME : name ":"@ _Type : type ";" as StructMember
STATE _StructMember.3
    EPSILON => _Type.Start
        SHIFT [_StructMember.3 => _StructMember.4] 

$<_AutoProperty> @
STATE _AutoProperty.RootEnd

@ <_Exp7>
STATE _Exp7.Start
    EPSILON => _Exp6.Start
        SHIFT [_Exp7.Start => _Exp7.1] 
    EPSILON => _Exp7.Start
        SHIFT [_Exp7.Start => _Exp7.2] 

<_Variable>: "var" NAME : name [ ":"@ _Type : type ] "=" _Expression : expression ";" as VariableDeclaration
STATE _Variable.3
    EPSILON => _Type.Start
        SHIFT [_Variable.3 => _Variable.5] 

<_Event>: "event" NAME : name "("@ [ _Type : arguments { "," _Type : arguments } ] ")" ";" as EventDeclaration
STATE _Event.3
    [CLOSE_BRACKET ")"] => _Event.5
    EPSILON => _Type.Start
        SHIFT [_Event.3 => _Event.4] 

<_Property>: "prop" NAME : name ":"@ _Type : type "{" NAME : getter [ "," NAME : setter ] [ ":" NAME : valueChangedEvent ] "}" as PropertyDeclaration
STATE _Property.3
    EPSILON => _Type.Start
        SHIFT [_Property.3 => _Property.4] 

@ <_ClassBody>
STATE _ClassBody.Start
    [COLON ":"] => _ClassBody.1
    [OPEN_BRACE "{"] => _ClassBody.2

<_Enum>: "enum" NAME : name "{"@ _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.5
    EPSILON => _EnumItemA.Start
        SHIFT [_Enum.5 => _Enum.7] 

<_Enum>: "flagenum" NAME : name "{"@ _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.6
    EPSILON => _EnumItemA.Start
        SHIFT [_Enum.6 => _Enum.8] 

<_CastResultInterface>: "$interface" NAME : name ":"@ _Type : baseType "<" _Type : elementType ">" ";" as CastResultInterfaceDeclaration
STATE _CastResultInterface.3
    EPSILON => _Type.Start
        SHIFT [_CastResultInterface.3 => _CastResultInterface.4] 

<_Attribute>: "@" NAME : category ":" NAME : name@ [ "(" _Expression : value ")" ] as Attribute
STATE _Attribute.4
    EPSILON => _Attribute.6
        CREATE Attribute
    [OPEN_BRACKET "("] => _Attribute.5

<_AutoProperty>: "prop" NAME : name ":"@ _Type : type [ "=" _Expression : expression ] !_APConfig
STATE _AutoProperty.3
    EPSILON => _Type.Start
        SHIFT [_AutoProperty.3 => _AutoProperty.4] 

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "("@ _Expression : expression [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.69
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.69 => _ExpPrimitive.71] 

@ <_Exp1>
STATE _Exp1.Start
    EPSILON => _Exp0.Start
        SHIFT [_Exp1.Start => _Exp1.1] 
    EPSILON => _Exp1.Start
        SHIFT [_Exp1.Start => _Exp1.2] 

<_Exp3>: _Exp3 : first "+"@ _Exp2 : second as BinaryExpression with { op = "Add" }
<_Exp3>: _Exp3 : first "-"@ _Exp2 : second as BinaryExpression with { op = "Sub" }
<_Exp3>: _Exp3 : first "&"@ _Exp2 : second as BinaryExpression with { op = "Union" }
<_Exp3>: _Exp3 : first "|"@ _Exp2 : second as BinaryExpression with { op = "Intersect" }
STATE _Exp3.3
    EPSILON => _Exp2.Start
        SHIFT [_Exp3.3 => _Exp3.4] 

<_Exp4>: _Exp4 : first@ "shl" _Exp3 : second as BinaryExpression with { op = "Shl" }
<_Exp4>: _Exp4 : first@ "shr" _Exp3 : second as BinaryExpression with { op = "Shr" }
STATE _Exp4.2
    [KEYWORD_SHL "shl"] => _Exp4.3
        CREATE BinaryExpression
        SET op => Shl
    [KEYWORD_SHR "shr"] => _Exp4.3
        CREATE BinaryExpression
        SET op => Shr

$<_Exp4> @
STATE _Exp4.RootEnd

<_Exp5>: !_Exp4@
<_Exp5>: _Exp5 : first "<" _Exp4 : second as BinaryExpression with { op = "LT" }@
<_Exp5>: _Exp5 : first ">" _Exp4 : second as BinaryExpression with { op = "GT" }@
<_Exp5>: _Exp5 : first "<=" _Exp4 : second as BinaryExpression with { op = "LE" }@
<_Exp5>: _Exp5 : first ">=" _Exp4 : second as BinaryExpression with { op = "GE" }@
<_Exp5>: _Exp5 : first "==" _Exp4 : second as BinaryExpression with { op = "EQ" }@
<_Exp5>: _Exp5 : first "!=" _Exp4 : second as BinaryExpression with { op = "NE" }@
END STATE _Exp5.1
    NORMAL-REDUCE => _Exp5.2
        REDUCE [_Exp5.Start => _Exp5.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp5.RootEnd
    NORMAL-REDUCE => _Exp6.1
        REDUCE [_Exp6.Start => _Exp6.1] 
        USING 
    NORMAL-REDUCE => _Exp6.4
        REDUCE [_Exp6.3 => _Exp6.4] 
        ASSIGN second

<_Exp5>: _Exp5 : first "<" _Exp4 : second as BinaryExpression@ with { op = "LT" }
<_Exp5>: _Exp5 : first ">" _Exp4 : second as BinaryExpression@ with { op = "GT" }
<_Exp5>: _Exp5 : first "<=" _Exp4 : second as BinaryExpression@ with { op = "LE" }
<_Exp5>: _Exp5 : first ">=" _Exp4 : second as BinaryExpression@ with { op = "GE" }
<_Exp5>: _Exp5 : first "==" _Exp4 : second as BinaryExpression@ with { op = "EQ" }
<_Exp5>: _Exp5 : first "!=" _Exp4 : second as BinaryExpression@ with { op = "NE" }
STATE _Exp5.4
    EPSILON => _Exp5.1

<_VirtualExpression>: "$coroutine" [ "(" NAME : name ")" ]@ _Block : statement as NewCoroutineExpression
STATE _VirtualExpression.12
    EPSILON => _Block.Start
        SHIFT [_VirtualExpression.12 => _VirtualExpression.1] 

<_Namespace>: "namespace" NAME : name "{" { _Declaration : declarations } "}" as NamespaceDeclaration@
END STATE _Namespace.5
    TOKEN-FINISH => _Namespace.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

$<_Module> @
STATE _Module.RootEnd

$<_SwitchCase> @
STATE _SwitchCase.RootEnd

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{"@ { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" @{ _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.16
    [CLOSE_BRACE "}"] => _VirtualStatement.19
        CREATE SwitchStatement
    [KEYWORD_DEFAULT "default"] => _VirtualStatement.18
    EPSILON => _SwitchCase.Start
        SHIFT [_VirtualStatement.16 => _VirtualStatement.16] 

$<_If> @
STATE _If.RootEnd

$<_VirtualStatement> @
STATE _VirtualStatement.RootEnd

$<_CoStatement> @
STATE _CoStatement.RootEnd

$<_CoProvider> @
STATE _CoProvider.RootEnd

<_Statement>: "try" _Block : protectedStatement [ "catch" "("@ NAME : name ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.15
    [NAME] => _Statement.16
        ASSIGN name

$<_Constructor> @
STATE _Constructor.RootEnd

$<_Destructor> @
STATE _Destructor.RootEnd

<_If>: "if" "(" [ "var"@ NAME : name ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.3
    [NAME] => _If.5
        ASSIGN name

<_VirtualStatement>: "for" "(" NAME : name@ ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.10
    [KEYWORD_IN "in"] => _VirtualStatement.14
        SET direction => Normal
    [KEYWORD_IN "in"] => _VirtualStatement.15

<_VirtualStatement>: [ "var" NAME : varName "=" ]@ COROUTINE_OPERATOR : opName [ _Expression : arguments { "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.11
    [COROUTINE_OPERATOR] => _VirtualStatement.4
        ASSIGN opName

@ <_Exp6>
STATE _Exp6.Start
    EPSILON => _Exp5.Start
        SHIFT [_Exp6.Start => _Exp6.1] 
    EPSILON => _Exp6.Start
        SHIFT [_Exp6.Start => _Exp6.2] 

@ <_EnumItemA>
STATE _EnumItemA.Start
    [NAME] => _EnumItemA.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_EnumItemA.Start => _EnumItemA.2] 

<_Attribute>: "@" NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute@
END STATE _Attribute.6
    TOKEN-FINISH => _Attribute.RootEnd
    NORMAL-REDUCE => _FunctionArgument.2
        REDUCE [_FunctionArgument.Start => _FunctionArgument.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _FunctionArgument.2
        REDUCE [_FunctionArgument.2 => _FunctionArgument.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _EnumItemA.2
        REDUCE [_EnumItemA.Start => _EnumItemA.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _EnumItemA.2
        REDUCE [_EnumItemA.2 => _EnumItemA.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _EnumItemB.2
        REDUCE [_EnumItemB.Start => _EnumItemB.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _EnumItemB.2
        REDUCE [_EnumItemB.2 => _EnumItemB.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _StructMember.2
        REDUCE [_StructMember.Start => _StructMember.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _StructMember.2
        REDUCE [_StructMember.2 => _StructMember.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _Declaration.2
        REDUCE [_Declaration.Start => _Declaration.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _Declaration.3
        REDUCE [_Declaration.Start => _Declaration.3] 
        ASSIGN attributes
    NORMAL-REDUCE => _Declaration.2
        REDUCE [_Declaration.2 => _Declaration.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _Declaration.3
        REDUCE [_Declaration.3 => _Declaration.3] 
        ASSIGN attributes
    NORMAL-REDUCE => _MemberDeclaration.2
        REDUCE [_MemberDeclaration.Start => _MemberDeclaration.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _MemberDeclaration.4
        REDUCE [_MemberDeclaration.Start => _MemberDeclaration.4] 
        ASSIGN attributes
    NORMAL-REDUCE => _MemberDeclaration.2
        REDUCE [_MemberDeclaration.2 => _MemberDeclaration.2] 
        ASSIGN attributes
    NORMAL-REDUCE => _MemberDeclaration.4
        REDUCE [_MemberDeclaration.4 => _MemberDeclaration.4] 
        ASSIGN attributes

<_Attribute>: "@" NAME : category ":" NAME : name [ "("@ _Expression : value ")" ] as Attribute
STATE _Attribute.5
    EPSILON => _Expression.Start
        SHIFT [_Attribute.5 => _Attribute.7] 

@ <_Exp2>
STATE _Exp2.Start
    EPSILON => _Exp1.Start
        SHIFT [_Exp2.Start => _Exp2.1] 
    EPSILON => _Exp2.Start
        SHIFT [_Exp2.Start => _Exp2.2] 

<_Exp4>: _Exp4 : first "shl"@ _Exp3 : second as BinaryExpression with { op = "Shl" }
<_Exp4>: _Exp4 : first "shr"@ _Exp3 : second as BinaryExpression with { op = "Shr" }
STATE _Exp4.3
    EPSILON => _Exp3.Start
        SHIFT [_Exp4.3 => _Exp4.4] 

<_Exp5>: _Exp5 : first@ "<" _Exp4 : second as BinaryExpression with { op = "LT" }
<_Exp5>: _Exp5 : first@ ">" _Exp4 : second as BinaryExpression with { op = "GT" }
<_Exp5>: _Exp5 : first@ "<=" _Exp4 : second as BinaryExpression with { op = "LE" }
<_Exp5>: _Exp5 : first@ ">=" _Exp4 : second as BinaryExpression with { op = "GE" }
<_Exp5>: _Exp5 : first@ "==" _Exp4 : second as BinaryExpression with { op = "EQ" }
<_Exp5>: _Exp5 : first@ "!=" _Exp4 : second as BinaryExpression with { op = "NE" }
STATE _Exp5.2
    [LT "<"] => _Exp5.3
        CREATE BinaryExpression
        SET op => LT
    [GT ">"] => _Exp5.3
        CREATE BinaryExpression
        SET op => GT
    [LE "<="] => _Exp5.3
        CREATE BinaryExpression
        SET op => LE
    [GE ">="] => _Exp5.3
        CREATE BinaryExpression
        SET op => GE
    [EQ "=="] => _Exp5.3
        CREATE BinaryExpression
        SET op => EQ
    [NE "!="] => _Exp5.3
        CREATE BinaryExpression
        SET op => NE

$<_Exp5> @
STATE _Exp5.RootEnd

<_Exp6>: !_Exp5@
<_Exp6>: _Exp6 : first "xor" _Exp5 : second as BinaryExpression with { op = "Xor" }@
END STATE _Exp6.1
    NORMAL-REDUCE => _Exp6.2
        REDUCE [_Exp6.Start => _Exp6.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp6.RootEnd
    NORMAL-REDUCE => _Exp7.1
        REDUCE [_Exp7.Start => _Exp7.1] 
        USING 
    NORMAL-REDUCE => _Exp7.4
        REDUCE [_Exp7.3 => _Exp7.4] 
        ASSIGN second

<_Exp6>: _Exp6 : first "xor" _Exp5 : second as BinaryExpression@ with { op = "Xor" }
STATE _Exp6.4
    EPSILON => _Exp6.1
        CREATE BinaryExpression
        SET op => Xor

$<_Namespace> @
STATE _Namespace.RootEnd

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default"@ ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.18
    [COLON ":"] => _VirtualStatement.21

@ <_SwitchCase>
STATE _SwitchCase.Start
    [KEYWORD_CASE "case"] => _SwitchCase.1

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name@ ")" _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.16
    [CLOSE_BRACKET ")"] => _Statement.17

<_If>: "if" "(" [ "var" NAME : name@ ":" _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.5
    [COLON ":"] => _If.7

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) )@ _Expression : collection ")" _Block : statement as ForEachStatement
<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) )@ _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.14
    EPSILON => _Expression.Start
        SHIFT [_VirtualStatement.14 => _VirtualStatement.17] 

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in"@ "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.15
    [KEYWORD_REVERSED "reversed"] => _VirtualStatement.14
        SET direction => Reversed

@ <_Exp5>
STATE _Exp5.Start
    EPSILON => _Exp4.Start
        SHIFT [_Exp5.Start => _Exp5.1] 
    EPSILON => _Exp5.Start
        SHIFT [_Exp5.Start => _Exp5.2] 

<_EnumItemA>: { _Attribute : attributes } NAME : name@ "=" INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.1
    [ASSIGN "="] => _EnumItemA.3

$<_Attribute> @
STATE _Attribute.RootEnd

<_FunctionArgument>: @{ _Attribute : attributes } NAME : name ":" _Type : type as FunctionArgument
STATE _FunctionArgument.2
    [NAME] => _FunctionArgument.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_FunctionArgument.2 => _FunctionArgument.2] 

<_EnumItemA>: @{ _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.2
    [NAME] => _EnumItemA.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_EnumItemA.2 => _EnumItemA.2] 

<_EnumItemB>: @{ _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.2
    [NAME] => _EnumItemB.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_EnumItemB.2 => _EnumItemB.2] 

<_StructMember>: @{ _Attribute : attributes } NAME : name ":" _Type : type ";" as StructMember
STATE _StructMember.2
    [NAME] => _StructMember.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_StructMember.2 => _StructMember.2] 

<_Declaration>: @{ _Attribute : attributes } !_SharedDeclarationBranch
STATE _Declaration.2
    EPSILON => _Attribute.Start
        SHIFT [_Declaration.2 => _Declaration.2] 
    EPSILON => _SharedDeclarationBranch.Start
        SHIFT [_Declaration.2 => _Declaration.1] 

<_Declaration>: @{ _Attribute : attributes } !_MemberDeclarationBranch
STATE _Declaration.3
    EPSILON => _Attribute.Start
        SHIFT [_Declaration.3 => _Declaration.3] 
    EPSILON => _MemberDeclarationBranch.Start
        SHIFT [_Declaration.3 => _Declaration.1] 

<_MemberDeclaration>: @{ _Attribute : attributes } !_SharedDeclarationBranch
STATE _MemberDeclaration.2
    EPSILON => _Attribute.Start
        SHIFT [_MemberDeclaration.2 => _MemberDeclaration.2] 
    EPSILON => _SharedDeclarationBranch.Start
        SHIFT [_MemberDeclaration.2 => _MemberDeclaration.1] 

<_MemberDeclaration>: @{ _Attribute : attributes } [ _ClassMember : classMember ] !_MemberDeclarationBranch
STATE _MemberDeclaration.4
    EPSILON => _Attribute.Start
        SHIFT [_MemberDeclaration.4 => _MemberDeclaration.4] 
    EPSILON => _ClassMember.Start
        SHIFT [_MemberDeclaration.4 => _MemberDeclaration.3] 
    EPSILON => _MemberDeclarationBranch.Start
        SHIFT [_MemberDeclaration.4 => _MemberDeclaration.1] 

@ <_Exp3>
STATE _Exp3.Start
    EPSILON => _Exp2.Start
        SHIFT [_Exp3.Start => _Exp3.1] 
    EPSILON => _Exp3.Start
        SHIFT [_Exp3.Start => _Exp3.2] 

<_Exp5>: _Exp5 : first "<"@ _Exp4 : second as BinaryExpression with { op = "LT" }
<_Exp5>: _Exp5 : first ">"@ _Exp4 : second as BinaryExpression with { op = "GT" }
<_Exp5>: _Exp5 : first "<="@ _Exp4 : second as BinaryExpression with { op = "LE" }
<_Exp5>: _Exp5 : first ">="@ _Exp4 : second as BinaryExpression with { op = "GE" }
<_Exp5>: _Exp5 : first "=="@ _Exp4 : second as BinaryExpression with { op = "EQ" }
<_Exp5>: _Exp5 : first "!="@ _Exp4 : second as BinaryExpression with { op = "NE" }
STATE _Exp5.3
    EPSILON => _Exp4.Start
        SHIFT [_Exp5.3 => _Exp5.4] 

<_Exp6>: _Exp6 : first@ "xor" _Exp5 : second as BinaryExpression with { op = "Xor" }
STATE _Exp6.2
    [KEYWORD_XOR "xor"] => _Exp6.3

$<_Exp6> @
STATE _Exp6.RootEnd

<_Exp7>: !_Exp6@
<_Exp7>: _Exp7 : first "and" _Exp6 : second as BinaryExpression with { op = "And" }@
END STATE _Exp7.1
    NORMAL-REDUCE => _Exp7.2
        REDUCE [_Exp7.Start => _Exp7.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp7.RootEnd
    NORMAL-REDUCE => _Exp8.1
        REDUCE [_Exp8.Start => _Exp8.1] 
        USING 
    NORMAL-REDUCE => _Exp8.4
        REDUCE [_Exp8.3 => _Exp8.4] 
        ASSIGN second

<_Exp7>: _Exp7 : first "and" _Exp6 : second as BinaryExpression@ with { op = "And" }
STATE _Exp7.4
    EPSILON => _Exp7.1
        CREATE BinaryExpression
        SET op => And

<_VirtualStatement>: "switch" "(" _Expression : expression ")" "{" { _SwitchCase : caseBranches } [ "default" ":"@ _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.21
    EPSILON => _Block.Start
        SHIFT [_VirtualStatement.21 => _VirtualStatement.23] 

<_SwitchCase>: "case"@ _Expression : expression ":" _Block : statement as SwitchCase
STATE _SwitchCase.1
    EPSILON => _Expression.Start
        SHIFT [_SwitchCase.1 => _SwitchCase.2] 

<_Statement>: "try" _Block : protectedStatement [ "catch" "(" NAME : name ")"@ _Block : catchStatement ] [ "finally" _Block : finallyStatement ] as TryStatement
STATE _Statement.17
    EPSILON => _Block.Start
        SHIFT [_Statement.17 => _Statement.18] 

<_If>: "if" "(" [ "var" NAME : name ":"@ _Type : type "=" ] _Expression : expression ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.7
    EPSILON => _Type.Start
        SHIFT [_If.7 => _If.9] 

@ <_Exp4>
STATE _Exp4.Start
    EPSILON => _Exp3.Start
        SHIFT [_Exp4.Start => _Exp4.1] 
    EPSILON => _Exp4.Start
        SHIFT [_Exp4.Start => _Exp4.2] 

<_EnumItemA>: { _Attribute : attributes } NAME : name "="@ INTEGER : number "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.3
    [INTEGER] => _EnumItemA.4
        ASSIGN number

<_EnumItemB>: { _Attribute : attributes } NAME : name@ "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.1
    [ASSIGN "="] => _EnumItemB.3

<_Exp6>: _Exp6 : first "xor"@ _Exp5 : second as BinaryExpression with { op = "Xor" }
STATE _Exp6.3
    EPSILON => _Exp5.Start
        SHIFT [_Exp6.3 => _Exp6.4] 

<_Exp7>: _Exp7 : first@ "and" _Exp6 : second as BinaryExpression with { op = "And" }
STATE _Exp7.2
    [KEYWORD_AND "and"] => _Exp7.3

$<_Exp7> @
STATE _Exp7.RootEnd

<_Exp8>: !_Exp7@
<_Exp8>: _Exp8 : first "or" _Exp7 : second as BinaryExpression with { op = "Or" }@
END STATE _Exp8.1
    NORMAL-REDUCE => _Exp8.2
        REDUCE [_Exp8.Start => _Exp8.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp8.RootEnd
    NORMAL-REDUCE => _Exp9.1
        REDUCE [_Exp9.Start => _Exp9.1] 
        USING 
    NORMAL-REDUCE => _Exp9.4
        REDUCE [_Exp9.3 => _Exp9.4] 
        ASSIGN second

<_Exp8>: _Exp8 : first "or" _Exp7 : second as BinaryExpression@ with { op = "Or" }
STATE _Exp8.4
    EPSILON => _Exp8.1
        CREATE BinaryExpression
        SET op => Or

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number@ "," as EnumItem with { kind = "Constant" }
STATE _EnumItemA.4
    [COMMA ","] => _EnumItemA.5

<_EnumItemB>: { _Attribute : attributes } NAME : name "="@ _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|"@ _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.3
    EPSILON => _EnumItemInt.Start
        SHIFT [_EnumItemB.3 => _EnumItemB.4] 

<_Exp7>: _Exp7 : first "and"@ _Exp6 : second as BinaryExpression with { op = "And" }
STATE _Exp7.3
    EPSILON => _Exp6.Start
        SHIFT [_Exp7.3 => _Exp7.4] 

<_Exp8>: _Exp8 : first@ "or" _Exp7 : second as BinaryExpression with { op = "Or" }
STATE _Exp8.2
    [KEYWORD_OR "or"] => _Exp8.3

$<_Exp8> @
STATE _Exp8.RootEnd

<_Exp9>: !_Exp8@
<_Exp9>: _Exp9 : first "??" _Exp8 : second as BinaryExpression with { op = "FailedThen" }@
END STATE _Exp9.1
    NORMAL-REDUCE => _Exp9.2
        REDUCE [_Exp9.Start => _Exp9.2] 
        ASSIGN first
    TOKEN-FINISH => _Exp9.RootEnd
    NORMAL-REDUCE => _Exp10.1
        REDUCE [_Exp10.Start => _Exp10.1] 
        USING 
    NORMAL-REDUCE => _Exp10.2
        REDUCE [_Exp10.Start => _Exp10.2] 
        ASSIGN condition

<_Exp9>: _Exp9 : first "??" _Exp8 : second as BinaryExpression@ with { op = "FailedThen" }
STATE _Exp9.4
    EPSILON => _Exp9.1
        CREATE BinaryExpression
        SET op => FailedThen

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem@ with { kind = "Constant" }
STATE _EnumItemA.5
    EPSILON => _EnumItemA.6
        CREATE EnumItem
        SET kind => Constant

@ <_EnumItemInt>
STATE _EnumItemInt.Start
    [NAME] => _EnumItemInt.1
        ASSIGN name

<_Exp8>: _Exp8 : first "or"@ _Exp7 : second as BinaryExpression with { op = "Or" }
STATE _Exp8.3
    EPSILON => _Exp7.Start
        SHIFT [_Exp8.3 => _Exp8.4] 

<_Exp9>: _Exp9 : first@ "??" _Exp8 : second as BinaryExpression with { op = "FailedThen" }
STATE _Exp9.2
    [FAILED_THEN "??"] => _Exp9.3

$<_Exp9> @
STATE _Exp9.RootEnd

<_Exp10>: !_Exp9@
<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression@
END STATE _Exp10.1
    TOKEN-FINISH => _Exp10.RootEnd
    NORMAL-REDUCE => _Exp10.4
        REDUCE [_Exp10.3 => _Exp10.4] 
        ASSIGN trueBranch
    NORMAL-REDUCE => _Exp10.6
        REDUCE [_Exp10.5 => _Exp10.6] 
        ASSIGN falseBranch
    NORMAL-REDUCE => _Exp11.1
        REDUCE [_Exp11.Start => _Exp11.1] 
        USING 
    NORMAL-REDUCE => _Exp11.2
        REDUCE [_Exp11.Start => _Exp11.2] 
        ASSIGN first

<_Exp10>: _Exp9 : condition@ "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.2
    [QUESTION_MARK "?"] => _Exp10.3

<_EnumItemA>: { _Attribute : attributes } NAME : name "=" INTEGER : number "," as EnumItem with { kind = "Constant" }@
END STATE _EnumItemA.6
    TOKEN-FINISH => _EnumItemA.RootEnd
    NORMAL-REDUCE => _Enum.7
        REDUCE [_Enum.5 => _Enum.7] 
        ASSIGN items
    NORMAL-REDUCE => _Enum.8
        REDUCE [_Enum.6 => _Enum.8] 
        ASSIGN items
    NORMAL-REDUCE => _Enum.7
        REDUCE [_Enum.7 => _Enum.7] 
        ASSIGN items
    NORMAL-REDUCE => _Enum.8
        REDUCE [_Enum.8 => _Enum.8] 
        ASSIGN items

<_EnumItemInt>: NAME : name as EnumItemIntersection@
STATE _EnumItemInt.1
    EPSILON => _EnumItemInt.2
        CREATE EnumItemIntersection

<_Exp9>: _Exp9 : first "??"@ _Exp8 : second as BinaryExpression with { op = "FailedThen" }
STATE _Exp9.3
    EPSILON => _Exp8.Start
        SHIFT [_Exp9.3 => _Exp9.4] 

$<_Exp10> @
STATE _Exp10.RootEnd

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch@ ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.4
    [COLON ":"] => _Exp10.5

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression@
STATE _Exp10.6
    EPSILON => _Exp10.1
        CREATE IfExpression

<_Exp11>: !_Exp10@
<_Exp11>: _Exp10 : first "=" _Exp11 : second as BinaryExpression with { op = "Assign" }@
END STATE _Exp11.1
    TOKEN-FINISH => _Exp11.RootEnd
    NORMAL-REDUCE => _Exp11.4
        REDUCE [_Exp11.3 => _Exp11.4] 
        ASSIGN second
    NORMAL-REDUCE => _Expression.1
        REDUCE [_Expression.Start => _Expression.1] 
        USING 

<_Exp11>: _Exp10 : first@ "=" _Exp11 : second as BinaryExpression with { op = "Assign" }
STATE _Exp11.2
    [ASSIGN "="] => _Exp11.3

<_Exp10>: _Exp9 : condition "?"@ _Exp10 : trueBranch ":" _Exp10 : falseBranch as IfExpression
STATE _Exp10.3
    EPSILON => _Exp10.Start
        SHIFT [_Exp10.3 => _Exp10.4] 

$<_EnumItemA> @
STATE _EnumItemA.RootEnd

<_Enum>: "enum" NAME : name "{" _EnumItemA : items@ { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
<_Enum>: "enum" NAME : name "{" _EnumItemA : items @{ _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }
STATE _Enum.7
    [CLOSE_BRACE "}"] => _Enum.9
        SET kind => Normal
        CREATE EnumDeclaration
    EPSILON => _EnumItemA.Start
        SHIFT [_Enum.7 => _Enum.7] 

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items@ { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items @{ _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.8
    [CLOSE_BRACE "}"] => _Enum.9
        SET kind => Flag
        CREATE EnumDeclaration
    EPSILON => _EnumItemA.Start
        SHIFT [_Enum.8 => _Enum.8] 
    EPSILON => _EnumItemB.Start
        SHIFT [_Enum.8 => _Enum.10] 

<_EnumItemInt>: NAME : name as EnumItemIntersection@
END STATE _EnumItemInt.2
    TOKEN-FINISH => _EnumItemInt.RootEnd
    NORMAL-REDUCE => _EnumItemB.4
        REDUCE [_EnumItemB.3 => _EnumItemB.4] 
        ASSIGN intersections

<_Exp10>: _Exp9 : condition "?" _Exp10 : trueBranch ":"@ _Exp10 : falseBranch as IfExpression
STATE _Exp10.5
    EPSILON => _Exp10.Start
        SHIFT [_Exp10.5 => _Exp10.6] 

$<_Exp11> @
STATE _Exp11.RootEnd

<_Exp11>: _Exp10 : first "=" _Exp11 : second as BinaryExpression@ with { op = "Assign" }
STATE _Exp11.4
    EPSILON => _Exp11.1
        CREATE BinaryExpression
        SET op => Assign

<_Expression>: !_Exp11@
END STATE _Expression.1
    NORMAL-REDUCE => _CtorFragment.1
        REDUCE [_CtorFragment.Start => _CtorFragment.1] 
        ASSIGN key
    NORMAL-REDUCE => _CtorFragment.4
        REDUCE [_CtorFragment.2 => _CtorFragment.4] 
        ASSIGN value
    NORMAL-REDUCE => _LetVariable.3
        REDUCE [_LetVariable.2 => _LetVariable.3] 
        ASSIGN value
    NORMAL-REDUCE => _VirtualExpression.9
        REDUCE [_VirtualExpression.6 => _VirtualExpression.9] 
        ASSIGN expression
    NORMAL-REDUCE => _VirtualExpression.9
        REDUCE [_VirtualExpression.13 => _VirtualExpression.9] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.24
        REDUCE [_ExpPrimitive.2 => _ExpPrimitive.24] 
        USING 
    NORMAL-REDUCE => _ExpPrimitive.25
        REDUCE [_ExpPrimitive.3 => _ExpPrimitive.25] 
        ASSIGN body
    NORMAL-REDUCE => _ExpPrimitive.47
        REDUCE [_ExpPrimitive.27 => _ExpPrimitive.47] 
        ASSIGN begin
    NORMAL-REDUCE => _ExpPrimitive.51
        REDUCE [_ExpPrimitive.31 => _ExpPrimitive.51] 
        ASSIGN arguments
    NORMAL-REDUCE => _ExpPrimitive.25
        REDUCE [_ExpPrimitive.34 => _ExpPrimitive.25] 
        ASSIGN second
    NORMAL-REDUCE => _ExpPrimitive.1
        REDUCE [_ExpPrimitive.35 => _ExpPrimitive.1] 
        ASSIGN collection
    NORMAL-REDUCE => _ExpPrimitive.63
        REDUCE [_ExpPrimitive.43 => _ExpPrimitive.63] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.53
        REDUCE [_ExpPrimitive.44 => _ExpPrimitive.53] 
        ASSIGN event
    NORMAL-REDUCE => _ExpPrimitive.54
        REDUCE [_ExpPrimitive.45 => _ExpPrimitive.54] 
        ASSIGN event
    NORMAL-REDUCE => _ExpPrimitive.57
        REDUCE [_ExpPrimitive.48 => _ExpPrimitive.57] 
        ASSIGN arguments
    NORMAL-REDUCE => _ExpPrimitive.63
        REDUCE [_ExpPrimitive.55 => _ExpPrimitive.63] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.64
        REDUCE [_ExpPrimitive.56 => _ExpPrimitive.64] 
        ASSIGN end
    NORMAL-REDUCE => _ExpPrimitive.66
        REDUCE [_ExpPrimitive.58 => _ExpPrimitive.66] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.51
        REDUCE [_ExpPrimitive.60 => _ExpPrimitive.51] 
        ASSIGN arguments
    NORMAL-REDUCE => _ExpPrimitive.63
        REDUCE [_ExpPrimitive.61 => _ExpPrimitive.63] 
        ASSIGN function
    NORMAL-REDUCE => _ExpPrimitive.63
        REDUCE [_ExpPrimitive.62 => _ExpPrimitive.63] 
        ASSIGN handler
    NORMAL-REDUCE => _ExpPrimitive.57
        REDUCE [_ExpPrimitive.65 => _ExpPrimitive.57] 
        ASSIGN arguments
    NORMAL-REDUCE => _ExpPrimitive.70
        REDUCE [_ExpPrimitive.68 => _ExpPrimitive.70] 
        ASSIGN events
    NORMAL-REDUCE => _ExpPrimitive.71
        REDUCE [_ExpPrimitive.69 => _ExpPrimitive.71] 
        ASSIGN expression
    NORMAL-REDUCE => _ExpPrimitive.73
        REDUCE [_ExpPrimitive.72 => _ExpPrimitive.73] 
        ASSIGN events
    TOKEN-FINISH => _Expression.RootEnd
    NORMAL-REDUCE => _SwitchCase.2
        REDUCE [_SwitchCase.1 => _SwitchCase.2] 
        ASSIGN expression
    NORMAL-REDUCE => _If.4
        REDUCE [_If.2 => _If.4] 
        ASSIGN expression
    NORMAL-REDUCE => _If.4
        REDUCE [_If.12 => _If.4] 
        ASSIGN expression
    NORMAL-REDUCE => _VirtualStatement.8
        REDUCE [_VirtualStatement.4 => _VirtualStatement.8] 
        ASSIGN arguments
    NORMAL-REDUCE => _VirtualStatement.9
        REDUCE [_VirtualStatement.5 => _VirtualStatement.9] 
        ASSIGN expression
    NORMAL-REDUCE => _VirtualStatement.8
        REDUCE [_VirtualStatement.12 => _VirtualStatement.8] 
        ASSIGN arguments
    NORMAL-REDUCE => _VirtualStatement.17
        REDUCE [_VirtualStatement.14 => _VirtualStatement.17] 
        ASSIGN collection
    NORMAL-REDUCE => _Statement.3
        REDUCE [_Statement.Start => _Statement.3] 
        ASSIGN expression
        CREATE ExpressionStatement
    NORMAL-REDUCE => _Statement.3
        REDUCE [_Statement.4 => _Statement.3] 
        ASSIGN expression
        CREATE ReturnStatement
    NORMAL-REDUCE => _Statement.3
        REDUCE [_Statement.5 => _Statement.3] 
        ASSIGN expression
        CREATE DeleteStatement
    NORMAL-REDUCE => _Statement.3
        REDUCE [_Statement.6 => _Statement.3] 
        ASSIGN expression
        CREATE RaiseExceptionStatement
    NORMAL-REDUCE => _Statement.11
        REDUCE [_Statement.9 => _Statement.11] 
        ASSIGN condition
    NORMAL-REDUCE => _Attribute.7
        REDUCE [_Attribute.5 => _Attribute.7] 
        ASSIGN value
    NORMAL-REDUCE => _Variable.6
        REDUCE [_Variable.4 => _Variable.6] 
        ASSIGN expression
    NORMAL-REDUCE => _BaseConstructorCall.3
        REDUCE [_BaseConstructorCall.2 => _BaseConstructorCall.3] 
        ASSIGN arguments
    NORMAL-REDUCE => _BaseConstructorCall.3
        REDUCE [_BaseConstructorCall.5 => _BaseConstructorCall.3] 
        ASSIGN arguments
    NORMAL-REDUCE => _AutoProperty.7
        REDUCE [_AutoProperty.5 => _AutoProperty.7] 
        ASSIGN expression

<_Exp11>: _Exp10 : first "="@ _Exp11 : second as BinaryExpression with { op = "Assign" }
STATE _Exp11.3
    EPSILON => _Exp11.Start
        SHIFT [_Exp11.3 => _Exp11.4] 

<_Enum>: "enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration@ with { kind = "Normal" }
<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration@ with { kind = "Flag" }
STATE _Enum.9
    EPSILON => _Enum.11

@ <_EnumItemB>
STATE _EnumItemB.Start
    [NAME] => _EnumItemB.1
        ASSIGN name
    EPSILON => _Attribute.Start
        SHIFT [_EnumItemB.Start => _EnumItemB.2] 

$<_EnumItemInt> @
STATE _EnumItemInt.RootEnd

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections@ { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections @{ "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }
STATE _EnumItemB.4
    [COMMA ","] => _EnumItemB.5
    [INTERSECTION "|"] => _EnumItemB.3

<_CtorFragment>: _Expression : key@ [ ":" _Expression : value ] as ConstructorArgument
STATE _CtorFragment.1
    EPSILON => _CtorFragment.3
        CREATE ConstructorArgument
    [COLON ":"] => _CtorFragment.2

<_CtorFragment>: _Expression : key [ ":" _Expression : value ] as ConstructorArgument@
STATE _CtorFragment.4
    EPSILON => _CtorFragment.3
        CREATE ConstructorArgument

<_LetVariable>: NAME : name "=" _Expression : value as LetVariable@
STATE _LetVariable.3
    EPSILON => _LetVariable.4
        CREATE LetVariable

<_VirtualExpression>: "bind" "(" _Expression : expression@ ")" as BindExpression
<_VirtualExpression>: "new" _Type : type "(" "using" _Expression : expression@ ")" as MixinCastExpression
STATE _VirtualExpression.9
    [CLOSE_BRACKET ")"] => _VirtualExpression.1

<_ExpPrimitive>: "(" !_Expression@ ")"
STATE _ExpPrimitive.24
    [CLOSE_BRACKET ")"] => _ExpPrimitive.23

<_ExpPrimitive>: "[" _Expression : body@ "]" as OrderedLambdaExpression
<_ExpPrimitive>: _ExpPrimitive : first "[" _Expression : second@ "]" as BinaryExpression with { op = "Index" }
STATE _ExpPrimitive.25
    [CLOSE_ARRAY "]"] => _ExpPrimitive.1

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin@ "," _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.47
    [COMMA ","] => _ExpPrimitive.56

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments@ { "," _Expression : arguments } ] ")" as CallExpression
<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments @{ "," _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.51
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        CREATE CallExpression
    [COMMA ","] => _ExpPrimitive.60

<_ExpPrimitive>: "attach" "(" _Expression : event@ "," _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.53
    [COMMA ","] => _ExpPrimitive.61
        CREATE AttachEventExpression

<_ExpPrimitive>: "detach" "(" _Expression : event@ "," _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.54
    [COMMA ","] => _ExpPrimitive.62
        CREATE DetachEventExpression

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments@ { "," _Expression : arguments } ] ")" as NewClassExpression
<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments @{ "," _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.57
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        CREATE NewClassExpression
    [COMMA ","] => _ExpPrimitive.65

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin "," _Expression : end@ ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.64
    [CLOSE_ARRAY "]"] => _ExpPrimitive.1
        SET endBoundary => Inclusive
        CREATE RangeExpression
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        SET endBoundary => Exclusive
        CREATE RangeExpression

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression@ [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.66
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        SET observeType => SimpleObserve
        CREATE ObserveExpression
    [KEYWORD_ON "on"] => _ExpPrimitive.68

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events@ { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events @{ "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.70
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        SET observeType => SimpleObserve
        CREATE ObserveExpression
    [COMMA ","] => _ExpPrimitive.68

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression@ [ "on" _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.71
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        SET observeType => ExtendedObserve
        CREATE ObserveExpression
    [KEYWORD_ON "on"] => _ExpPrimitive.72

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events@ { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events @{ "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.73
    [CLOSE_BRACKET ")"] => _ExpPrimitive.1
        SET observeType => ExtendedObserve
        CREATE ObserveExpression
    [COMMA ","] => _ExpPrimitive.72

$<_Expression> @
STATE _Expression.RootEnd

<_SwitchCase>: "case" _Expression : expression@ ":" _Block : statement as SwitchCase
STATE _SwitchCase.2
    [COLON ":"] => _SwitchCase.3

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression@ ")" _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.4
    [CLOSE_BRACKET ")"] => _If.6

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments@ { "," _Expression : arguments } ] ";" as CoOperatorStatement
<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments @{ "," _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.8
    [COMMA ","] => _VirtualStatement.12
    [SEMICOLON ";"] => _VirtualStatement.19
        CREATE CoOperatorStatement

<_VirtualStatement>: "switch" "(" _Expression : expression@ ")" "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.9
    [CLOSE_BRACKET ")"] => _VirtualStatement.13

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection@ ")" _Block : statement as ForEachStatement
STATE _VirtualStatement.17
    [CLOSE_BRACKET ")"] => _VirtualStatement.20

<_Statement>: "while" "(" _Expression : condition@ ")" _Block : statement as WhileStatement
STATE _Statement.11
    [CLOSE_BRACKET ")"] => _Statement.14
        CREATE WhileStatement

<_Attribute>: "@" NAME : category ":" NAME : name [ "(" _Expression : value@ ")" ] as Attribute
STATE _Attribute.7
    [CLOSE_BRACKET ")"] => _Attribute.8

<_Variable>: "var" NAME : name [ ":" _Type : type ] "=" _Expression : expression@ ";" as VariableDeclaration
STATE _Variable.6
    [SEMICOLON ";"] => _Variable.7

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments@ { "," _Expression : arguments } ] ")" as BaseConstructorCall
<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments @{ "," _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.3
    [CLOSE_BRACKET ")"] => _BaseConstructorCall.4
    [COMMA ","] => _BaseConstructorCall.5

<_AutoProperty>: "prop" NAME : name ":" _Type : type [ "=" _Expression : expression ]@ !_APConfig
STATE _AutoProperty.7
    EPSILON => _APConfig.Start
        SHIFT [_AutoProperty.7 => _AutoProperty.6] 

<_Enum>: "enum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } "}" as EnumDeclaration with { kind = "Normal" }@
<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } { _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }@
END STATE _Enum.11
    TOKEN-FINISH => _Enum.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem@ with { kind = "Intersection" }
STATE _EnumItemB.5
    EPSILON => _EnumItemB.6
        CREATE EnumItem
        SET kind => Intersection

<_CtorFragment>: _Expression : key [ ":" _Expression : value ] as ConstructorArgument@
END STATE _CtorFragment.3
    TOKEN-FINISH => _CtorFragment.RootEnd
    NORMAL-REDUCE => _ExpPrimitive.6
        REDUCE [_ExpPrimitive.6 => _ExpPrimitive.6] 
        ASSIGN arguments

<_CtorFragment>: _Expression : key [ ":"@ _Expression : value ] as ConstructorArgument
STATE _CtorFragment.2
    EPSILON => _Expression.Start
        SHIFT [_CtorFragment.2 => _CtorFragment.4] 

<_LetVariable>: NAME : name "=" _Expression : value as LetVariable@
END STATE _LetVariable.4
    TOKEN-FINISH => _LetVariable.RootEnd
    NORMAL-REDUCE => _ExpPrimitive.26
        REDUCE [_ExpPrimitive.4 => _ExpPrimitive.26] 
        ASSIGN variables

<_ExpPrimitive>: "range" ( ( "(" with { beginBoundary = "Exclusive" } ) | ( "[" with { beginBoundary = "Inclusive" } ) ) _Expression : begin ","@ _Expression : end ( ( ")" with { endBoundary = "Exclusive" } ) | ( "]" with { endBoundary = "Inclusive" } ) ) as RangeExpression
STATE _ExpPrimitive.56
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.56 => _ExpPrimitive.64] 

<_ExpPrimitive>: _ExpPrimitive : function "(" [ _Expression : arguments { ","@ _Expression : arguments } ] ")" as CallExpression
STATE _ExpPrimitive.60
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.60 => _ExpPrimitive.51] 

<_ExpPrimitive>: "attach" "(" _Expression : event ","@ _Expression : function ")" as AttachEventExpression
STATE _ExpPrimitive.61
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.61 => _ExpPrimitive.63] 

<_ExpPrimitive>: "detach" "(" _Expression : event ","@ _Expression : handler ")" as DetachEventExpression
STATE _ExpPrimitive.62
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.62 => _ExpPrimitive.63] 

<_ExpPrimitive>: "new" _Type : type "(" [ _Expression : arguments { ","@ _Expression : arguments } ] ")" as NewClassExpression
STATE _ExpPrimitive.65
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.65 => _ExpPrimitive.57] 

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on"@ _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "(" _Expression : expression [ "on" _Expression : events { ","@ _Expression : events } ] ")" as ObserveExpression with { observeType = "SimpleObserve" }
STATE _ExpPrimitive.68
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.68 => _ExpPrimitive.70] 

<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on"@ _Expression : events { "," _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
<_ExpPrimitive>: _ExpPrimitive : parent "." "observe" "as" NAME : name "(" _Expression : expression [ "on" _Expression : events { ","@ _Expression : events } ] ")" as ObserveExpression with { observeType = "ExtendedObserve" }
STATE _ExpPrimitive.72
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.72 => _ExpPrimitive.73] 

<_SwitchCase>: "case" _Expression : expression ":"@ _Block : statement as SwitchCase
STATE _SwitchCase.3
    EPSILON => _Block.Start
        SHIFT [_SwitchCase.3 => _SwitchCase.4] 

<_If>: "if" "(" [ "var" NAME : name ":" _Type : type "=" ] _Expression : expression ")"@ _Block : trueBranch [ "else" ( _Block : falseBranch | _If : falseBranch ) ] as IfStatement
STATE _If.6
    EPSILON => _Block.Start
        SHIFT [_If.6 => _If.8] 

<_VirtualStatement>: [ "var" NAME : varName "=" ] COROUTINE_OPERATOR : opName [ _Expression : arguments { ","@ _Expression : arguments } ] ";" as CoOperatorStatement
STATE _VirtualStatement.12
    EPSILON => _Expression.Start
        SHIFT [_VirtualStatement.12 => _VirtualStatement.8] 

<_VirtualStatement>: "switch" "(" _Expression : expression ")"@ "{" { _SwitchCase : caseBranches } [ "default" ":" _Block : defaultBranch ] "}" as SwitchStatement
STATE _VirtualStatement.13
    [OPEN_BRACE "{"] => _VirtualStatement.16

<_VirtualStatement>: "for" "(" NAME : name ( ( "in" with { direction = "Normal" } ) | ( "in" "reversed" with { direction = "Reversed" } ) ) _Expression : collection ")"@ _Block : statement as ForEachStatement
STATE _VirtualStatement.20
    EPSILON => _Block.Start
        SHIFT [_VirtualStatement.20 => _VirtualStatement.19] 

<_Statement>: "while" "(" _Expression : condition ")"@ _Block : statement as WhileStatement
STATE _Statement.14
    EPSILON => _Block.Start
        SHIFT [_Statement.14 => _Statement.2] 

<_Attribute>: "@" NAME : category ":" NAME : name [ "(" _Expression : value ")" ] as Attribute@
STATE _Attribute.8
    EPSILON => _Attribute.6
        CREATE Attribute

<_Variable>: "var" NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration@
STATE _Variable.7
    EPSILON => _Variable.8
        CREATE VariableDeclaration

<_BaseConstructorCall>: _Type : type "(" [ _Expression : arguments { ","@ _Expression : arguments } ] ")" as BaseConstructorCall
STATE _BaseConstructorCall.5
    EPSILON => _Expression.Start
        SHIFT [_BaseConstructorCall.5 => _BaseConstructorCall.3] 

$<_Enum> @
STATE _Enum.RootEnd

<_EnumItemB>: { _Attribute : attributes } NAME : name "=" _EnumItemInt : intersections { "|" _EnumItemInt : intersections } "," as EnumItem with { kind = "Intersection" }@
END STATE _EnumItemB.6
    TOKEN-FINISH => _EnumItemB.RootEnd
    NORMAL-REDUCE => _Enum.10
        REDUCE [_Enum.8 => _Enum.10] 
        ASSIGN items
    NORMAL-REDUCE => _Enum.10
        REDUCE [_Enum.10 => _Enum.10] 
        ASSIGN items

$<_CtorFragment> @
STATE _CtorFragment.RootEnd

$<_LetVariable> @
STATE _LetVariable.RootEnd

<_ExpPrimitive>: "let" _LetVariable : variables@ { "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
<_ExpPrimitive>: "let" _LetVariable : variables @{ "," _LetVariable : variables } "in" "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.26
    [COMMA ","] => _ExpPrimitive.4
    [KEYWORD_IN "in"] => _ExpPrimitive.46

<_Variable>: "var" NAME : name [ ":" _Type : type ] "=" _Expression : expression ";" as VariableDeclaration@
END STATE _Variable.8
    NORMAL-REDUCE => _Statement.2
        REDUCE [_Statement.Start => _Statement.2] 
        ASSIGN variable
        CREATE VariableStatement
    TOKEN-FINISH => _Variable.RootEnd
    NORMAL-REDUCE => _SharedDeclarationBranch.1
        REDUCE [_SharedDeclarationBranch.Start => _SharedDeclarationBranch.1] 
        USING 

$<_EnumItemB> @
STATE _EnumItemB.RootEnd

<_Enum>: "flagenum" NAME : name "{" _EnumItemA : items { _EnumItemA : items } @{ _EnumItemB : items } "}" as EnumDeclaration with { kind = "Flag" }
STATE _Enum.10
    [CLOSE_BRACE "}"] => _Enum.9
        SET kind => Flag
        CREATE EnumDeclaration
    EPSILON => _EnumItemB.Start
        SHIFT [_Enum.10 => _Enum.10] 

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in"@ "(" _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.46
    [OPEN_BRACKET "("] => _ExpPrimitive.55
        CREATE LetExpression

$<_Variable> @
STATE _Variable.RootEnd

<_ExpPrimitive>: "let" _LetVariable : variables { "," _LetVariable : variables } "in" "("@ _Expression : expression ")" as LetExpression
STATE _ExpPrimitive.55
    EPSILON => _Expression.Start
        SHIFT [_ExpPrimitive.55 => _ExpPrimitive.63] 

--------------------------------
@ $<_CtorFragment>
STATE _CtorFragment.RootStart
    TOKEN-BEGIN => _CtorFragment.Start

--------------------------------
@ $<_LetVariable>
STATE _LetVariable.RootStart
    TOKEN-BEGIN => _LetVariable.Start

--------------------------------
@ $<_VirtualExpression>
STATE _VirtualExpression.RootStart
    TOKEN-BEGIN => _VirtualExpression.Start

--------------------------------
@ $<_ExpPrimitive>
STATE _ExpPrimitive.RootStart
    TOKEN-BEGIN => _ExpPrimitive.Start

--------------------------------
@ $<_Exp0>
STATE _Exp0.RootStart
    TOKEN-BEGIN => _Exp0.Start

--------------------------------
@ $<_Exp1>
STATE _Exp1.RootStart
    TOKEN-BEGIN => _Exp1.Start

--------------------------------
@ $<_Exp2>
STATE _Exp2.RootStart
    TOKEN-BEGIN => _Exp2.Start

--------------------------------
@ $<_Exp3>
STATE _Exp3.RootStart
    TOKEN-BEGIN => _Exp3.Start

--------------------------------
@ $<_Exp4>
STATE _Exp4.RootStart
    TOKEN-BEGIN => _Exp4.Start

--------------------------------
@ $<_Exp5>
STATE _Exp5.RootStart
    TOKEN-BEGIN => _Exp5.Start

--------------------------------
@ $<_Exp6>
STATE _Exp6.RootStart
    TOKEN-BEGIN => _Exp6.Start

--------------------------------
@ $<_Exp7>
STATE _Exp7.RootStart
    TOKEN-BEGIN => _Exp7.Start

--------------------------------
@ $<_Exp8>
STATE _Exp8.RootStart
    TOKEN-BEGIN => _Exp8.Start

--------------------------------
@ $<_Exp9>
STATE _Exp9.RootStart
    TOKEN-BEGIN => _Exp9.Start

--------------------------------
@ $<_Exp10>
STATE _Exp10.RootStart
    TOKEN-BEGIN => _Exp10.Start

--------------------------------
@ $<_Exp11>
STATE _Exp11.RootStart
    TOKEN-BEGIN => _Exp11.Start

--------------------------------
@ $<_Expression>
STATE _Expression.RootStart
    TOKEN-BEGIN => _Expression.Start

--------------------------------
@ $<_SwitchCase>
STATE _SwitchCase.RootStart
    TOKEN-BEGIN => _SwitchCase.Start

--------------------------------
@ $<_Block>
STATE _Block.RootStart
    TOKEN-BEGIN => _Block.Start

--------------------------------
@ $<_If>
STATE _If.RootStart
    TOKEN-BEGIN => _If.Start

--------------------------------
@ $<_VirtualStatement>
STATE _VirtualStatement.RootStart
    TOKEN-BEGIN => _VirtualStatement.Start

--------------------------------
@ $<_CoStatement>
STATE _CoStatement.RootStart
    TOKEN-BEGIN => _CoStatement.Start

--------------------------------
@ $<_CoProvider>
STATE _CoProvider.RootStart
    TOKEN-BEGIN => _CoProvider.Start

--------------------------------
@ $<_Statement>
STATE _Statement.RootStart
    TOKEN-BEGIN => _Statement.Start

--------------------------------
@ $<_Attribute>
STATE _Attribute.RootStart
    TOKEN-BEGIN => _Attribute.Start

--------------------------------
@ $<_Namespace>
STATE _Namespace.RootStart
    TOKEN-BEGIN => _Namespace.Start

--------------------------------
@ $<_FunctionArgument>
STATE _FunctionArgument.RootStart
    TOKEN-BEGIN => _FunctionArgument.Start

--------------------------------
@ $<_Function>
STATE _Function.RootStart
    TOKEN-BEGIN => _Function.Start

--------------------------------
@ $<_Variable>
STATE _Variable.RootStart
    TOKEN-BEGIN => _Variable.Start

--------------------------------
@ $<_Event>
STATE _Event.RootStart
    TOKEN-BEGIN => _Event.Start

--------------------------------
@ $<_Property>
STATE _Property.RootStart
    TOKEN-BEGIN => _Property.Start

--------------------------------
@ $<_BaseConstructorCall>
STATE _BaseConstructorCall.RootStart
    TOKEN-BEGIN => _BaseConstructorCall.Start

--------------------------------
@ $<_Constructor>
STATE _Constructor.RootStart
    TOKEN-BEGIN => _Constructor.Start

--------------------------------
@ $<_Destructor>
STATE _Destructor.RootStart
    TOKEN-BEGIN => _Destructor.Start

--------------------------------
@ $<_ClassBody>
STATE _ClassBody.RootStart
    TOKEN-BEGIN => _ClassBody.Start

--------------------------------
@ $<_Class>
STATE _Class.RootStart
    TOKEN-BEGIN => _Class.Start

--------------------------------
@ $<_EnumItemInt>
STATE _EnumItemInt.RootStart
    TOKEN-BEGIN => _EnumItemInt.Start

--------------------------------
@ $<_EnumItemA>
STATE _EnumItemA.RootStart
    TOKEN-BEGIN => _EnumItemA.Start

--------------------------------
@ $<_EnumItemB>
STATE _EnumItemB.RootStart
    TOKEN-BEGIN => _EnumItemB.Start

--------------------------------
@ $<_Enum>
STATE _Enum.RootStart
    TOKEN-BEGIN => _Enum.Start

--------------------------------
@ $<_StructMember>
STATE _StructMember.RootStart
    TOKEN-BEGIN => _StructMember.Start

--------------------------------
@ $<_Struct>
STATE _Struct.RootStart
    TOKEN-BEGIN => _Struct.Start

--------------------------------
@ $<_APConfig>
STATE _APConfig.RootStart
    TOKEN-BEGIN => _APConfig.Start

--------------------------------
@ $<_AutoProperty>
STATE _AutoProperty.RootStart
    TOKEN-BEGIN => _AutoProperty.Start

--------------------------------
@ $<_CastResultInterface>
STATE _CastResultInterface.RootStart
    TOKEN-BEGIN => _CastResultInterface.Start

--------------------------------
@ $<_SharedDeclarationBranch>
STATE _SharedDeclarationBranch.RootStart
    TOKEN-BEGIN => _SharedDeclarationBranch.Start

--------------------------------
@ $<_MemberDeclarationBranch>
STATE _MemberDeclarationBranch.RootStart
    TOKEN-BEGIN => _MemberDeclarationBranch.Start

--------------------------------
@ $<_Declaration>
STATE _Declaration.RootStart
    TOKEN-BEGIN => _Declaration.Start

--------------------------------
@ $<_ClassMember>
STATE _ClassMember.RootStart
    TOKEN-BEGIN => _ClassMember.Start

--------------------------------
@ $<_MemberDeclaration>
STATE _MemberDeclaration.RootStart
    TOKEN-BEGIN => _MemberDeclaration.Start

--------------------------------
@ $<_UsingFragment>
STATE _UsingFragment.RootStart
    TOKEN-BEGIN => _UsingFragment.Start

@ <_UsingFragment>
STATE _UsingFragment.Start
    [NAME] => _UsingFragment.1
        ASSIGN name
        CREATE ModuleUsingNameFragment
    [MUL "*"] => _UsingFragment.1
        CREATE ModuleUsingWildCardFragment

<_UsingFragment>: NAME : name as ModuleUsingNameFragment@
<_UsingFragment>: "*" as ModuleUsingWildCardFragment@
STATE _UsingFragment.1
    EPSILON => _UsingFragment.2

<_UsingFragment>: NAME : name as ModuleUsingNameFragment@
<_UsingFragment>: "*" as ModuleUsingWildCardFragment@
END STATE _UsingFragment.2
    TOKEN-FINISH => _UsingFragment.RootEnd
    NORMAL-REDUCE => _UsingItem.1
        REDUCE [_UsingItem.Start => _UsingItem.1] 
        ASSIGN fragments
    NORMAL-REDUCE => _UsingItem.1
        REDUCE [_UsingItem.1 => _UsingItem.1] 
        ASSIGN fragments

$<_UsingFragment> @
STATE _UsingFragment.RootEnd

<_UsingItem>: _UsingFragment : fragments@ { _UsingFragment : fragments } as ModuleUsingItem
<_UsingItem>: _UsingFragment : fragments @{ _UsingFragment : fragments } as ModuleUsingItem
STATE _UsingItem.1
    EPSILON => _UsingItem.2
        CREATE ModuleUsingItem
    EPSILON => _UsingFragment.Start
        SHIFT [_UsingItem.1 => _UsingItem.1] 

<_UsingItem>: _UsingFragment : fragments { _UsingFragment : fragments } as ModuleUsingItem@
END STATE _UsingItem.2
    TOKEN-FINISH => _UsingItem.RootEnd
    NORMAL-REDUCE => _UsingPath.2
        REDUCE [_UsingPath.1 => _UsingPath.2] 
        ASSIGN items

$<_UsingItem> @
STATE _UsingItem.RootEnd

<_UsingPath>: "using" _UsingItem : items@ { "::" _UsingItem : items } ";" as ModuleUsingPath
<_UsingPath>: "using" _UsingItem : items @{ "::" _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.2
    [SCOPE_DELIMITER "::"] => _UsingPath.1
    [SEMICOLON ";"] => _UsingPath.3

<_UsingPath>: "using"@ _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath
<_UsingPath>: "using" _UsingItem : items { "::"@ _UsingItem : items } ";" as ModuleUsingPath
STATE _UsingPath.1
    EPSILON => _UsingItem.Start
        SHIFT [_UsingPath.1 => _UsingPath.2] 

<_UsingPath>: "using" _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath@
STATE _UsingPath.3
    EPSILON => _UsingPath.4
        CREATE ModuleUsingPath

@ <_UsingItem>
STATE _UsingItem.Start
    EPSILON => _UsingFragment.Start
        SHIFT [_UsingItem.Start => _UsingItem.1] 

<_UsingPath>: "using" _UsingItem : items { "::" _UsingItem : items } ";" as ModuleUsingPath@
END STATE _UsingPath.4
    TOKEN-FINISH => _UsingPath.RootEnd
    NORMAL-REDUCE => _Module.3
        REDUCE [_Module.3 => _Module.3] 
        ASSIGN paths

$<_UsingPath> @
STATE _UsingPath.RootEnd

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";"@ { _UsingPath : paths } { _Declaration : declarations } as Module
<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name ";" @{ _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.3
    EPSILON => _Module.4
        CREATE Module
    EPSILON => _Declaration.Start
        SHIFT [_Module.3 => _Module.5] 
    EPSILON => _UsingPath.Start
        SHIFT [_Module.3 => _Module.3] 

@ <_UsingPath>
STATE _UsingPath.Start
    [KEYWORD_USING "using"] => _UsingPath.1

--------------------------------
@ $<_UsingItem>
STATE _UsingItem.RootStart
    TOKEN-BEGIN => _UsingItem.Start

--------------------------------
@ $<_UsingPath>
STATE _UsingPath.RootStart
    TOKEN-BEGIN => _UsingPath.Start

--------------------------------
@ $<_Module>
STATE _Module.RootStart
    TOKEN-BEGIN => _Module.Start

@ <_Module>
STATE _Module.Start
    [KEYWORD_MODULE "module"] => _Module.1
        SET moduleType => Module
    [KEYWORD_UNIT "unit"] => _Module.1
        SET moduleType => Unit

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) )@ NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module
<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) )@ NAME : name ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.1
    [NAME] => _Module.2
        ASSIGN name

<_Module>: ( ( "module" with { moduleType = "Module" } ) | ( "unit" with { moduleType = "Unit" } ) ) NAME : name@ ";" { _UsingPath : paths } { _Declaration : declarations } as Module
STATE _Module.2
    [SEMICOLON ";"] => _Module.3

--------------------------------
